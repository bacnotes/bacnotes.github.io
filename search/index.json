[{"content":"什麼是 Hook?  Hook 是 JavaScript 函式，react 提供的內建 Hook 為 use 開頭的函式(e.g. useEffect、useReducer、useContext) 只能用在 React 的 Function Component 跟 custom Hook，class Component 無法，當然自己寫的 function 也無法 使用時需要寫在元件內第一層，不能巢狀到，也不要在迴圈、條件判斷下使用  什麼是 Effect(Side Effect)? React 主要工作是\n 評估是否渲染元件在畫面上 管理狀態跟 props 表單與事件處理(使用者互動) 根據狀態和 props 的更新評估是否重新渲染部分畫面  Side Effect: 非 React 的工作，跟渲染畫面無直接相關，包含儲存資料發送 http 請求跟設定 timer，驗證邏輯，手動操作 DOM 都是 Side Effect\nSide Effect 可能造成的結果\n 非同步操作可能會阻塞渲染工作 跟伺服器請求資料可能會造成無限循環：發送請求-\u0026gt;請求結果返回-\u0026gt;set 新狀態-\u0026gt;狀態改變-\u0026gt;重新渲染元件-\u0026gt;觸發發送請求\u0026hellip;  使用 useEffect 來管理 Effect(Side Effect)  useEffect(()=\u0026gt; {\u0026hellip;}, [dependencies]) 用來限制元件 re-render 執行的程式碼 若沒有相依某個參數，掛載元件跟更新資料都會執行，寫跟沒寫一樣 若有相依某個參數，re-render 時參數有改變的話可以重新觸發 useEffect 裡面的函式 []相依空陣列，第一次渲染完會觸發，因空陣列資料不變，所以後續都不會觸發 [state]相依狀態，第一次渲染完會觸發，且每次狀態改變都會跑一次 [props]相依 props，第一次渲染完會觸發，props 更新都會跑一次 發生時間點為畫面渲染完，控制好觸發時機點，避免不必要的觸發 相依空陣列範例  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  // 渲染登入頁面時，確認localStorage登入驗證資訊，只執行一次 function App() { const [isLoggedIn, setIsLoggedIn] = useState(false); // 第一次渲染完會觸發，後續狀態/props更新不會run  useEffect(() =\u0026gt; { const storedUserLoggedInInformation = localStorage.getItem(\u0026#34;isLoggedIn\u0026#34;); if (storedUserLoggedInInformation === \u0026#34;1\u0026#34;) { setIsLoggedIn(true); } }, []); const loginHandler = (email, password) =\u0026gt; { // We should of course check email and password  // But it\u0026#39;s just a dummy/ demo anyways  localStorage.setItem(\u0026#34;isLoggedIn\u0026#34;, \u0026#34;1\u0026#34;); setIsLoggedIn(true); }; const logoutHandler = () =\u0026gt; { // 登出時移除登入驗證  localStorage.removeItem(\u0026#34;isLoggedIn\u0026#34;); setIsLoggedIn(false); }; // 若有登入驗證資訊 渲染Home頁面 沒有則渲染Login頁面  return ( \u0026lt;React.Fragment\u0026gt; \u0026lt;MainHeader isAuthenticated={isLoggedIn} onLogout={logoutHandler} /\u0026gt; \u0026lt;main\u0026gt; {!isLoggedIn \u0026amp;\u0026amp; \u0026lt;Login onLogin={loginHandler} /\u0026gt;} {isLoggedIn \u0026amp;\u0026amp; \u0026lt;Home onLogout={logoutHandler} /\u0026gt;} \u0026lt;/main\u0026gt; \u0026lt;/React.Fragment\u0026gt; ); }    相依 enteredEmail、enteredPassword 表單狀態  1 2 3 4 5 6 7 8 9 10 11 12 13 14  const Login = (props) =\u0026gt; { const [enteredEmail, setEnteredEmail] = useState(\u0026#39;\u0026#39;); const [emailIsValid, setEmailIsValid] = useState(); const [enteredPassword, setEnteredPassword] = useState(\u0026#39;\u0026#39;); const [passwordIsValid, setPasswordIsValid] = useState(); const [formIsValid, setFormIsValid] = useState(false); // 第一次會執行，後續表單狀態更新也會執行（驗證程式碼）  useEffect(() =\u0026gt; { setFormIsValid( enteredEmail.includes(\u0026#39;@\u0026#39;) \u0026amp;\u0026amp; enteredPassword.trim().length \u0026gt; 6 ); }, [enteredEmail, enteredPassword]); ... }   不需加入相依的參數  更新狀態的函式 setXXX 元件外的變數或函式  應該加入的相依參數  \u0026ldquo;things\u0026rdquo; could change because your component (or some parent component) re-rendered  用 setTimeout 優化觸發時間點，搭配 cleanup 清除功能  若不要每個 key 下去的動作都觸發驗證功能，可以用 setTimeout 一段時間再觸發 effect(非最佳解，後面還有其他做法) useEffect 裡面的 return 函式，只會在 unmount，元件要被從 DOM 卸載時觸發  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  const Login = (props) =\u0026gt; { const [enteredEmail, setEnteredEmail] = useState(\u0026#39;\u0026#39;); const [emailIsValid, setEmailIsValid] = useState(); const [enteredPassword, setEnteredPassword] = useState(\u0026#39;\u0026#39;); const [passwordIsValid, setPasswordIsValid] = useState(); const [formIsValid, setFormIsValid] = useState(false); useEffect(() =\u0026gt; { const identifier = setTimeout(() =\u0026gt; { // 第一次觸發，後續per 0.5秒觸發  console.log(\u0026#39;Checking form validity!\u0026#39;); setFormIsValid( enteredEmail.includes(\u0026#39;@\u0026#39;) \u0026amp;\u0026amp; enteredPassword.trim().length \u0026gt; 6 ); }, 500); // return內容需要是一個function  // 下方程式碼不會在第一次渲染觸發，元件更新才會觸發(when unmounts from the DOM, the component is reused)  return () =\u0026gt; { console.log(\u0026#39;CLEANUP\u0026#39;); //在新的Timer設置前先把舊的Timer刪除  clearTimeout(identifier); }; }, [enteredEmail, enteredPassword]); const emailChangeHandler = (event) =\u0026gt; { setEnteredEmail(event.target.value); }; ... }   官方說明不需要搭配 cleanup 的 Effect  fetch data、手動操作 DOM、輸出 log 紀錄（不用追蹤後續） get 方法讓個別頁面獲取不同資料(把 dummyData 換成實際 server 資料)  需搭配 cleanup 的 Effect  訂閱監聽事件，監聽事件 避免 memory leak  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  import React, { useState, useEffect } from \u0026#34;react\u0026#34;; function FriendStatus(props) { const [isOnline, setIsOnline] = useState(null); useEffect(() =\u0026gt; { function handleStatusChange(status) { setIsOnline(status.isOnline); } ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); // Specify how to clean up after this effect:  return function cleanup() { ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); }; }); if (isOnline === null) { return \u0026#34;Loading...\u0026#34;; } return isOnline ? \u0026#34;Online\u0026#34; : \u0026#34;Offline\u0026#34;; }   useReducer 管理複雜狀態邏輯   當寫 useState 開始覺得不好管理狀態，或需要處理複雜邏輯的時候可以考慮使用 useReducer\n  const [state, dispatchFn] = useReducer(reducerFn, initState, initFn)\n  dispatchFn 觸發 action，action 觸發 reducerFn\n  reducer 會收到上一個狀態跟 action 參數，並且回傳新的 state\n  reducerFn (prevState, action) =\u0026gt; newState\n  initFn 可以用來設定 initState，如果比較複雜的話，需要外部資料等等\n  使用 useReducer 管理 email 跟 password input 狀態(effect 相依參數改成驗證狀態，減少不必要觸發)\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102  // reducerFn寫在元件外面，相關參數會透過dispatch傳入 const emailReducer = (state, action) =\u0026gt; { // 收到dispatch事件同時更新input值跟isValid狀態  if (action.type === \u0026#39;USER_INPUT\u0026#39;) { return { value: action.value, isValid: action.value.includes(\u0026#39;@\u0026#39;) }; } // 點其他Input會Blur  if (action.type === \u0026#39;INPUT_BLUR\u0026#39;) { // 這邊Blur事件不會傳遞值，但需要有一個值維持狀態  // state.value可以拿到最新的state  return { value: state.value, isValid: state.value.includes(\u0026#39;@\u0026#39;) }; // includes驗證會回傳true false  } return { value: \u0026#39;\u0026#39;, isValid: false }; }; const passwordReducer = (state, action) =\u0026gt; { if (action.type === \u0026#39;USER_INPUT\u0026#39;) { return { value: action.value, isValid: action.value.trim().length \u0026gt; 6 }; } // 點其他Input會Blur  if (action.type === \u0026#39;INPUT_BLUR\u0026#39;) { // 這邊Blur事件不會傳遞值，但需要有一個值維持狀態  // state.value可以拿到最新的state  return { value: state.value, isValid: state.value.trim().length \u0026gt; 6 }; // includes驗證會回傳true false  } return {value:\u0026#39;\u0026#39;, isValid: false} } const Login = (props) =\u0026gt; { // const [enteredEmail, setEnteredEmail] = useState(\u0026#39;\u0026#39;);  // const [emailIsValid, setEmailIsValid] = useState();  // const [enteredPassword, setEnteredPassword] = useState(\u0026#39;\u0026#39;);  // const [passwordIsValid, setPasswordIsValid] = useState();  const [formIsValid, setFormIsValid] = useState(false); const [emailState, dispatchEmail] = useReducer(emailReducer, { value: \u0026#39;\u0026#39;, isValid: null, }); // 上面是initState  const [passwordState, dispatchPassword] = useReducer(passwordReducer, { value:\u0026#39;\u0026#39;, isValid: null }) useEffect(() =\u0026gt; { console.log(\u0026#39;EFFECT RUNNING\u0026#39;); return () =\u0026gt; { console.log(\u0026#39;EFFECT CLEANUP\u0026#39;); }; }, []); // 解構賦值，改換另一個變數名  const { isValid: emailIsValid } = emailState; const { isValid: passwordIsValid } = passwordState; useEffect(() =\u0026gt; { const identifier = setTimeout(() =\u0026gt; { console.log(\u0026#39;Checking form validity!\u0026#39;); setFormIsValid(emailIsValid \u0026amp;\u0026amp; passwordIsValid); }, 500); return () =\u0026gt; { console.log(\u0026#39;CLEANUP\u0026#39;); clearTimeout(identifier); }; // 改由驗證有更新再re-run effect來優化效能  }, [emailIsValid, passwordIsValid]); const emailChangeHandler = (event) =\u0026gt; { // 通常是一個物件 {type:\u0026#39;\u0026#39;, 也可以寫payload要跟上面reducer action內key值一樣: 傳遞下去的值}  dispatchEmail({type: \u0026#39;USER_INPUT\u0026#39;, value: event.target.value}); setFormIsValid( event.target.value.includes(\u0026#39;@\u0026#39;) \u0026amp;\u0026amp; enteredPassword.trim().length \u0026gt; 6 ); }; const passwordChangeHandler = (event) =\u0026gt; { dispatchPassWord({type:\u0026#39;USER_INPUT\u0026#39;, value:event.target.value}) setFormIsValid( emailState.isValid \u0026amp;\u0026amp; event.target.value.trim().length \u0026gt; 6 ); }; const validateEmailHandler = () =\u0026gt; { dispatchEmail({type: \u0026#39;INPUT_BLUR\u0026#39;}); }; const validatePasswordHandler = () =\u0026gt; { dispatchPassword({type: \u0026#39;INPUT_BLUR\u0026#39;}); }; const submitHandler = (event) =\u0026gt; { event.preventDefault(); // state取值用state.value  props.onLogin(emailState.value, passwordState.value); };    上述的解構賦值很常用在取相依參數，也可以用取屬性的方式  1 2 3 4 5 6 7 8  const { someProperty } = someObject; useEffect(() =\u0026gt; { // code that only uses someProperty ... }, [someProperty]); useEffect(() =\u0026gt; { // code that only uses someProperty ... }, [someObject.someProperty]);    記得避免直接寫整個物件，因為物件傳值，彼此就算長一樣地址也不會相同  useContext 管理全域 State  好處：不用透過長長的 prop chain 直接傳遞資料 流程：先透過 React.createContext 創造一個變數，透過 AuthContext 輸出，其他元件用 useContext 引用相對應的 context 檔案獲取物件值  1 2 3 4 5 6 7 8  // src/store import { createContext } from \u0026#34;react\u0026#34;; // 建立一個context物件 裡面放初始值 const AuthContext = createContext({ isLoggedIn: false, }); export default AuthContext;    \u0026lt;AuthContext.Provider\u0026gt;...\u0026lt;/AuthContext.Provider\u0026gt;透過 Provider 屬性可以獲取 AuthContext 而包裹在\u0026lt;AuthContext.Provider\u0026gt;之間的元件都可以獲取這個 AuthContext  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // App.js // import context變數 import AuthContext from \u0026#39;./store/auth-context\u0026#39;; function App() { const [isLoggedIn, setIsLoggedIn] = useState(false); ... return ( // 如果有預設值基本上不需要寫value，但若有會變動的值，要透過value傳入更新狀態，只能透過Provider來做  \u0026lt;AuthContext.Provider value={{ isLoggedIn: isLoggedIn, // context物件裡面的value 也可以放函式  onLoggedOut: () =\u0026gt; {}, }} \u0026gt; \u0026lt;MainHeader onLogout={logoutHandler} /\u0026gt; \u0026lt;main\u0026gt; {!isLoggedIn \u0026amp;\u0026amp; \u0026lt;Login onLogin={loginHandler} /\u0026gt;} {isLoggedIn \u0026amp;\u0026amp; \u0026lt;Home onLogout={logoutHandler} /\u0026gt;} \u0026lt;/main\u0026gt; \u0026lt;/AuthContext.Provider\u0026gt; ); export default App;    在 Navbar 來獲取變數  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  import React, { useContext } from \u0026#34;react\u0026#34;; import AuthContext from \u0026#34;../../store/auth-context\u0026#34;; const Navigation = () =\u0026gt; { // 使用useContext 指向特定context獲取value(物件)  const ctx = useContext(AuthContext); return ( \u0026lt;nav className={classes.nav}\u0026gt; \u0026lt;ul\u0026gt; {ctx.isLoggedIn \u0026amp;\u0026amp; ( \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#39;/\u0026#39;\u0026gt;Users\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; )} {ctx.isLoggedIn \u0026amp;\u0026amp; ( \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#39;/\u0026#39;\u0026gt;Admin\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; )} {ctx.isLoggedIn \u0026amp;\u0026amp; ( \u0026lt;li\u0026gt; \u0026lt;button onClick={ctx.onLogout}\u0026gt;Logout\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; )} \u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt; ); }; export default Navigation;    重構：把登入登出 Auth 相關的函式都放在 context 管理  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  import React, { useState, useEffect } from \u0026#34;react\u0026#34;; const AuthContext = React.createContext({ isLoggedIn: false, onLogout: () =\u0026gt; {}, onLogin: (email, password) =\u0026gt; {}, }); // 新增 export const AuthContextProvider = (props) =\u0026gt; { const [isLoggedIn, setIsLoggedIn] = useState(false); useEffect(() =\u0026gt; { const storedUserLoggedInInformation = localStorage.getItem(\u0026#34;isLoggedIn\u0026#34;); if (storedUserLoggedInInformation === \u0026#34;1\u0026#34;) { setIsLoggedIn(true); } }, []); const logoutHandler = () =\u0026gt; { localStorage.removeItem(\u0026#34;isLoggedIn\u0026#34;); setIsLoggedIn(false); }; const loginHandler = () =\u0026gt; { localStorage.setItem(\u0026#34;isLoggedIn\u0026#34;, \u0026#34;1\u0026#34;); setIsLoggedIn(true); }; return ( \u0026lt;AuthContext.Provider value={{ isLoggedIn: isLoggedIn, onLogout: logoutHandler, onLogin: loginHandler, }}\u0026gt; {props.children} \u0026lt;/AuthContext.Provider\u0026gt; ); }; export default AuthContext;    把\u0026lt;AuthContextProvider\u0026gt;包裹全域監聽放到 index.js  1 2 3 4 5 6 7 8 9 10 11 12 13  import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; import \u0026#34;./index.css\u0026#34;; import App from \u0026#34;./App\u0026#34;; import { AuthContextProvider } from \u0026#34;./store/auth-context\u0026#34;; ReactDOM.render( \u0026lt;AuthContextProvider\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/AuthContextProvider\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;) );    App.js 跟 Navbar 只要引用 Context 的資料  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  //App.js import AuthContext from \u0026#34;./store/auth-context\u0026#34;; function App() { const ctx = useContext(AuthContext); return ( \u0026lt;React.Fragment\u0026gt; \u0026lt;MainHeader /\u0026gt; \u0026lt;main\u0026gt; {!ctx.isLoggedIn \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt;} {ctx.isLoggedIn \u0026amp;\u0026amp; \u0026lt;Home /\u0026gt;} \u0026lt;/main\u0026gt; \u0026lt;/React.Fragment\u0026gt; ); } export default App;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  // Navbar import AuthContext from \u0026#34;../../store/auth-context\u0026#34;; const Navigation = () =\u0026gt; { const ctx = useContext(AuthContext); return ( \u0026lt;nav className={classes.nav}\u0026gt; \u0026lt;ul\u0026gt; {ctx.isLoggedIn \u0026amp;\u0026amp; ( \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#39;/\u0026#39;\u0026gt;Users\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; )} {ctx.isLoggedIn \u0026amp;\u0026amp; ( \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#39;/\u0026#39;\u0026gt;Admin\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; )} {ctx.isLoggedIn \u0026amp;\u0026amp; ( \u0026lt;li\u0026gt; \u0026lt;button onClick={ctx.onLogout}\u0026gt;Logout\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; )} \u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt; ); }; export default Navigation;   useContext 的限制  不適合頻繁更動的資料（每秒好幾次)，使用 redux 鄰近父子元件還是建議透過 props 傳遞資料，而非用 useContext 取代  如果還想多了解 React 的朋友，可以繼續閱讀這篇自學 React 的你需要知道的一些知識｜ React - The Complete Guide\n","date":"2022-02-03T00:00:00+08:00","image":"https://bacnotes.github.io/p/react-effect-reducer-context/pexels-rodolpho-zanardo-1309095_hu3d03a01dcc18bc5be0e67db3d8d209a6_4924053_120x120_fill_q75_box_smart1.jpg","permalink":"https://bacnotes.github.io/p/react-effect-reducer-context/","title":"React 必須了解的3大Hooks：useEffect、useReducer、useContext｜React - The Complete Guide｜bacnotes備份筆記"},{"content":"元件該怎麼添加 CSS 樣式? 主要方法有四種：\n Inline style 直接給他寫上去(最難維護) CSS(全域套用容易撞名) Styled Component(CSS in JS) CSS modules(CSS JS 分離)  inline style 撰寫動態樣式  useState 來更新有效無效狀態 沒效套用紅色，有效套用黑色  1 2 3 4 5 6 7 8 9 10 11 12 13 14  const Input = props =\u0026gt; { const [ enteredValue, setEnteredValue ] = useState(\u0026#39;\u0026#39;) const [ isValid, setIsValid ] = useState(true) const goalInputChangeHandler = event =\u0026gt; { setEnteredValue(event.target.value); }; if(enteredValue.trim().length === 0){ setIsValid(false) return } return( \u0026lt;input style ={{ borderColor: !isValid ? \u0026#39;red\u0026#39; : \u0026#39;Black\u0026#39;, background: !isValid ? \u0026#39;red\u0026#39; : \u0026#39;Black\u0026#39;}} onChange={goalInputChangeHandler}\u0026gt; ) }   為什麼不用 inline style 撰寫動態樣式?  分散在 html 程式的樣式不好管理 inline style 會覆蓋掉其他 CSS 樣式(權重僅次!important)，找改動點更費時  CSS 撰寫動態樣式  把剛剛的樣式貼到 CSS file  1 2 3 4 5 6 7 8 9 10  .form-control { outline: none; background: pink; border-corlor: red; ...等等其他固定的樣式; } .invalid { border-color: red; background: red; }    拿掉 inline style ，動態添加 className 上一篇\u0026quot;有提到 class 是 JavaScript 的保留字，所以不使用 class  1 2  // 固定樣式form-control搭配動態樣式isValid  \u0026lt;input className={`form-control ${!isValid ? \u0026#39;invalid\u0026#39; : \u0026#39;\u0026#39; }`} onChange={goalInputChangeHandler}\u0026gt;   為什麼不用 CSS 撰寫動態樣式  因為樣式會套用在全域環境，即生效在所有元件上，而大型專案上在 className 命名的時候很難避免撞名，樣式容易發生衝突 使用 Styled Component 套件來創造 scoped CSS  Styled Component 撰寫動態樣式 安裝套件跟撰寫方式  cd 到專案資料夾 npm install --save styled-components const Input = styled.html 元素CSS樣式 (attacked template literal) styled package 有所有 html 元素的方法，透過``可以撰寫多行 CSS 樣式，指定到對應 html 元素當中 動態產生獨特 hash  1 2 3 4 5 6 7 8 9 10 11 12 13 14  import styled from \u0026#34;styled-components\u0026#34;; const Input = styled.input` font: inherit; padding: 0.5rem 1.5rem; // 偽元素選擇器 \u0026amp;:focus { outline: none; } \u0026amp;:hover, \u0026amp;:active { background: #ac2342; } `;   使用 props 動態管理樣式  可以拿掉一些不必要的 CSS 樣式(form-control.invalid input 這種聯集的選擇器)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  import styled from \u0026#39;styled-components\u0026#39;; const FormControl = styled.div` margin: 0.5rem 0; \u0026amp;:label { font-weight: bold; display: block; margin-bottom: 0.5rem; color: ${props =\u0026gt; (props.invalid ? \u0026#39;red\u0026#39; : \u0026#39;black\u0026#39;)}; } \u0026amp;:input { display: block; width: 100%; border: 1px solid ${props =\u0026gt; (props.invalid ? \u0026#39;red\u0026#39; : \u0026#39;#ccc\u0026#39;)}; background: ${props =\u0026gt; (props.invalid ? \u0026#39;#ffd7d7\u0026#39; : \u0026#39;transparent\u0026#39;)}; font: inherit; line-height: 1.5rem; padding: 0 0.25rem; } \u0026amp;:input:focus { outline: none; background: #fad0ec; border-color: #8b005d; } `; ... return ( \u0026lt;form onSubmit={formSubmitHandler}\u0026gt; // 原本CSS\u0026lt;div className={`form-control ${!isValid ? \u0026#39;invalid\u0026#39;:\u0026#39;\u0026#39;}`}\u0026gt;  // 改成FormControl是一個帶有樣式的 div  // 動態className改成invalid或valid透過props 布林值決定  \u0026lt;FormControl invalid={!isValid}\u0026gt; \u0026lt;label\u0026gt;Course Goal\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; onChange={goalInputChangeHandler} /\u0026gt; \u0026lt;/FormControl\u0026gt; \u0026lt;Button type=\u0026#34;submit\u0026#34;\u0026gt;Add Goal\u0026lt;/Button\u0026gt; \u0026lt;/form\u0026gt; );   style component 使用 media queries 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  const Button = styled.button` // 手機版展開 width: 100%; font: inherit; padding: 0.5rem 1.5rem; border: 1px solid #8b005d; color: white; background: #8b005d; box-shadow: 0 0 4px rgba(0, 0, 0, 0.26); cursor: pointer; // 平板變小 @media (min-width: 768px) { width: auto; } \u0026amp;:focus { outline: none; } \u0026amp;:hover, \u0026amp;:active { background: #ac0e77; border-color: #ac0e77; box-shadow: 0 0 8px rgba(0, 0, 0, 0.26); } `;   style component 的優缺點  優點：不用想 className 名字了 缺點：隨機的 hash 不容易 debug，但透過安裝 babel-plugin-styled-components 可以在瀏覽器看到元件名稱 適合喜歡 CSS 跟 JS 邏輯寫在一起的人  CSS modules  不用安裝套件，CRA 本身支援 CSS modules 把副檔名.css 檔案改成.module.css，引用路徑也要改 className = {styles.樣式選擇器名} 瀏覽器看到 class 名為：元件名_class 名__hash，因此不會撞名 class 名若有橫線-連接，寫法需要改成${style['form-control']}  1 2 3 4 5 6 7 8 9 10 11 12  // import後面的變數名自由命名，會當作物件(整包樣式屬性)傳入，這邊以styles為範例 import styles from \u0026#34;./Button.module.css\u0026#34;; const Button = (props) =\u0026gt; { return ( // 這邊  \u0026lt;button type={props.type} className={styles.button} onClick={props.onClick}\u0026gt; {props.children} \u0026lt;/button\u0026gt; ); }; export default Button;   CSS modules 使用 media queries  一樣寫在 CSS 檔案就好  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  .button { width: 100%; font: inherit; padding: 0.5rem 1.5rem; border: 1px solid #8b005d; color: white; background: #8b005d; box-shadow: 0 0 4px rgba(0, 0, 0, 0.26); cursor: pointer; } .button:focus { outline: none; } .button:hover, .button:active { background: #ac0e77; border-color: #ac0e77; box-shadow: 0 0 8px rgba(0, 0, 0, 0.26); } @media (min-width: 768px) { .button { width: auto; } }   CSS modules 的優缺點  優點：命名時不用擔心撞名，hash 維持獨特性 缺點：需要改副檔名，一開始沒導入後面手動要改比較累一點 適合喜歡 CSS 跟 JS 分離的人  ","date":"2022-02-02T00:00:00+08:00","image":"https://bacnotes.github.io/p/react-styling/pexels-vlada-karpovich-7025515_hu3d03a01dcc18bc5be0e67db3d8d209a6_3812665_120x120_fill_q75_box_smart1.jpg","permalink":"https://bacnotes.github.io/p/react-styling/","title":"React CSS撰寫方式好多種，我該怎麼選？｜React - The Complete Guide｜bacnotes備份筆記"},{"content":"這是一個懶人包整理～！祝大家新年快樂！\n字串可以使用部分陣列的方法 根據索引取值 1 2 3 4 5  const airline = \u0026#34;TAP Air Portugal\u0026#34;; const plane = \u0026#34;A320\u0026#34;; console.log(plane[0]); // A console.log(\u0026#34;B35\u0026#34;[0]); // B console.log(plane.length); // 4   indexOf()、lastIndexOf() 找索引位置  indexOf(searchElement, fromIndex) 由前往後找值的索引，第 2 個參數是 option lastIndexOf(searchElement, fromIndex) 由後往前找值的索引，第 2 個參數是 option 若不存在則回傳 -1  1 2 3 4  const airline = \u0026#34;TAP Air Portugal\u0026#34;; const plane = \u0026#34;A320\u0026#34;; console.log(airline.indexOf(\u0026#34;r\u0026#34;)); // 6 console.log(airline.lastIndexOf(\u0026#34;r\u0026#34;)); // 10 後往前找    會判別字母大小寫(case-sensitive)  1 2  console.log(airline.indexOf(\u0026#34;portugal\u0026#34;)); // -1 console.log(airline.indexOf(\u0026#34;Portugal\u0026#34;)); // 8    淺拷貝 slice(start, end)，預設 slice(0, arr.length)，回傳選取範圍之陣列 若有指定 end，所在的元素不會被納入 無法使用 splice 因為字串是 immutable  1  console.log(airline.slice(4)); // Air Portugal    切出第一個字(不包含空白)  1  console.log(airline.slice(0, airline.indexOf(\u0026#34; \u0026#34;))); // TAP    寫一個判斷字串尾端有無 B 或 E 的 function，來判段機位位置 e.g. 11B 23C  1 2 3 4 5 6 7  const checkMiddleSeat = function (seat) { const position = seat.slice(-1); if (position === \u0026#34;B\u0026#34; || position === \u0026#34;E\u0026#34;) console.log(\u0026#34;middle seat\u0026#34;); else console.log(\u0026#34;not middle seat\u0026#34;); }; checkMiddleSeat(\u0026#34;11B\u0026#34;); // middle seat checkMiddleSeat(\u0026#34;11C\u0026#34;); // not middle seat   toUpperCase()、toLowerCase()轉大小寫 1 2 3 4 5 6 7 8 9 10  const airline = \u0026#34;TAP Air Portugal\u0026#34;; console.log(airline.toLowerCase()); // tap air portugal console.log(airline.toUpperCase()); // TAP AIR PORTUGAL  // 把大小寫混亂的字轉開頭大寫，後面小寫 const name = \u0026#34;jOnAs\u0026#34;; const nameLower = name.toLowerCase(); const nameCorrect = nameLower[0].toUpperCase() + nameLower.slice(1); console.log(nameCorrect); // Jonas   trim()、trimStart()、trimEnd() 移除泛空白字元(後兩個 IE 沒有支援)  trim() 刪除兩端所有空白 trimStart() 將刪除字串開頭的所有空白 trimEnd() 將刪除字串末尾的所有空白  1 2 3 4 5 6  // email輸入剪掉空白跟轉換成小寫 const email = \u0026#34;hello@jonas.io\u0026#34;; // 正確email資料 const loginEmail = \u0026#34; Hello@jonas.Io\\n\u0026#34;; // 輸入時大小寫混用+空白+enter  const normalizedEmail = loginEmail.toLowerCase().trim(); console.log(normalizedEmail); // hello@jonas.io   replace()、replaceAll() 字串取代，會回傳一個新字串(後者 IE 沒有支援)  replace(regexp|substr, newSubstr|function)第二個參數會取代第一個參數  1 2 3  const priceGB = \u0026#34;288,97£\u0026#34;; const priceUS = priceGB.replace(\u0026#34;£\u0026#34;, \u0026#34;$\u0026#34;).replace(\u0026#34;,\u0026#34;, \u0026#34;.\u0026#34;); console.log(priceUS); // 288.97$    當輸入對象是字串，replace 只會取代第一個匹配的，replaceAll 會取代所有匹配的  1 2 3  const p = \u0026#34;abab\u0026#34;; console.log(p.replace(\u0026#34;a\u0026#34;, \u0026#34;A\u0026#34;)); // \u0026#34;Abab\u0026#34; console.log(p.replaceAll(\u0026#34;a\u0026#34;, \u0026#34;A\u0026#34;)); // \u0026#34;AbAb\u0026#34;    當第一個參數為是正則表達式，兩者都會取代所有匹配的  1 2 3  const p = \u0026#34;abab\u0026#34;; console.log(p.replace(/a/g, \u0026#34;A\u0026#34;)); // \u0026#34;AbAb\u0026#34; console.log(p.replaceAll(/a/g, \u0026#34;A\u0026#34;)); // \u0026#34;AbAb\u0026#34;   includes() 檢查是否包含特定字串，回傳 true false  arr.includes(valueToFind, fromIndex)，第 2 個參數 option 區分大小寫，使用零值相等確認元素是否一樣 若 fromIndex 大於陣列長度，直接回傳 false 若 fromIndex 小於 0，會搜尋整個陣列  1 2 3 4  const plane = \u0026#34;Airbus A320neo\u0026#34;; console.log(plane.includes(\u0026#34;A320\u0026#34;)); // true console.log(plane.includes(\u0026#34;Boeing\u0026#34;)); //false console.log(plane.startsWith(\u0026#34;Airb\u0026#34;)); // true    寫一個檢查字串是否有刀槍字串的 function  1 2 3 4 5 6 7 8 9 10 11 12  const checkBaggage = function (items) { const baggage = items.toLowerCase(); // 輸入統一轉小寫，比較好處理檢查  if (baggage.includes(\u0026#34;knife\u0026#34;) || baggage.includes(\u0026#34;gun\u0026#34;)) { console.log(\u0026#34;You are NOT allowed on board\u0026#34;); } else { console.log(\u0026#34;Welcome aboard!\u0026#34;); } }; checkBaggage(\u0026#34;I have a laptop, some Food and a pocket Knife\u0026#34;); // You are NOT allowed on board checkBaggage(\u0026#34;Socks and camera\u0026#34;); // Welcome aboard!   split() 使用指定字串切割字串，切割的結果回傳成一個陣列  split(separator, limit)，第 2 個參數是 option  1 2 3 4 5 6 7 8  console.log(\u0026#34;string\u0026#34;.split(\u0026#34;\u0026#34;)); // [ \u0026#39;s\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;g\u0026#39; ] 沒有寫條件，會以字元為單位切 console.log(\u0026#34;a+very+nice+string\u0026#34;.split(\u0026#34;+\u0026#34;)); // 以+切割 // [ \u0026#39;a\u0026#39;, \u0026#39;very\u0026#39;, \u0026#39;nice\u0026#39;, \u0026#39;string\u0026#39; ] console.log(\u0026#34;Jonas Schmedtmann\u0026#34;.split(\u0026#34; \u0026#34;)); // 以空白切割 // [ \u0026#39;Jonas\u0026#39;, \u0026#39;Schmedtmann\u0026#39; ] const [firstName, lastName] = \u0026#34;Jonas Schmedtmann\u0026#34;.split(\u0026#34; \u0026#34;); // 切割後解構賦值   join() 使用指定字串將陣列元素合併為一個字串  join([separator]) join() // a, b, c join(\u0026rsquo;\u0026rsquo;) // abc join(\u0026rsquo;-\u0026rsquo;) // a-b-c 若陣列只有一個就不使用 join 中的字串 在陣列長度為零、元素為 undefined 或 null 狀況下，回傳空字串  1 2  const newName = [\u0026#34;Mr.\u0026#34;, firstName, lastName.toUpperCase()].join(\u0026#34; \u0026#34;); console.log(newName);    使用 split()跟 join()把名字整理成只有第一個大寫開頭  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // 方法一 const capitalizeName = function (name) { const names = name.split(\u0026#34; \u0026#34;); const nameUpper = []; for (const char of names) { nameUpper.push(char[0].toUpperCase() + char.slice(1)); } console.log(nameUpper.join(\u0026#34; \u0026#34;)); }; capitalizeName(\u0026#34;jessica ann smith davis\u0026#34;); // Jessica Ann Smith Davis  // 方法二 改用replace const capitalizeName = function (name) { const names = name.split(\u0026#34; \u0026#34;); const nameUpper = []; for (const char of names) { nameUpper.push(char.replace(char[0], char[0].toUpperCase())); } console.log(nameUpper.join(\u0026#34; \u0026#34;)); // Jessica Ann Smith Davis };   ＊字串拼接還有一種 concat 方法，但 MDN 強烈建議直接使用運算子 assignment operators (en-US) 來達成， 像是 + 及 += 若想了解 concat 方法，可以參考陣列的處理方法\npadStart()、padEnd()填充字串 (IE 沒有支援)  padStart(targetLength, padString)，從開頭填充字串到指定長度 padEnd(targetLength, padString)，從結尾填充字串到指定長度 第 2 個參數沒寫會填充空白  1 2 3  const message = \u0026#34;Go to gate 23!\u0026#34;; console.log(message.padStart(20, \u0026#34;+\u0026#34;).padEnd(26, \u0026#34;+\u0026#34;)); //++++++Go to gate 23!++++++    信用卡加密  1 2 3 4 5 6 7  const maskCreditCard = function (number) { const str = number + \u0026#34;\u0026#34;; const last = str.slice(-4); return last.padStart(str.length, \u0026#34;*\u0026#34;); }; console.log(maskCreditCard(\u0026#34;334859493847755774747\u0026#34;)); // *****************4747   repeat() 回傳指定數量 copy 字串  repeat(count)  1 2 3 4 5  const planesInLine = function (num) { console.log(`There are ${num}planes in line ${\u0026#34;🛩\u0026#34;.repeat(num)}`); }; planesInLine(5); // There are 5 planes in line 🛩🛩🛩🛩🛩   search()  回傳正規表達式的第一個匹配的 index，若找不到，回傳 -1。  1 2 3 4 5 6 7 8 9 10 11  const paragraph = \u0026#34;The quick brown fox jumps over the lazy dog. If the dog barked, was it really lazy?\u0026#34;; // any character that is not a word character or whitespace const regex = /[^\\w\\s]/g; console.log(paragraph.search(regex)); // expected output: 43  console.log(paragraph[paragraph.search(regex)]); // expected output: \u0026#34;.\u0026#34;   match()  回傳一個字串匹配正規表達式的结果 使用 g 全局比對，回傳所有結果在一個陣列 沒有使用 g，回傳第一個匹配的結果，匹配的起始點，輸入字串本身，捕獲陣列或 undefined  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  const paragraph = \u0026#34;The quick brown fox jumps over the lazy dog. It barked.\u0026#34;; const regex = /[A-Z]/g; const regexNotGlobal = /[A-Z]/; const found = paragraph.match(regex); const foundNotGlobal = paragraph.match(regexNotGlobal); console.log(found); // expected output: Array [\u0026#34;T\u0026#34;, \u0026#34;I\u0026#34;]  console.log(foundNotGlobal); // [ // \u0026#39;T\u0026#39;, // index: 0, // input: \u0026#39;The quick brown fox jumps over the lazy dog. It barked.\u0026#39;, // groups: undefined // ]   綜合練習 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  // Q1 //TEST DATA (pasted to textarea) //underscore_case // first_name //Some_Variable // calculate_AGE //delayed_departure  //SHOULD PRODUCE THIS OUTPUT (5 separate console.log outputs) //underscoreCase ✅ //firstName ✅✅ //someVariable ✅✅✅ //calculateAge ✅✅✅✅ //delayedDeparture ✅✅✅✅✅  document.body.append(document.createElement(\u0026#34;textarea\u0026#34;)); document.body.append(document.createElement(\u0026#34;button\u0026#34;)); const text = document.querySelector(\u0026#34;textarea\u0026#34;).value; document.querySelector(\u0026#34;button\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, function () { const text = document.querySelector(\u0026#34;textarea\u0026#34;).value; const rows = text.split(\u0026#34;\\n\u0026#34;); for (const [i, row] of rows.entries()) { const [first, second] = row.toLowerCase().trim().split(\u0026#34;_\u0026#34;); const output = `${first}${second.replace( second[0], second[0].toUpperCase() )}`.padEnd(20); const check = \u0026#34;✅\u0026#34;.repeat(i + 1); console.log(output + check); } }); // Q2 // const flights = \u0026#39;_Delayed_Departure;fao93766109;txl2133758440;11:25+_Arrival;bru0943384722;fao93766109;11:45+_Delayed_Arrival;hel7439299980;fao93766109;12:05+_Departure;fao93766109;lis2323639855;12:30\u0026#39;;  // 🔴 Delayed Departure from FAO to TXL (11h25) // Arrival from BRU to FAO (11h45) // 🔴 Delayed Arrival from HEL to FAO (12h05) // Departure from FAO to LIS (12h30)  // 抽出共用方法：切出前三個字轉大寫 const getCode = (str) =\u0026gt; str.slice(0, 3).toUpperCase(); for (const item of flights.split(\u0026#34;+\u0026#34;)) { const [status, from, to, time] = item.split(\u0026#34;;\u0026#34;); const signal = status.slice(1).includes(\u0026#34;_\u0026#34;) ? \u0026#34;🔴\u0026#34; : \u0026#34;\u0026#34;; console.log( `${signal}${status.replaceAll(\u0026#34;_\u0026#34;, \u0026#34; \u0026#34;)}${getCode(from)}${getCode( to )}${time.replace(\u0026#34;:\u0026#34;, \u0026#34;h\u0026#34;)}`.padStart(35) ); }   補充：為什麼字串是 Primitives (不是物件)，卻可以呼叫方法  JavaScript 在字串呼叫方法時會把字串轉成物件，這個過程叫 boxing  1 2  console.log(new String(\u0026#34;jonas\u0026#34;)); // String{\u0026#39;jonas\u0026#39;} console.log(typeof new String(\u0026#34;jonas\u0026#34;)); //object    當轉換結束後會再把物件轉回字串  1  console.log(typeof new String(\u0026#34;jonas\u0026#34;).slice(1)); // string   ","date":"2022-01-30T00:00:00+08:00","image":"https://bacnotes.github.io/p/string-methods/pexels-pixabay-278887_hu3d03a01dcc18bc5be0e67db3d8d209a6_1794718_120x120_fill_q75_box_smart1.jpg","permalink":"https://bacnotes.github.io/p/string-methods/","title":"字串的處理方法｜The Complete JavaScript Course｜bacnotes備份筆記"},{"content":"產出好維護好管理的程式碼是重要的，想像今天你的任務是要從這個房間裡找出某一本書，你覺得你需要多少時間？\n如果專案程式碼長這樣的話，還沒開始 debug 腦袋就已經先當機了\u0026hellip;\n物件導向程式設計就是為了解決這個問題而誕生的一種方便管理程式碼的方式\n什麼是物件導向程式設計(Object-Oriented Programming)  基於物件概念的程式設計方法 使用物件形容(model)具體或抽象的 feature(e.g. user, todo-item, 元件或資料結構) 我們把相關屬性跟方法都包在一個物件，可以很方便取得內部資料 物件是獨立的(self-contained)的程式碼片段，透過彼此互動構築成一個應用程式 公開的 API 即是透過物件內方法跟應用程式互動  物件導向程式語言四大原則 抽象化  隱藏實作細節的機制  封裝  把屬性跟方法封裝在 class 不讓外部讀取修改，但 class 內部可以讀取 封裝好(讓屬性跟方法保持 private)可避免產生非預期 bug 當外在程式碼能夠更動到 class 內部資料，會連動影響到調用這個 class 的相關程式碼 需要公開存取 API 可設計成開放存取  繼承  當有兩個相似的 class，我們可以使用繼承特性避免撰寫重複程式碼(parent class → child class)  多型  child class 可以覆寫 parent class 的方法  class 跟 instance 實例是什麼？  class 是一個藍圖(非物件)，透過 class 建構出來的東西是 instance 實例 但 JavaScript 其實沒有真正的 class 這個類別實例(而 Java，C++有) JavaScript 的 class 比較像是語法糖，透過建構函式來模擬 class，可以調用原型(prototype-based)方法  prototype 原型是什麼？  在 JavaScript 物件都會連結到原型，原型繼承(prototypal inheritance)表示所有被連結到的實例都可以使用原型的方法 舉例來說，我們在使用陣列的 map 方法，也是從陣列的 prototype 取用這個方法，而不是 num 本身有的方法()  建立原型的 3 種方法  建立原型是為了可以使用原型繼承   使用建構函式(Constructor functions)跟 new 運算子產生新的實例 ES6 的 class 語法糖 Object.create（最簡單創造出一個物件連結 prototype 的方法)  1 2  const num = [1, 2, 3]; console.log(num.map((el) =\u0026gt; el + 2)); //[ 3, 4, 5 ]   使用建構函式跟 new 運算子建立原型連結  寫一個建構函式，使用 new 運算子產生新的物件實例{} 當函式被呼叫，物件實例的 this 會指向這個實例本身{} (因為使用 new 運算子才有這個特性，跟一般函式 this 不同) 實例會連結到建構函式，讓實例可以使用建構函式的方法，因此每個物件下會有.__proto__屬性 建構函式本身會 return{}  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  // 使用同原型創造不同實例 const Person = function (firstName, birthYear) { // this 指向實例本身  console.log(this); // Person {}  // 設定實例屬性為外部傳進來的參數  this.firstName = firstName; this.birthYear = birthYear; // 方法不會寫在原型裡面，會造成多餘的程式碼，若有一千個物件就有一千個方法程式碼 }; // 創造一個firstName為Jonas birthYear為1991的Person實例 const jonas = new Person(\u0026#34;Jonas\u0026#34;, 1991); console.log(jonas); // Person { firstName: \u0026#39;Jonas\u0026#39;, birthYear: 1991 }  // 創造一個firstName為mirenda birthYear為2003的Person實例 const mirenda = new Person(\u0026#34;mirenda\u0026#34;, 2003); console.log(mirenda); // Person { firstName: \u0026#39;mirenda\u0026#39;, birthYear: 2003 }  // 使用.prototype.方法名 新增原型共用方法 // 一樣所有物件可以透過prototype inheritance共用，但只需要管理這段程式碼，不會有多餘的copy Person.prototype.calcAge = function () { console.log(2037 - this.birthYear); }; // 可以共用原型方法 jonas.calcAge(); // 46 mirenda.calcAge(); // 34  // 使用.prototype 新增原型屬性 Person.prototype.species = \u0026#34;Homo Sapiens\u0026#34;; console.log(jonas.species); // 可以取得共用屬性 Homo Sapiens console.log(jonas); // Person { firstName: \u0026#39;Jonas\u0026#39;, birthYear: 1991 } 但不會出現在jonas實例裡面，除非有寫入   檢查實例所屬原型方法 1 2 3  console.log(jonas instanceof Person); // true console.log(jonas.__proto__ === Person.prototype); // 若是原型連結的實例為 true console.log(Person.prototype.isPrototypeOf(jonas)); // 若是原型連結的實例為 true   檢查實例是否含有某屬性 hasOwnProperty 1 2 3  console.log(jonas.hasOwnProperty(\u0026#34;firstName\u0026#34;)); // true console.log(jonas.species); // Homo Sapiens console.log(jonas.hasOwnProperty(\u0026#34;species\u0026#34;)); // false 因為不是jonas擁有屬性 而是原型   prototype chain 原型鏈 建構函式 v.s. 原型 v.s. 實例 關係圖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  // 建構函式.prototype = 原型 // 原型.constructor = 建構函式  // 建構函式 const Person = function (firstName, birthYear) { // Instance properties  this.firstName = firstName; this.birthYear = birthYear; }; // new 建構函式 = 實例 const jonas = new Person(\u0026#34;Jonas\u0026#34;, 1991); console.log(jonas); // Person { firstName: \u0026#39;Jonas\u0026#39;, birthYear: 1991 }  // 實例.__proto__ = 物件原型 // jonas的原型是Person，故可以獲取Person的方法或屬性 console.log(jonas.__proto__); //{species: \u0026#39;Homo Sapiens\u0026#39;, calcAge: ƒ (), constructor: ƒ(firstName, birthYear), [[Prototype]]: Object}  // Person的原型是物件原型 (Object.prototype) console.log(jonas.__proto__.__proto__); // {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …} 列出物件方法  // 物件原型的prototype是null(原型鏈chain最上層) console.log(jonas.__proto__.__proto__.__proto__); // null  // 以陣列實例來看原型鏈 const arr = [1, 2, 3]; // 實例的原型是陣列原型Array.prototype，可獲取陣列的方法 console.log(arr.__proto__); // [constructor: ƒ, concat: ƒ, copyWithin: ƒ, fill: ƒ, find: ƒ, …]  // 陣列原型的原型是物件，可獲取物件的方法 console.log(arr.__proto__.__proto__); // {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}  // 物件原型(Object.prototype)的prototype是null(原型鏈chain最上層) console.log(arr.__proto__.__proto__.__proto__); // null   ES6 的 class 建立原型連結 跟 function 一樣有 expression 和 declaration 兩種寫法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // class expression const Person = class { constructor(firstName, birthYear) { this.firstName = firstName; this.birthYear = birthYear; } }; // class declaration（寫起來比上方程式碼工整，都寫在一個物件中，方法不用寫在外面管理) class Person { constructor(firstName, birthYear) { this.firstName = firstName; this.birthYear = birthYear; } // 寫在這邊的方法都會進到prototype  calcAge() { console.log(2037 - this.birthYear); } greet() { console.log(`Hey ${this.fullName}`); } } const jessica = new Person(\u0026#34;Jessica Davis\u0026#34;, 1996); console.log(jessica); // Person {firstName: \u0026#39;Jessica Davis\u0026#39;, birthYear: 1996} jessica.calcAge(); // 41 console.log(jessica.__proto__ === PersonCl.prototype); // true   關於 class 的幾個重點  class 不會被提升 hoisting(即便寫 class declaration) class 具備一級函式特性(可作為參數傳入，也可被回傳) class 須在嚴格模式下執行 class 寫法比第一種(建構函式/const 實例 = new 函式/Person.prototype.方法)更好閱讀與維護，constructor/屬性/方法都寫在 class 裡，方法不需要寫在外面也可以使用 prototype inheritance  getters \u0026amp; setter  所有物件都有的屬性(assessor properties)，相對於一般屬性稱為 data properties 是獲取值或設定值的 function 適合用在 validation  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  const account = { owner: \u0026#34;Jonas\u0026#34;, movements: [200, 530, 120, 300], get latest() { // this.movements.slice(-1)是一個陣列，為了取值用pop  return this.movements.slice(-1).pop(); }, // 需要至少一個參數  set latest(mov) { this.movements.push(mov); }, }; // 像是獲取屬性一樣來使用這個方法 console.log(account.latest); // 300 // 像是更改屬性一樣來使用這個方法 而非account.latest(50) account.latest = 50; console.log(account.movements); // [200, 530, 120, 300, 50]    可以使用剛剛的 Person 來寫個 get 跟 set function  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  class Person { constructor(fullName, birthYear) { // 建構時會使用參數fullName 呼叫set fullName方法  this.fullName = fullName; this.birthYear = birthYear; } calcAge() { console.log(2037 - this.birthYear); } greet() { console.log(`Hey ${this.fullName}`); } get age() { return 2037 - this.birthYear; } // set a property that already exists  // 當使用.fullName就會呼叫這個方法，包含一開始建構實例時  set fullName(name) { console.log(name); if (name.includes(\u0026#34; \u0026#34;)) // set跟 constructor都使用firstName會有衝突 使用另一個變數存  this._fullName = name; else alert(`${name}is not a full name`); } // jessica.fullName才不會undefined  get fullName() { return this._fullName; } } const jessica = new Person(\u0026#34;Jessica Davis\u0026#34;, 1996); console.log(jessica.age); // 41  const walter = new Person(\u0026#34;Walter\u0026#34;, 1996); // Walter is not a full name   static methods  使用關鍵字 static 來定義一個靜態的方法（method）給類別（class），靜態方法在由類別所建立的物件實體（instance）上不能被呼叫，靜態方法只能由類別本身呼叫 例如 Array.from() 可以把類陣列轉成陣列，但陣列本身不能呼叫這個方法 因為這個方法是放在 Array constructor 身上，而非陣列的原型，所以陣列無法獲取  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69  class Person { constructor(fullName, birthYear) { this.fullName = fullName; this.birthYear = birthYear; } calcAge() { console.log(2037 - this.birthYear); } greet() { console.log(`Hey ${this.fullName}`); } get age() { return 2037 - this.birthYear; } set fullName(name) { console.log(name); if (name.includes(\u0026#34; \u0026#34;)) this._fullName = name; else alert(`${name}is not a full name`); } get fullName() { return this._fullName; } } // 這種寫法方法不會更新在原型，jonas無法繼承 Person.hey = function () { console.log(\u0026#34;hey\u0026#34;, this); }; Person.hey(); // hey class Person {...省略} (this會是建構函式本身) jonas.hey(); // Uncaught TypeError: jonas.hey is not a function  // 使用static關鍵字，可出現跟上方一樣的結果 class Person { constructor(fullName, birthYear) { this.fullName = fullName; this.birthYear = birthYear; } // 實例可以獲取的方法 會被加入原型.prototype property  calcAge() { console.log(2037 - this.birthYear); } greet() { console.log(`Hey ${this.fullName}`); } get age() { return 2037 - this.birthYear; } set fullName(name) { console.log(name); if (name.includes(\u0026#34; \u0026#34;)) this._fullName = name; else alert(`${name}is not a full name`); } get fullName() { return this._fullName; } // 建構時才能獲取的方法，實例無法獲取  static hey() { console.log(\u0026#34;hey\u0026#34;, this); } }    另一個小練習，get set 時使用另一個變數名(speedUS 而非 speed)就不用擔心撞變數名的問題  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class Car { constructor(make, speed) { this.make = make; this.speed = speed; } accelerate() { this.speed += 10; console.log(`${this.make}is going at ${this.speed}km/h`); } brake() { this.speed -= 5; console.log(`${this.make}is going at ${this.speed}km/h`); } get speedUS() { return this.speed / 1.6; } set speedUS(speed) { this.speed = speed * 1.6; } } const ford = new CarCl(\u0026#34;Ford\u0026#34;, 120); console.log(ford.speedUS); // 75 ford.accelerate(); // Ford is going at 130km/h ford.accelerate(); // Ford is going at 140km/h ford.brake(); // // Ford is going at 135km/h ford.speedUS = 50; // 50 console.log(ford); //Car{make:\u0026#34;Ford\u0026#34;, speed: 80}   Object.create() 建立原型連結  不需要寫建構函式 constructor new，或是.prototype 下方範例一般不會這樣做，顯示機制用  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  const PersonProto = { // 可以不需要寫constructor  calcAge() { console.log(2037 - this.birthYear); }, }; // 建立原型連結到steven const steven = Object.create(PersonProto); console.log(steven); // 手動增加原型內容 steven.name = \u0026#34;Steven\u0026#34;; steven.birthYear = 2002; steven.calcAge(); //35 // {} \u0026gt; __proto__: calcAge: f calcAge()  console.log(steven.__proto__ === PersonProto); //true  // 建立原型連結到sarah const sarah = Object.create(PersonProto); const PersonProto = { // 不需要寫constructor  // 建立一個方法來新增屬性，相較上面一個個新增  init(firstName, birthYear) { this.firstName = firstName; this.birthYear = birthYear; }, calcAge() { console.log(2037 - this.birthYear); }, }; // 誰呼叫this就是誰 sarah.init(\u0026#34;Sarah\u0026#34;, 1979); sarah.calcAge(); // 58   class 間的繼承: 父類別 parent class \u0026amp; 子類別 child class  了解如何用 Object.create()在 class 間設置原型鏈，讓父類別原型方法跟屬性可以被子類別繼承 子類別繼承父類別的方法跟屬性，也可以有自己的方法跟屬性 當子層父層有一樣名稱的方法，會用子層的  使用建構函式跟 new 運算子建立父子類別繼承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // 人類原型 const Person = function (firstName, birthYear) { this.firstName = firstName; this.birthYear = birthYear; }; // 人類原型建立方法 Person.prototype.calcAge = function () { console.log(2037 - this.birthYear); }; // 學生原型 const Student = function (firstName, birthYear, course) { // 呼叫人類屬性  // 如果用一般函式呼叫(沒有用new) Person(firstName, birthYear) 會Uncaught Error: cannot set firstName of undefined  // a regular function call, the this keyword is set to undefined  // 如果需要呼叫函式並設置this在這個函式，使用call  Person.call(this, firstName, birthYear); this.course = course; }; // 使用Object.create建立原型連結 // 新增任何子類別原型的方法前，需要先建立連結，下方會回傳空物件，若順序錯誤空物件會覆蓋掉新增的方法 Student.prototype = Object.create(Person.prototype); // 學生原型建立方法 Student.prototype.introduce = function () { console.log(`My name is ${this.firstName}and I study ${this.course}`); }; // 建立一個學生 const mike = new Student(\u0026#34;Mike\u0026#34;, 2020, \u0026#34;Computer Science\u0026#34;); mike.introduce(); // 成功呼叫到父類別方法，跟scope chain一樣當子層找不到會往父層找 // 若子層有定義自己的calcAge()，會呼叫子層的方法 mike.calcAge(); // 17    子類別實例跟子類別跟父類別關係  1 2 3 4 5 6 7 8 9 10 11  // 學生原型 可以看到introduce方法 console.log(mike.__proto__); // Person { introduce: [Function (anonymous)] } // 人類原型 可以看到calcAge方法 console.log(mike.__proto__.__proto__); // { calcAge: [Function (anonymous)] }  console.log(mike instanceof Student); // true console.log(mike instanceof Person); // true 若沒有上面建立連結會是false console.log(mike instanceof Object); // true  Student.prototype.constructor = Student; // 加上這行fix mike的constructor指向ㄎ console.dir(Student.prototype.constructor); // 若沒有上面這行會指向Person   使用 ES6 class 建立父子類別繼承  使用 extend 父類別 搭配 super 父類別參數 super 是父層的建構函式 constructor  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  // 人類原型 class Person { constructor(firstName, birthYear) { this.firstName = firstName; this.birthYear = birthYear; } // 人類原型建立方法  calcAge = function () { console.log(2037 - this.birthYear); }; } // 學生原型 不用寫父層.call 用extends就會指向父層了 class Student extends Person { constructor(firstName, birthYear, course) { // super永遠寫在最上面 子層的this  super(firstName, birthYear); this.course = course; } introduce() { console.log(`My name is ${this.firstName}and I study ${this.course}`); } // 覆寫父層方法  // calcAge() {  // console.log(`i am ${2037- this.birthYear}`)  // } } // 使用Object.create建立原型連結，讓兩個class建立父子關係 // 在添加任何學生原型的方法前，需要先建立連結，因為下方會先回傳空物件，若順序錯誤空物件會覆蓋掉新增的方法 Student.prototype = Object.create(Person.prototype); // 建立一個學生 const mike = new Student(\u0026#34;Mike\u0026#34;, 2020, \u0026#34;Computer Science\u0026#34;); mike.introduce(); // My name is Mike and I study Computer Science  // 成功呼叫到父類別方法，若子層有同樣calcAge()則會呼叫子層方法 mike.calcAge(); // 17   使用 Object.create 建立父子類別繼承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  const PersonProto = { calcAge() { console.log(2037 - this.birthYear); }, init(firstName, birthYear) { this.firstName = firstName; this.birthYear = birthYear; }, }; // 使用Object.create建立原型連結 const StudentProto = Object.create(PersonProto); // 使用Object.create建立原型連結 const jay = Object.create(StudentProto); // 子層新增相同名稱方法 StudentProto.init = function (firstName, birthYear, course) { // 呼叫函式並設置this在這個函式，使用call 獲取父層init方法  PersonProto.init.call(this, firstName, birthYear); this.course = course; }; // 子層新增不同方法 StudentProto.introduce = function () { console.log(`My name is ${this.firstName}and I study ${this.course}`) }; jay.init(\u0026#34;Jay\u0026#34;, 2010, \u0026#34;computer science\u0026#34;); jay.introduce() // My name is Jay and I study computer science jay.calcAge() // 27   ","date":"2022-01-14T00:00:00+08:00","image":"https://bacnotes.github.io/p/object-oriented-programming/pexels-j%C3%A9shoots-271458_hu3d03a01dcc18bc5be0e67db3d8d209a6_2056159_120x120_fill_q75_box_smart1.jpg","permalink":"https://bacnotes.github.io/p/object-oriented-programming/","title":"今晚，我們來聊點物件導向程式設計(Object-Oriented Programming) ｜The Complete JavaScript Course｜bacnotes備份筆記"},{"content":"我們之前在JavaScript 底層運作原理 101，介紹過 primitives 跟 objects 使用記憶體的方式\n也有在JavaScript 基礎知識複習(2)，補充中提到 primitives 賦值時是傳值，而陣列、物件賦值時是傳址\n在這篇文章中，我們會繼續介紹傳址跟傳值在函式傳遞參數(arguments)時，primitives 跟 objects 兩者表現會有什麼不同\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // 有一個字串資料跟一個物件資料 const flight = \u0026#39;LH234\u0026#39;; const jonas = { name: \u0026#39;Jonas Schmedtmann\u0026#39;, passport: 24739479284, }; const checkIn = function (flightNum, passenger) { // flightNum 只是一個flight字串值的copy 兩者使用不同記憶體  flightNum = \u0026#39;LH999\u0026#39;; // passenger.name 則是直接把記憶體傳過去 使用同一份記憶體  passenger.name = \u0026#39;Mr. \u0026#39; + passenger.name; if (passenger.passport === 24739479284) { console.log(\u0026#39;Checked in\u0026#39;); } else { console.log(\u0026#39;Wrong passport!\u0026#39;); } }; // flight是一個primitives 傳值進function // jonas是一個object 傳址進function checkIn(flight, jonas); // Checked in  console.log(flight); // flight變數(primitives): LH234 沒有變 console.log(jonas); // person.name(物件屬性)：Mr.Jonas Schmedtmann 變了    當兩個函式操作同一個物件且沒有做淺拷貝，直接傳址  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  const flight = \u0026#39;LH234\u0026#39;; const jonas = { name: \u0026#39;Jonas Schmedtmann\u0026#39;, passport: 24739479284, }; const flightNum = flight; const passenger = jonas; const checkIn = function (flightNum, passenger) { flightNum = \u0026#39;LH999\u0026#39;; // 修改記憶體中的值  passenger.name = \u0026#39;Mr. \u0026#39; + passenger.name; if (passenger.passport === 24739479284) { console.log(\u0026#39;Checked in\u0026#39;); } else { console.log(\u0026#39;Wrong passport!\u0026#39;); } }; const newPassport = function (person) { person.passport = Math.trunc(Math.random() * 100000000000); }; newPassport(jonas); // a random number checkIn(flight, jonas); // Wrong passport! (因為改到passport號碼)    大型專案有時候因為不經意的修改到物件資料，會造成很大的影響，所以需要多注意傳址傳值的概念  First-Class Function 一級函式 之前介紹 JavaScript 語言特性時，有提到 JavaScript 有一級函式的特性\n因此我們可以使用 higher-order function：\n 可以把 function 當參數傳入另一個 function(又被稱作回呼函式) 可以 function return function  callback function 回呼函式 回呼函式 callback function 是把函式當作另一個函式的參數，透過另一個函式來呼叫它\n只是通常提到的場景是在處理非同步的時候\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  // 把所有英文字空白去掉，把字拼在一起的函式 const oneWord = function (str) { return str.replace(/ /g, \u0026#39;\u0026#39;).toLowerCase(); }; // 把第一個英文字都轉大寫字的函式 const upperFirstWord = function (str) { const [first, ...others] = str.split(\u0026#39; \u0026#39;); return [first.toUpperCase(), ...others].join(\u0026#39; \u0026#39;); }; // Higher-order function 字串跟函式為參數 const transformer = function (str, fn) { console.log(`Original string: ${str}`); console.log(`Transformed string: ${fn(str)}`); console.log(`Transformed by: ${fn.name}`); }; // 回呼函式範例1 transformer(\u0026#39;JavaScript is the best!\u0026#39;, upperFirstWord); // Original string: JavaScript is the best! // Transformed string: JAVASCRIPT is the best! // Transformed by: upperFirstWord  // 回呼函式範例2 transformer(\u0026#39;JavaScript is the best!\u0026#39;, oneWord); // Original string: JavaScript is the best! // Transformed string: javascriptisthebest! // Transformed by: oneWord   Function return function  可以把函式一層層封裝起來，讓外層只傳入一個參數，function programming 常用的程式設計技巧，有助於重複利用程式碼\n＊柯里化：把接受多個參數的函數變換成接受一個單一參數（最初函數的第一個參數）的函數，並且返回接受餘下的參數而且返回結果的新函數的技術 因為 Function return function 會創造閉包，閉包是函式本身及函式被建立時的執行文本(execution context)，因此下方 greeting 的參數 Hey 會被記住  1 2 3 4 5 6 7 8 9 10 11 12 13 14  const greet = function (greeting) { return function (name) { console.log(`${greeting}${name}`); }; }; const greeterHey = greet(\u0026#39;Hey\u0026#39;); greeterHey(\u0026#39;Jonas\u0026#39;); // Hey Jonas greeterHey(\u0026#39;Steven\u0026#39;); // Hey Stevens  greet(\u0026#39;Hello\u0026#39;)(\u0026#39;Jonas\u0026#39;); // Hello Jonas  // ＊補充上方的greet函式也可以寫成箭頭函式 const greet = (greeting) =\u0026gt; (name) =\u0026gt; console.log(`${greeting}${name}`);   Call \u0026amp; Apply 綁定 this 對象 當我們開發程式後可能會複用不同物件內的方法，但如果你只 copy 方法，使用一般函式呼叫，會發現 this undefined，符合我們之前提到的一般函式呼叫的狀況下，嚴格模式下 this 是 undefined（非嚴格模式下為全域物件）\n這個時候你就需要使用 Call 或 Apply 來告訴程式 this 要綁定的對象\n使用 Call 方法  call(thisArg, arg1, \u0026hellip; , argN)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  const lufthansa = { airline: \u0026#39;Lufthansa\u0026#39;, iataCode: \u0026#39;LH\u0026#39;, bookings: [], // book: function() {}  book(flightNum, name) { console.log( `${name}booked a seat on ${this.airline}flight ${this.iataCode}${flightNum}` ); this.bookings.push({ flight: `${this.iataCode}${flightNum}`, name }); }, }; lufthansa.book(239, \u0026#39;Jonas Schmedtmann\u0026#39;); lufthansa.book(635, \u0026#39;John Smith\u0026#39;); // 也想在這邊使用上面book的方法 const eurowings = { airline: \u0026#39;Eurowings\u0026#39;, iataCode: \u0026#39;EW\u0026#39;, bookings: [], }; // copy方法，內容為push一段文字到bookings const book = lufthansa.book; // 若直接用一般函式呼叫 not work book(23, \u0026#39;Sarah Williams\u0026#39;); // Uncaught TypeError: Cannot read property \u0026#39;airline\u0026#39; of undefined  // 不是去呼叫 book函式而是return 新的函式綁定this對象為eurowings book.call(eurowings, 23, \u0026#39;Sarah Williams\u0026#39;); console.log(eurowings); // 的確有使用book方法把資料push進來了  // { // airline: \u0026#39;Eurowings\u0026#39;, // iataCode: \u0026#39;EW\u0026#39;, // bookings: [ { flight: \u0026#39;EW23\u0026#39;, name: \u0026#39;Sarah Williams\u0026#39; } ] // }   使用 Apply 方法  apply(thisArg, argsArray) Call 跟 Apply 差別在參數傳入的資料結構的不同，使用 Apply 綁定時，參數需要放在陣列當中，Call 則是直接寫在()中。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // 定義另一個物件 const swiss = { airline: \u0026#39;Swiss Air Lines\u0026#39;, iataCode: \u0026#39;LX\u0026#39;, bookings: [], }; // 參數放入陣列 const flightData = [583, \u0026#39;George Cooper\u0026#39;]; book.apply(swiss, flightData); // 可以看到的確有使用到這個方法推新資料進去 console.log(swiss); // { // airline: \u0026#39;Swiss Air Lines\u0026#39;, // iataCode: \u0026#39;LX\u0026#39;, // bookings: [ { flight: \u0026#39;LX583\u0026#39;, name: \u0026#39;George Cooper\u0026#39; } ] // }  // 若使用call需要展開陣列，直接傳參數本身 book.call(swiss, ...flightData);   不會馬上執行函式的綁定方法：Bind  bind(thisArg, arg1, \u0026hellip; , argN) bind 是創造一個函式物件的拷貝，不會執行函式 因此 bind 之後還要再另外寫執行函式的動作()，而 call 是直接執行函式  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // 使用剛剛的物件跟原型方法 const lufthansa = { airline: \u0026#39;Lufthansa\u0026#39;, iataCode: \u0026#39;LH\u0026#39;, bookings: [], // book: function() {}  book(flightNum, name) { console.log( `${name}booked a seat on ${this.airline}flight ${this.iataCode}${flightNum}` ); this.bookings.push({ flight: `${this.iataCode}${flightNum}`, name }); }, }; const book = lufthansa.book; const eurowings = { airline: \u0026#39;Eurowings\u0026#39;, iataCode: \u0026#39;EW\u0026#39;, bookings: [], }; // 複習一下 下方是return新的函式綁定this對象為eurowings // book.call(eurowings, 23, \u0026#39;Sarah Williams\u0026#39;);  // 使用這個邏輯把指向不同對象的book函式存到不同變數 const bookEW = book.bind(eurowings); const bookLH = book.bind(lufthansa); const bookLX = book.bind(swiss); bookEW(23, \u0026#39;Steven Williams\u0026#39;); // 測試一下有work! Steven Williams booked a seat on Eurowings flight EW23  // 層層參數綁定 const bookEW23 = book.bind(eurowings, 23); // 只需要傳一個參數進去就可以呼叫裡面的方法，柯里化 bookEW23(\u0026#39;Jonas Schmedtmann\u0026#39;); bookEW23(\u0026#39;Martha Cooper\u0026#39;);    另一個常用的場景是監聽事件  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // With Event Listeners lufthansa.planes = 300; // 計數器 lufthansa.buyPlane = function () { console.log(this); // 使用監聽時 this指向觸發event元素  this.planes++; console.log(this.planes); }; lufthansa.buyPlane(); // 的確有+1 變成301  document .querySelector(\u0026#39;.buy\u0026#39;) // 我們不希望立即觸發所以使用bind綁定this指向對象，等click再執行  .addEventListener(\u0026#39;click\u0026#39;, lufthansa.buyPlane.bind(lufthansa));    當函式執行內容不包含 this，還是可以使用 Bind 綁定非 this 部分的參數，讓函式更有彈性的被執行 不需要 this 的狀況下寫 null 即可  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 不同稅率的計算應用 const addTax = (rate, value) =\u0026gt; value + value * rate; // 一般函式下操作 console.log(addTax(0.1, 200)); // 220  // 用bind綁定稅率23% const addVAT = addTax.bind(null, 0.23); // 等於 addVAT = value =\u0026gt; value + value * 0.23;  console.log(addVAT(100)); // 123  // 嘗試用function return function 改寫上面bind方法 const addTax = function (rate) { return function (value) { return value + value * rate; }; }; const addVAT = addTax(0.23);   Immediately Invoked Function Expressions (IIFE) 立即執行函式  只會執行一次的函式，執行完就馬上消失 函式會創造作用域，外部無法獲取內部的變數 不會污染外部變數，適合用在第三方函式庫  1 2 3 4 5 6 7 8  (function () { statements; })(); // 也可以寫箭頭函式 (()=\u0026gt; statements)() // 但不會存取在一個變數裡const abc = function () {statements}    在之前的文章有介紹過，const let 也會創造出 block 作用域，外部無法獲取內部參數 但 var 會被獲取到  1 2 3 4 5 6 7 8  // block區域 { const state = 123; var state2 = 123; } console.log(state); // Uncaught ReferenceError: state is not defined console.log(state2); // 123    因為有了 let const 限制住作用域，因此在 ES6 後就比較少使用到 IIFE  Closure 閉包  閉包（Closure）是函式以及該函式被宣告時所在的作用域環境（lexical environment）的組合 如果是第一次接觸閉包觀念應該會有下方反應   這部分會需要知道什麼是作用域跟執行文本，不熟的話可以看一下這篇 JavaScript 底層運作原理 101再回來 我們以下方函式來講解閉包的運作 step1. 創造全域執行文本 (全域變數環境：secureBooking=fn, booker=fn) step2. 執行全域執行文本，創造出個別執行文本 secureBooking()作用域：可以獲取本地作用域跟父層的環境變數\n(變數環境：passengerCount=0, secureBooking=fn)\n程式跑到 return function 後，secureBooking()執行文本消失，回傳的 function 指派給 booker\n(變數環境：passengerCount=0, secureBooking=fn, booker=fn) step3. 執行個別文本\n執行 booker() (變數環境：empty, secureBooking=fn, booker=fn)\n由於所有函式都可以獲取被創造當下的執行文本(execution context)的變數環境(variable environment)\n因為 booker 是全域下的變數，所以可取得全域的secureBooking=fn, booker=fn的變數環境，而secureBooking()的變數環境裡面有passengerCount=0  1 2 3 4 5 6 7 8 9 10  const secureBooking = function () { let passengerCount = 0; return function () { passengerCount++; console.log(`${passengerCount}passenger`); }; }; const booker = secureBooking(); booker(); // 1 passenger   step 1 \u0026amp; 2 創造＆執行全域執行文本，創造出個別執行文本\nstep 3 執行個別文本\n總結  閉包建立在所有函式都可以獲取被創造當下的執行文本的變數環境的機制下 即便執行文本已經被銷毀，函式還是可以透過某種 ref 獲取到這個變數環境 所以可以取得 passengerCount = 0 的值，且可以持續更新這個變數  1 2 3  booker(); // 1 passenger booker(); // 2 passenger booker(); // 3 passenger   註：如果想知道這個神秘的Closure變數存在哪裡的話，可以在devtools裡console.dir偷偷看一下匿名函式的[[Scopes]]下Closure的passengerCount變數。但因為是private作用域所以無法存取或修改。\n1 2 3 4 5  console.dir(booker); // ... [[Scopes]]: Scopes[3] 0: Closure (secureBooking) {passengerCount: 0}   ","date":"2022-01-12T00:00:00+08:00","image":"https://bacnotes.github.io/p/javascript-advanced-part1/javascript-removebg-preview_hu5afc4de35f8caf4a9ddf52b81b394066_38619_120x120_fill_box_smart1_3.png","permalink":"https://bacnotes.github.io/p/javascript-advanced-part1/","title":"JavaScript 進階函式知識 ｜The Complete JavaScript Course｜bacnotes備份筆記"},{"content":"歡迎來到JavaScript基礎知識複習(3)，還記得 \u0026amp;\u0026amp; || ?? 這三個邏輯運算子嗎？其實他們可以跟指派運算子一起使用，如果沒有接觸過的可以先看看第一篇JavaScript 基礎知識複習(1)的介紹再來往下看唷\n邏輯運算子 + 指派運算子 \u0026amp;\u0026amp;= ||= ??=  下方是兩個餐廳資料物件，彼此的屬性略有不同  1 2 3 4 5 6 7 8 9  const restaurant1 = { name: \u0026#34;Carpi\u0026#34;, numGuests: 20, }; const restaurant2 = { name: \u0026#34;La Piazza\u0026#34;, owner: \u0026#34;Giovanni Rossi\u0026#34;, };    當我們想增加物件內的屬性，可以用邏輯運算子的方式添加  1 2 3 4  restaurant1.numGuests = restaurant1.numGuests || 10; // 屬性存在不會有變動 restaurant2.numGuests = restaurant2.numGuests || 10; // 沒有這個屬性，新增一個numGuests: 10 console.log(restaurant1); // { name: \u0026#39;Carpi\u0026#39;, numGuests: 20 } console.log(restaurant2); // { name: \u0026#39;La Piazza\u0026#39;, owner: \u0026#39;Giovanni Rossi\u0026#39;, numGuests: 10 }    但還可以寫得更精簡，使用邏輯運算子 + 指派運算子，跟上方的結果是一樣的  1 2 3 4  restaurant1.numGuests ||= 10; // 屬性存在不會有變動 restaurant2.numGuests ||= 10; // 沒有這個屬性，新增一個numGuests: 10 console.log(restaurant1); // { name: \u0026#39;Carpi\u0026#39;, numGuests: 20 } console.log(restaurant2); // { name: \u0026#39;La Piazza\u0026#39;, owner: \u0026#39;Giovanni Rossi\u0026#39;, numGuests: 10 }    遇到 numGuests 數量為0，會因 falsy 更新成後面的值，這個邏輯不是我們期待的結果可以使用??= 的方式避免這個問題 當屬性 null 不存在或 undefined，使用後方的值增加這個屬性  1 2 3 4  restaurant1.numGuests ??= 10; restaurant2.numGuests ??= 10; console.log(restaurant1); // { name: \u0026#39;Carpi\u0026#39;, numGuests: 20 } console.log(restaurant2); // { name: \u0026#39;La Piazza\u0026#39;, owner: \u0026#39;Giovanni Rossi\u0026#39;, numGuests: 10 }    當我們想更新屬性值的時候則可以使用\u0026amp;\u0026amp;=，如果這個屬性不存在會回傳 undefined  1 2 3 4 5 6 7  // 更新第一家餐廳的客戶數量 restaurant1.numGuests \u0026amp;\u0026amp;= 300; console.log(restaurant1); // {name: \u0026#39;Carpi\u0026#39;, numGuests: 300}  // 更新第二家餐廳的owner restaurant2.owner \u0026amp;\u0026amp;= \u0026#34;Mars\u0026#34;; console.log(restaurant2); // {name: \u0026#39;La Piazza\u0026#39;, owner: \u0026#39;Mars\u0026#39;, numGuests: 10}   for 迴圈語法糖：for of 迭代元素、for in 迭代屬性  每次寫 for 迴圈都覺得寫計數器跟迭代條件很麻煩嗎？其實還有更簡單的寫法 一樣可以搭配使用 continue 跟 break 語法  for of 迴圈迭代陣列裡的元素  for (const 陣列元素 of 陣列) 迭代元素  1 2 3 4 5 6 7 8  const menu = [\u0026#34;Focaccia\u0026#34;, \u0026#34;Bruschetta\u0026#34;, \u0026#34;Garlic Bread\u0026#34;]; for (const item of menu) { console.log(item); } // Focaccia // Bruschetta // Garlic Bread   for in 迴圈迭代物件屬性  for in 迭代屬性  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const openingHours = { mon: { open: 10, close: 16, }, tue: { open: 12, close: 18, }, }; for (const day in openingHours) { console.log(day); } // mon // tue    for in 搭配取值的bracket[]迭代值  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const openingHours = { mon: { open: 10, close: 16, }, tue: { open: 12, close: 18, }, }; for (const day in openingHours) { console.log(openingHours[day]); } // mon // tue    for..in 不應該用來迭代一個索引順序很重要的陣列。 陣列索引只是以整數命名的可列舉屬性，其他方面等同於一般物件屬性。 無法擔保 for\u0026hellip;in 以特定順序傳回索引，並且它將傳回全部可列舉屬性，包括非整數名的，以及繼承而來的可列舉屬性。  使用 Object.keys()、Object.values() 迭代物件屬性名或值 Object.keys 迭代物件屬性名成一個陣列  Object.keys(obj)  1 2 3 4 5 6 7 8 9 10 11 12  const openingHours = { mon: { open: 10, close: 16, }, tue: { open: 12, close: 18, }, }; console.log(Object.keys(openingHours)); // [\u0026#39;mon\u0026#39;, \u0026#39;tue\u0026#39;]   1 2 3 4 5 6  - Object.keys()可搭配 for of 迭代出陣列元素(值) for (const day of Object.keys(openingHours)){ console.log(day) } // mon // tue    跟 for in 迴圈迭代順序相同但 for in 還會列舉出 prototype 的屬性  Object.values 迭代物件值成一個陣列  Object.values(obj)  1 2 3 4 5 6 7 8 9 10 11 12  const openingHours = { mon: { open: 10, close: 16, }, tue: { open: 12, close: 18, }, }; console.log(Object.values(openingHours)); // [{open: 10, close: 16}, {open: 12, close: 18}]   同時迭代陣列或物件的屬性跟值：陣列.entries() Object.entries(Obj) 陣列 array.prototype.entries() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  const menu = [\u0026#34;Focaccia\u0026#34;, \u0026#34;Bruschetta\u0026#34;, \u0026#34;Garlic Bread\u0026#34;]; for (const item of menu.entries()) { console.log(item); } // [ 0, \u0026#39;Focaccia\u0026#39; ] // [ 1, \u0026#39;Bruschetta\u0026#39; ] // [ 2, \u0026#39;Garlic Bread\u0026#39; ]  // ...展開陣列 for (const item of menu.entries()) { console.log(...item); } // 0 Focaccia // 1 Bruschetta // 2 Garlic Bread  // 使用解構賦值，並從1開始呈現 for (const [index, item] of menu.entries()) { console.log(`${index + 1}: ${item}`); } // 1: Focaccia // 2: Bruschetta // 3: Garlic Bread   物件 Object.entries(obj)  跟 for in 迴圈迭代順序相同但 for in 還會列舉出 prototype 的屬性  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const openingHours = { mon: { open: 10, close: 16, }, tue: { open: 12, close: 18, }, }; // 屬性key 值value for (const [key, { open, close }] of Object.entries(openingHours)) { console.log(`On ${key}, we open at${open}and close at ${close}`); } // On mon, we open at10 and close at 16 // On tue, we open at12 and close at 18   Enhanced Object Literals 當變數跟屬性名稱相同可省略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // 變數name 跟 openingHours const name = \u0026#39;Great Restaurant\u0026#39;, const openingHours = { mon: { open: 10, close: 16, }, tue: { open: 12, close: 18 } } // 以往物件賦值，需要屬性key跟值value都寫上去 const restaurant = { name: name, openingHours:openingHours, location: \u0026#39;France\u0026#39; } // 現在只要屬性跟變數名一樣，單寫屬性就好，程式碼會幫你把值對起來 const restaurant = { name, openingHours, location: \u0026#39;France\u0026#39; }   物件方法可省略冒號跟 function 1 2 3 4 5 6 7 8 9  // 過去會寫成 order: function (a,b){ return a + b } // 可以簡寫成 長得就跟宣告函式一樣 order(a, b) { return a + b }   表達式作為物件的屬性名 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const weekdays = [\u0026#34;mon\u0026#34;, \u0026#34;tue\u0026#34;, \u0026#34;wed\u0026#34;, \u0026#34;thu\u0026#34;, \u0026#34;fri\u0026#34;]; const openingHours = { [weekdays[2]]: { open: 12, close: 18, }, [`day-${2 + 4}`]: { open: 13, close: 19, }, }; console.log(openingHours); // day-6: {open: 13, close: 19} // wed: {open: 12, close: 18}   Optional Chaining(ES2020) ?.  當資料本身很多屬性且每筆資料不一定存在這個屬性，讀取到不存在的屬性會跳出 Uncaught TypeError 使用?.讀取屬性，若不存在 null 或 undefined，會立即回傳 undefined，可以避免上方的 Uncaught TypeError 若為 0 \u0026lsquo;\u0026lsquo;會回傳相對應的值，只有 null undefined 會回傳 undefined 常搭配??一起使用  屬性加上 Optional Chaining 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  const openingHours = { mon: { open: 10, close: 16, }, tue: { open: 12, close: 18 }, wed: { open: 12, close: 18 } } const restaurant = { name: \u0026#39;Great restaurant\u0026#39;, openingHours } // 使用邏輯運算子的寫法 當屬性存在才執行（但資料一多會吐血） if(restaurant.openingHours \u0026amp;\u0026amp; restaurant.openingHours.mon) console.log(restaurant.openingHours.mon.open) // 使用Optional Chaining的寫法 簡短 console.log(restaurant.openingHours?.mon?.open) // 加上迭代for of 想知道平日幾點開門 const weekdays = [\u0026#39;mon\u0026#39;, \u0026#39;tue\u0026#39;, \u0026#39;wed\u0026#39;, \u0026#39;thu\u0026#39;, \u0026#39;fri\u0026#39;] for (const weekday of weekdays){ // 避免undefined出現 使用??設定預設值 not open  const open = restaurant.openingHours[weekday]?.open ??\u0026#39;not open\u0026#39; console.log(`On ${weekday}, ${open}`) } // On mon, 10 // On tue, 12 // On wed, 12 // On thu, not open // On fri, not open   物件方法加上 Optional Chaining  確認方法是否存在  1 2 3 4 5 6 7 8 9 10  const restaurant = { order(starterIndex, mainIndex) { return \u0026#34;Order!\u0026#34;; }, orderDelivery({ starterIndex = 1, mainIndex }) { return \u0026#34;OrderDelivery!\u0026#34;; }, }; console.log(restaurant.order?.(0, 1) ?? \u0026#34;Method not existed\u0026#34;); // Order! console.log(restaurant.orderRisotto?.(0, 1) ?? \u0026#34;Method not exist\u0026#34;); // \u0026#39;Method not exist\u0026#39;   陣列加上 Optional Chaining  檢查陣列是否有資料  1 2 3 4 5 6 7 8  const users = [{ name: \u0026#39;Jonas\u0026#39;, email: \u0026#39;hello@jonas.com\u0026#39;}] // 過去可能要寫 if(users.length \u0026gt; 0) console.log(users[0].name) else console.log(\u0026#39;User array empty\u0026#39;) // 使用Optional Chaining 寫起來更精簡 console.log(users[0]?.name ?? \u0026#39;User array empty\u0026#39;)   Set  長得像陣列，是元素的集合，元素可以是任何資料格式 Set 中所有的元素都是唯一的 (unique values)，不會有重複的值，當你存入重複的元素(值)會被忽略 Set 內部會用 === 來判斷是否有重複值，唯一的例外是 NaN 會被判斷作是重複的值(雖然 NaN !== NaN) 元素數量計算使用.size  1 2  const someSet = new Set([a, b, c]); console.log(someSet.size); // 3    .has(\u0026lsquo;元素\u0026rsquo;)檢查是否有包含元素  1 2  const someSet = new Set([a, b, c]); console.log(someSet.has(\u0026#34;a\u0026#34;)); // true    增加與刪除元素 .add() .delete() .clear()  1 2 3 4 5 6  someSet.add(\u0026#34;d\u0026#34;); console.log(someSet); // [a, b, c, d] someSet.delete(\u0026#34;a\u0026#34;); console.log(someSet); // [b, c, d] someSet.clear(); console.log(someSet); // []    無法用 index 從 Set 中把值取出，會回傳 undefined 可以迭代  1 2  const someSet = new Set([a, b, c]); for (const item of someSet) console.log(item); // a b c    查詢資料中不重複元素的數量  1 2 3  const classmate = [\u0026#34;a\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;b\u0026#34;]; const classmateSet = new Set(classmate); console.log(classmateSet.size);    把 Set 變不重複元素的陣列  1 2 3  const classmate = [\u0026#34;a\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;b\u0026#34;]; const classmateSet = [...new Set(classmate)]; console.log(classmateSet); // [ \u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;b\u0026#39; ]   Map  長得像物件，key value pair 的組合，可以記住 key 的原始加入 Map 的順序 可以迭代，迭代順序為加入 Map 的順序 在 Map 判斷 NaN 跟 NaN 相等（雖然 NaN !== NaN），剩下的值使用=== 判斷是否相等  新建構一個 Map 1  const restaurant = new Map(); //裡面是空的 跟物件有prototype不同    新增 key 使用.set(key, value) key 值的不限於字串，可以是任何資料型態（number、array、object、function、symbol)  1 2 3 4 5  console.log(restaurant.set(1, \u0026#34;Firenze, Italy\u0026#34;)); // Map(1) { 1 =\u0026gt; \u0026#39;Firenze, Italy\u0026#39; }  console.log(restaurant.set(2, \u0026#34;Tokyo, Japan\u0026#34;)); // Map(2) { 1 =\u0026gt; \u0026#39;Firenze, Italy\u0026#39;, 2 =\u0026gt; \u0026#39;Tokyo, Japan\u0026#39; }    set 的時候不只會更新 Map 內部資料，也會回傳一個新的 Map，所以我們可以連續.set 連續新增很多資料  1 2 3 4 5 6 7 8 9 10 11 12 13  restaurant .set(\u0026#34;categories\u0026#34;, [\u0026#34;Italian\u0026#34;, \u0026#34;Pizzeria\u0026#34;]) .set(\u0026#34;open\u0026#34;, 11) .set(\u0026#34;close\u0026#34;, 23) .set(true, \u0026#34;we are open\u0026#34;); console.log(restaurant); // Map(4) { // \u0026#39;categories\u0026#39; =\u0026gt; [ \u0026#39;Italian\u0026#39;, \u0026#39;Pizzeria\u0026#39; ], // \u0026#39;open\u0026#39; =\u0026gt; 11, // \u0026#39;close\u0026#39; =\u0026gt; 23, // true =\u0026gt; \u0026#39;we are open\u0026#39; // }   使用 get 獲取 key 的對應值 1 2 3  restaurant.set(1, \u0026#34;Test\u0026#34;); console.log(restaurant.get(1)); // \u0026#39;Test\u0026#39;   讀取 key 值加上邏輯判斷做條件渲染 1 2 3 4 5 6 7 8 9 10 11 12 13  // 新增以下key restaurant.set(\u0026#34;open\u0026#34;, 11); restaurant.set(\u0026#34;close\u0026#34;, 21); restaurant.set(true, \u0026#34;we are open\u0026#34;); restaurant.set(false, \u0026#34;we are closed\u0026#34;); // 判斷營業時間 const time = 21; console.log( restaurant.get( time \u0026gt; restaurant.get(\u0026#34;open\u0026#34;) \u0026amp;\u0026amp; time \u0026lt; restaurant.get(\u0026#34;close\u0026#34;) ) ); // we are closed   使用.size 查詢資料長度 1  console.log(restaurant.size); //6   使用 has 確認是否包含某個 key，回傳 true false 1 2  console.log(restaurant.has(true)); //true console.log(restaurant.has(false)); //true   使用 delete 刪除元素 clear 清空元素 1 2 3 4 5 6 7 8 9 10 11  restaurant.delete(1); console.log(restaurant); // Map(5) { // 2 =\u0026gt; \u0026#39;Tokyo, Japan\u0026#39;, // \u0026#39;open\u0026#39; =\u0026gt; 11, // \u0026#39;close\u0026#39; =\u0026gt; 21, // true =\u0026gt; \u0026#39;we are open\u0026#39;, // false =\u0026gt; \u0026#39;we are closed\u0026#39; // } restaurant.clear(); // Map(0) {}    注意：物件如果不是 ref 的方式給值，無法讀取到對應 value  1 2 3 4 5 6 7 8  restaurant.set([1, 2], \u0026#34;Test\u0026#34;); console.log(restaurant.get([1, 2])); // undefined  const arr = [1, 2]; restaurant.set(arr, \u0026#34;Test\u0026#34;); console.log(restaurant.get(arr)); // \u0026#39;Test\u0026#39;   可以綁定 DOM 元素 1 2 3  restaurant.set(document.querySelector(\u0026#34;h1\u0026#34;), \u0026#34;Heading\u0026#34;); console.log(restaurant.get(\u0026#34;h1\u0026#34;)); //Map(1) {h1.bold-title.is-1 =\u0026gt; \u0026#39;Heading\u0026#39;}   物件轉 Map  Object.entries(obj) 組成巢狀陣列，new Map 轉成 Map  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  const openingHours = { mon: { open: 10, close: 16, }, tue: { open: 12, close: 18, }, }; console.log(Object.entries(openingHours)); //[ // [ \u0026#39;mon\u0026#39;, { open: 10, close: 16 } ], // [ \u0026#39;tue\u0026#39;, { open: 12, close: 18 } ] //] // const hoursMap = new Map(Object.entries(openingHours)); console.log(hoursMap); //Map(2) { // \u0026#39;mon\u0026#39; =\u0026gt; { open: 10, close: 16 }, // \u0026#39;tue\u0026#39; =\u0026gt; { open: 12, close: 18 } //}   迭代 Map key value   建議迭代結構為巢狀陣列(同 Object.entries(obj)或[\u0026hellip;array.entries()]輸出的結構) // [[\u0026lsquo;key\u0026rsquo;, {value}], [\u0026lsquo;key\u0026rsquo;, {value}], [\u0026lsquo;key\u0026rsquo;, {value}]]\n  使用展開運算子搭配.keys()或.values()，並將迭代出的元素放入一個新陣列\n  直接使用.keys()或.values()會出現[Map Iterator] { \u0026lsquo;question\u0026rsquo;, 1, 2, 3, \u0026lsquo;correct\u0026rsquo;, true, false }\n  1 2 3 4 5 6 7 8 9  const question = new Map([ [\u0026#34;question\u0026#34;, \u0026#34;What is the best programming language in the world?\u0026#34;], [1, \u0026#34;C\u0026#34;], [2, \u0026#34;Java\u0026#34;], [3, \u0026#34;JavaScript\u0026#34;], [\u0026#34;correct\u0026#34;, 3], [true, \u0026#34;Correct 🎉\u0026#34;], [false, \u0026#34;Try again!\u0026#34;], ]);    先看看展開運算子外層加上陣列的結果 console.log([\u0026hellip;question]) 等於 console.log([\u0026hellip;question.entries())  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  //[ // [ \u0026#39;question\u0026#39;, \u0026#39;What is the best programming language in the world?\u0026#39; ], // [ 1, \u0026#39;C\u0026#39; ], // [ 2, \u0026#39;Java\u0026#39; ], // [ 3, \u0026#39;JavaScript\u0026#39; ], // [ \u0026#39;correct\u0026#39;, 3 ], // [ true, \u0026#39;Correct 🎉\u0026#39; ], // [ false, \u0026#39;Try again!\u0026#39; ] //]  // 迭代Map key console.log([...question.keys()]); // [\u0026#39;question\u0026#39;, 1, 2, 3, \u0026#39;correct\u0026#39;, true, false]  // 迭代Map value console.log([...question.values()]); // [\u0026#39;What is the best programming language in the world?\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;Java\u0026#39;, \u0026#39;JavaScript\u0026#39;, 3, \u0026#39;Correct 🎉\u0026#39;, \u0026#39;Try again!\u0026#39;]  // 問答 console.log(question.get(\u0026#34;question\u0026#34;)); // What is the best programming language in the world? for (const [key, value] of question) { if (typeof key === \u0026#34;number\u0026#34;) console.log(`Answer ${key}: ${value}`); } // Anwser 1: C // Anwser 2: Java // Anwser 3: JavaScript  const answer = Number(prompt(\u0026#34;Your Anwser\u0026#34;)); console.log(answer); // 問答用布林判斷 若答案3 下方判斷是為true 顯示\u0026#39;Correct 🎉\u0026#39; question.get(question.get(\u0026#34;correct\u0026#34;) === answer);   如何決定資料結構 考量資料來源  程式本身 2. UI 互動介面 3. API(JSON 格式{a, b:[{},{}\u0026hellip;], c})  資料結構  list (可用陣列或 set) key value pairs (可用 obj 或 map)  何時適合 Set 而不是陣列呢  需要 list 裡面都是唯一值(不能有重複值) 不需要索引取值 不需要對資料做操作 需要高效能查找  何時適合 Map 而不是物件呢  需要對資料頻繁操作，保持高效能 當資料插入順序是需要考慮的因素 需要使用不同資料型態的 key（不限於 string 和 symbol 作為 key) 方便迭代跟計算大小 size 比較少需要單獨對部分資料做操作(物件比較方便用.跟[]取值)  課程小練習 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150  // challenge 1 const game = { team1: \u0026#34;Bayern Munich\u0026#34;, team2: \u0026#34;Borrussia Dortmund\u0026#34;, players: [ [ \u0026#34;Neuer\u0026#34;, \u0026#34;Pavard\u0026#34;, \u0026#34;Martinez\u0026#34;, \u0026#34;Alaba\u0026#34;, \u0026#34;Davies\u0026#34;, \u0026#34;Kimmich\u0026#34;, \u0026#34;Goretzka\u0026#34;, \u0026#34;Coman\u0026#34;, \u0026#34;Muller\u0026#34;, \u0026#34;Gnarby\u0026#34;, \u0026#34;Lewandowski\u0026#34;, ], [ \u0026#34;Burki\u0026#34;, \u0026#34;Schulz\u0026#34;, \u0026#34;Hummels\u0026#34;, \u0026#34;Akanji\u0026#34;, \u0026#34;Hakimi\u0026#34;, \u0026#34;Weigl\u0026#34;, \u0026#34;Witsel\u0026#34;, \u0026#34;Hazard\u0026#34;, \u0026#34;Brandt\u0026#34;, \u0026#34;Sancho\u0026#34;, \u0026#34;Gotze\u0026#34;, ], ], score: \u0026#34;4:0\u0026#34;, scored: [\u0026#34;Lewandowski\u0026#34;, \u0026#34;Gnarby\u0026#34;, \u0026#34;Lewandowski\u0026#34;, \u0026#34;Hummels\u0026#34;], date: \u0026#34;Nov 9th, 2037\u0026#34;, odds: { team1: 1.33, x: 3.25, team2: 6.5, }, }; // 分組 const [players1, players2] = game.players; console.log(players1); console.log(players2); // 組裡面有兩種角色 守門員gk跟 其他球員 const [gk, ...fieldPlayers] = players1; console.log(gk, fieldPlayers); // 把所有隊伍人的放進去一個陣列 const allPlayers = [...players1, ...players2]; console.log(allPlayers); // 新增三個候補 const players1Final = [...players1, \u0026#34;Thiago\u0026#34;, \u0026#34;Coutinho\u0026#34;, \u0026#34;Perisic\u0026#34;]; console.log(players1Final); // 解構賦值取出變數 x的變數名改為draw const { odds: { team1, x: draw, team2 }, } = game; console.log(team1, draw, team2); // 丟一堆名字進去，使用其餘運算子合併成陣列，length計算長度 function printGoals(...players) { console.log(`${players.length}goals were scored`); } printGoals(\u0026#34;Davies\u0026#34;, \u0026#34;Muller\u0026#34;, \u0026#34;Lewandowski\u0026#34;, \u0026#34;Kimmich\u0026#34;); // 勝率比大小 上面已經有寫出team1勝率跟team2勝率 team1 \u0026gt; team2 \u0026amp;\u0026amp; console.log(\u0026#34;Team 1 is more likely to win\u0026#34;); team1 \u0026lt; team2 \u0026amp;\u0026amp; console.log(\u0026#34;Team 2 is more likely to win\u0026#34;); // challenge 2 // 依序列印出game.scored array 裡面的球員 Goal 1: Lewandowski for (const [index, item] of game.scored.entries()) console.log(`Goal ${index + 1}: ${item}`); // 需要算出team1 x team2平均數 累加value / 長度 const odds = Object.values(game.odds); // [ 1.33, 3.25, 6.5 ] let sum = 0; for (const item of odds) { sum += item; } console.log(sum / odds.length); // 列印出 // Odd of victory Bayern Munich: 1.33 // Odd of draw: 3.25 // Odd of victory Borrussia Dortmund: 6.5  for (const [team, odd] of Object.entries(game.odds)) { // Object.entries(game.odds) // [ [ \u0026#39;team1\u0026#39;, 1.33 ], [ \u0026#39;x\u0026#39;, 3.25 ], [ \u0026#39;team2\u0026#39;, 6.5 ] ]  const teamStr = team === \u0026#34;x\u0026#34; ? \u0026#34;draw\u0026#34; : `victory ${game[team]}`; // 每次loop出來的team是字串，所以可以用這個[]方式取值  console.log(team, odd); } // 分數統計 // scorers = { // Gnarby: 1, // Hummels: 1, // Lewandowski: 2 // }  const scorers = {}; for (const item of game.scored) { // 屬性存在 賦值+1 不存在時賦值=1  scorers[item] ? scorers[item]++ : (scorers[item] = 1); } console.log(scorers); // challenge 3 const gameEvents = new Map([ [17, \u0026#34;⚽️ GOAL\u0026#34;], [36, \u0026#34;🔁 Substitution\u0026#34;], [47, \u0026#34;⚽️ GOAL\u0026#34;], [61, \u0026#34;🔁 Substitution\u0026#34;], [64, \u0026#34;🔶 Yellow card\u0026#34;], [69, \u0026#34;🔴 Red card\u0026#34;], [70, \u0026#34;🔁 Substitution\u0026#34;], [72, \u0026#34;🔁 Substitution\u0026#34;], [76, \u0026#34;⚽️ GOAL\u0026#34;], [80, \u0026#34;⚽️ GOAL\u0026#34;], [92, \u0026#34;🔶 Yellow card\u0026#34;], ]); // 創造不重複事件陣列：迭代巢狀陣列的value變成一個陣列 不重複使用new Set(array) const events = new Set(gameEvents.values()); console.log(events); // 移除map中64分鐘的資料 gameEvents.delete(64); console.log(gameEvents); // 列印出發生事件avg時間長度\u0026#34;An event happened, on average, every 9 minutes\u0026#34; 一局90分鐘 const time = [...gameEvents.keys()].pop(); console.log(time); // 92 有超過90分鐘因此另外計算 console.log( `An event happened, on average, every ${time / gameEvents.size}minutes` ); // 加上前後半場標示[FIRST HALF] 17: ⚽️ GOAL  for (const [key, value] of gameEvents) { const half = key \u0026lt;= 45 ? \u0026#34;First\u0026#34; : \u0026#34;Second\u0026#34;; console.log(`[${half}HALF]${key}: ${value}`); }   ","date":"2022-01-10T00:00:00+08:00","image":"https://bacnotes.github.io/p/javascript-fundamentals-part3/javascript_hu206ed96a14226138f3215dbd4aa48c79_350158_120x120_fill_box_smart1_3.png","permalink":"https://bacnotes.github.io/p/javascript-fundamentals-part3/","title":"JavaScript基礎知識複習(3)｜The Complete JavaScript Course｜bacnotes備份筆記"},{"content":"本文是基於下方這堂 Udemy 課程的筆記，對 React 有興趣的話可以購買看看唷\nReact - The Complete Guide (incl Hooks, React Router, Redux)\n讓我們娓娓道來 React 的各種知識吧！\n1. 什麼是 React？ 1 2  A JavaScript library for building user interfaces. 一套用來打造使用者介面的JavaScript函式庫    React 是客戶端 based(非伺服器端運作)，在瀏覽器操作 DOM 讓互動性變高 使用 SPA 減少跟伺服器的溝通，使用上就跟手機的原生 APP 一樣順暢，所以名字才叫 React 技術上來說(e.g.跟 Augular 相比)React 不算是一個完整的框架  ＊什麼是 SPA（Single-page application）\n 單頁應用，伺服器傳送一次 HTML，就接管整個頁面的生命週期 可以透過 API(e.g. XMLHttpRequest 或 Fetch)更新部分畫面(元件)或整個頁面 Angular、React、Vue 都是熱門的 SPA  2. 為什麼用 React 對開發者好處  使用 Declarative programming 宣告式程式設計\n描述目標而非流程，比起過往 DOM 操作要一個個選元素，一個口令一個動作的指令式程式設計 imperative programming，可以讓撰寫的程式碼精簡不少 以元件為中心\n把視覺呈現、資料等元素放在單一檔案中，複用性高，可以減少重複代碼 JSX 語法\nJSX 幫助我們同時寫 HTML 跟 JS 邏輯，資料跟事件的綁定可以直接寫在 HTML 上，很方便，像是在 HTML 上實作 JS 邏輯，且容易閱讀 關注點分離\n每一模組各自有獨立關注焦點，有助於後續協作跟維護 資料驅動畫面\n用 useState+雙向綁定 HTML 元素，資料有變動畫面就會變動 不用再寫一個渲染指令請程式更新畫面  對使用者好處  不需要在換頁時跟伺服器要資料(減少等待重新渲染的時間)，使用者體驗佳  3. React.js v.s. Angular v.s. Vue  都是以元件為中心，資料驅動畫面 React：內建 framework 較少，建議使用 JSX 語法但也可以用 JavaScript 撰寫，不想跟用 Vue 一樣記太多額外的語法，適合直接來 React Angular：用 TypeScript 撰寫，有很多內建的 framework，不太需要社群資源，比較複雜 Vue：內建 framework 比 React 多，比 Angular 少，有很多語法糖，適合初學者建立框架與生命週期觀念  4. React 建立專案 CRA(create-react-app)  相對傳統撰寫網頁的方式，只要建立 HTML、CSS、JavaScript 三個檔案 React 專案建立相較複雜一點，使用 CRA 指令前要先安裝 node.js(JavaScript 執行環境)才能使用 npm/npx 等指令下載相關模組(記得下載時網路要順暢)  1 2 3 4 5  // cd到專案資料夾 專案名以new-app為範例 npx create-react-app new-app cd new-app npm start // 可以在localhost 3000看到    CRA 內建 Babel 和 Webpack 幫你把 JSX 轉成瀏覽器可以解析的 HTML、CSS、JavaScript  5. VSCode 安裝 Prettier format document 選擇 prettier  若同時會使用 Vue 或 Javascript 開發不同專案，建議 VSCode 設定檔 by 框架/語言設定格式化的預設套件及 formatOnSave 選項  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  { // JavaScript  \u0026#34;[javascript]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34;, \u0026#34;editor.formatOnSave\u0026#34;: true }, // vue  \u0026#34;[vue]\u0026#34;: { \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; }, // react JSX  \u0026#34;[javascriptreact]\u0026#34;: { \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; }, }   參考文章：VSCode does not format JSX Correctly\n啟用 emmet snippet 縮寫  設定檔寫入  1 2 3 4 5  { \u0026#34;emmet.includeLanguages\u0026#34;: { \u0026#34;javascript\u0026#34;: \u0026#34;javascriptreact\u0026#34; }, }    使用 rcc 或 rfc（趨勢) 來幫助你加速開發吧  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // rcc class component import React, { Component } from \u0026#39;react\u0026#39;; class 元件名 extends Component { render() { return ( \u0026lt;div\u0026gt; \u0026lt;/div\u0026gt; ); } } export default 元件名; // rfc function component import React from \u0026#39;react\u0026#39;; const 元件名 = () =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;/div\u0026gt; ); } export default 元件名;   參考文章：Enable Emmet support for JSX in Visual Studio Code | React\n6. 開發專案前環境整理  如果只是要簡單開發一個 React 程式，必要的檔案有 App.js、index.css、index.js 移除不需要的 import  1 2 3 4 5  // App.js function App() { return \u0026lt;div\u0026gt;Hello\u0026lt;/div\u0026gt;; } export default App;    npm run start 觀看即時 Hot Reload 畫面  7. 了解 React 運作方式跟元件   在 2020 React17 更新後不用在每個客製化元件最上方 import React from 'react'，Babel 遇到 JSX 就會幫我們處理，且跟過往的 JSX 程式碼相容\n  但記得 index.js entry point 這邊的 import React from 'react'不能拿掉\n  對於 JSX 轉換細節有興趣的人可以參考這篇文章Introducing the New JSX Transform\n  1 2 3 4 5 6  // Inserted by a compiler (don\u0026#39;t import it yourself!) import { jsx as _jsx } from \u0026#34;react/jsx-runtime\u0026#34;; function App() { return _jsx(\u0026#34;h1\u0026#34;, { children: \u0026#34;Hello world\u0026#34; }); }     SPA 是針對 server 回傳的單頁 HTML 做變動，也就是\u0026lt;body\u0026gt; 中 id=\u0026lsquo;root\u0026rsquo;區塊\n  而 \u0026lt;App /\u0026gt;是一個 JavaScript function 回傳 JSX code，我們不會在瀏覽器 element 區塊看到\u0026lt;App /\u0026gt;裡面的 JSX 內容(因瀏覽器不懂 JSX 的內容) 而是會 render 出 Babel 轉譯\u0026lt;App /\u0026gt;後的內容\n  1 2 3  import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; ReactDom.render(\u0026lt;App /\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;));   8. 元件添加 CSS 樣式使用 className 而非 class  因為 class 是 JavaScript 的保留字，而 JSX 是 JavaScript 的延伸語法，所以不使用 class  1 2 3 4 5 6 7 8  function APP() { return ( \u0026lt;div\u0026gt; \u0026lt;h1 className=\u0026#39;container\u0026#39;\u0026gt;Hello\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } export default App;   9. 使用元件增加複用性  下方是一個元件範例，一般會放在 src/components 下，檔案命名建議大寫開頭 元件保持精簡，一個元件專心做一件事，降低耦合  1 2 3 4 5 6 7 8 9 10 11 12 13  // 客製化元件大寫命名，跟內建HTML元素做區隔 function Todo() { return ( \u0026lt;div className=\u0026#39;container\u0026#39;\u0026gt; \u0026lt;h2\u0026gt;Title\u0026lt;/h2\u0026gt; \u0026lt;div className=\u0026#39;actions\u0026#39;\u0026gt; \u0026lt;span\u0026gt;A span\u0026lt;/span\u0026gt; \u0026lt;button className=\u0026#39;btn\u0026#39;\u0026gt;Delete\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default Todo;    引用元件到 App.js 要先 import  1 2 3 4 5 6 7 8 9 10 11 12  // App.js import Todo from \u0026#34;./components/Todo\u0026#34;; function APP() { return ( \u0026lt;div\u0026gt; \u0026lt;h1 className=\u0026#39;container\u0026#39;\u0026gt;Hello\u0026lt;/h1\u0026gt; \u0026lt;Todo /\u0026gt; \u0026lt;Todo /\u0026gt; \u0026lt;/div\u0026gt; ); } export default App;   10. 父層透過 props 傳資料到子層元件  {}放入表達式 ，用同樣邏輯渲染出不同的資料  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // App.js // 資料傳入子層 import Todo from \u0026#39;./components/Todo\u0026#39; function APP () { return ( \u0026lt;div\u0026gt; \u0026lt;h1 className=\u0026#39;container\u0026#39;\u0026gt;Hello\u0026lt;/h1\u0026gt; \u0026lt;Todo text=\u0026#39;Learn React\u0026#39;/\u0026gt; \u0026lt;Todo text=\u0026#39;Master React\u0026#39;/\u0026gt; \u0026lt;/div\u0026gt; ) } export default App // 元件 Todo.js // 利用props收到的動態資料，渲染出2項Todo function Todo(props) { return ( \u0026lt;div className=\u0026#39;container\u0026#39;\u0026gt; \u0026lt;h2\u0026gt;{props.text}\u0026lt;/h2\u0026gt; \u0026lt;div className=\u0026#39;actions\u0026#39;\u0026gt; \u0026lt;span\u0026gt;A span\u0026lt;/span\u0026gt; \u0026lt;button className=\u0026#39;btn\u0026#39;\u0026gt;Delete\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default Todo;   11. 設置與監聽事件  需理解 React 裡面的 JSX 不等於 HTML，所以不能用 HTML inline JavaScript 事件的值應該是一個表達式所以用 onClick={} 可以寫成匿名函式 onClick={function(){}}或箭頭函式 onClick={()⇒{}} 但建議指向另一個 function，保持 HTML 精簡(寫在 return 前的區塊)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 元件 Todo.js 下方是一個 delete 事件 function Todo(props) { // 命名通常是xxxHandler  function openModalHandler() { console.log(\u0026#34;click\u0026#34;, props.text); } return ( \u0026lt;div className=\u0026#39;container\u0026#39;\u0026gt; \u0026lt;h2\u0026gt;{props.text}\u0026lt;/h2\u0026gt; \u0026lt;div className=\u0026#39;actions\u0026#39;\u0026gt; \u0026lt;span\u0026gt;A span\u0026lt;/span\u0026gt; // openModalHandler這邊不會加上執行() 等觸發才執行  \u0026lt;button onClick={openModalHandler} className=\u0026#39;btn\u0026#39;\u0026gt; Delete \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default Todo;   12. 引入多個元件  以提示窗為例，需要一個 backdrop 覆蓋 modal 後面的背景，跟一個 modal  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function Backdrop(props) { return \u0026lt;div className=\u0026#39;backdrop\u0026#39; /\u0026gt;; } function Modal(props) { return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Are you sure?\u0026lt;/p\u0026gt; \u0026lt;button className=\u0026#39;btn btn--alt\u0026#39;\u0026gt;Cancel\u0026lt;/button\u0026gt; \u0026lt;button className=\u0026#39;btn\u0026#39;\u0026gt;Delete\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default Modal;    兩個都引入到 App  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // App.js import Todo from \u0026#34;./components/Todo\u0026#34;; import Modal from \u0026#34;./components/Modal\u0026#34;; import Backdrop from \u0026#34;./components/Backdrop\u0026#34;; function APP() { return ( \u0026lt;div\u0026gt; \u0026lt;h1 className=\u0026#39;container\u0026#39;\u0026gt;Hello\u0026lt;/h1\u0026gt; \u0026lt;Todo text=\u0026#39;Learn React\u0026#39; /\u0026gt; \u0026lt;Todo text=\u0026#39;Master React\u0026#39; /\u0026gt; \u0026lt;Modal /\u0026gt; \u0026lt;Backdrop /\u0026gt; \u0026lt;/div\u0026gt; ); } export default App;   13. useState 紀錄網頁 State，跟使用者互動  useState 是 React 一個 Hook，Hook 是一個內建 function，useState 是用來操作狀態的 hook 我們註冊不同的 State，React 會在 State 改變時 render 不同東西 const [state, setState] = useState(initialState setState(newState);  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // useState 是一個 function，因為是第三方函式庫不用寫路徑 import { useState } from ‘react’ function SomeFunction(){ // useState 會回傳陣列，內有 2 個元素，可以定義初始值參數 // useState 要放在元件 function 內第一層，不能巢狀到 const [variable, setVariable] = useState(initialValue) return ( \u0026lt;div\u0026gt; ... \u0026lt;/div\u0026gt; ); } export default SomeFunction   為什麼我重新賦值的變數畫面沒有更新？ 無法透過重新賦值 變數 的值來更新畫面\n 更改值會需要呼叫陣列的第二個參數(一個 callback function)更新初始值(以下方範例來說是 setModalIsOpen) 呼叫 useState 的時候 React 才會重新執行 State 所屬的元件，並重新更新資料跟畫面 ＊不這麼做的話畫面是不會重新渲染的（也就是跑一次下方的 return 的 JSX)。 我們會用 setModalIsOpen 來更新值，用 modalIsOpen 判斷條件渲染 JSX 的程式碼  ＊Hook 有很多種，官方文件有列出所有的 Hook 在這裡Hook API\n useEffect 可以 fetch 資料、訂閱、或操作 DOM useRef 可以抓取 Dom 元素，獲取表單的 value(但更新 current 值不會重新渲染畫面) useContext 可以管理全域狀態等，下方會繼續介紹  同層監聽：click 開啟刪除確認 modal 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // Todo.js 元件  import { useState } from \u0026#34;react\u0026#34;; import Modal from \u0026#34;./Modal\u0026#34;; import Backdrop from \u0026#34;./Backdrop\u0026#34;; function Todo(props) { const [modalIsOpen, setModalIsOpen] = useState(false); function deleteHandler() { setModalIsOpen(true); } return ( \u0026lt;div className=\u0026#39;card\u0026#39;\u0026gt; \u0026lt;h2\u0026gt;{props.text}\u0026lt;/h2\u0026gt; \u0026lt;div className=\u0026#39;actions\u0026#39;\u0026gt; // 點擊觸發上層function  \u0026lt;button className=\u0026#39;btn\u0026#39; onClick={deleteHandler}\u0026gt; Delete \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {modalIsOpen \u0026amp;\u0026amp; \u0026lt;Modal /\u0026gt;} {modalIsOpen \u0026amp;\u0026amp; \u0026lt;Backdrop /\u0026gt;} \u0026lt;/div\u0026gt; ); }   父層監聽子層：click 關閉刪除確認 modal  子元件觸發事件，方法寫在父層 onClick 監聽是觸發同層 function，裡面包裹 props 傳下來的父層方法(Passing Function As Props) 範例為點 Cancel 跟 Delete 按鈕會關閉 modal  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  // Todo.js 元件 import Modal from \u0026#34;./components/Modal\u0026#34;; import Backdrop from \u0026#34;./components/Backdrop\u0026#34;; function Todo(props) { const [modalIsOpen, setModalIsOpen] = userState(false); function openModalHandler() { setModalIsOpen(true); } function closeModalHandler() { setModalIsOpen(false); } return ( \u0026lt;div className=\u0026#39;container\u0026#39;\u0026gt; \u0026lt;h2\u0026gt;{props.text}\u0026lt;/h2\u0026gt; \u0026lt;div className=\u0026#39;actions\u0026#39;\u0026gt; \u0026lt;button onClick={openModalHandler} className=\u0026#39;btn\u0026#39;\u0026gt; Delete \u0026lt;/button\u0026gt; {modalIsOpen \u0026amp;\u0026amp; ( \u0026lt;Modal onCancel={closeModalHandler} onConfirm={openModalHandler} /\u0026gt; )} // 透過props傳下去key value 讓子層觸發執行  {modalIsOpen \u0026amp;\u0026amp; \u0026lt;Backdrop onCancel={closeModalHandler} /\u0026gt;} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } // Modal.js function Modal(props) { function cancelHandler() { // 執行onCancel 父層方法 關閉modal  props.onCancel(); } function confirmHandler() { // 執行onCancel 父層方法 關閉modal  props.onConfirm(); } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Are you sure?\u0026lt;/p\u0026gt; \u0026lt;button onClick={cancelHandler} className=\u0026#39;btn btn--alt\u0026#39;\u0026gt; Cancel \u0026lt;/button\u0026gt; \u0026lt;button onClick={confirmHandler} className=\u0026#39;btn\u0026#39;\u0026gt; Delete \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default Modal;   ＊onCancel 是離開一個 dialog 元素會觸發的事件(e.g. 點遮罩或右上角 x，或取消按鈕)\n＊onConfirm 是點確認\n14. 加上路由  需要安裝套件（不包含在 CRA)  1  npm install --save react-router-dom@5    建議加上 src/pages 資料夾，比較好找到對應元件  1 2 3 4 5 6 7 8 9 10 11  // 建立這三個檔案在pages裡面 AllMeetups.js 命名Page幫助我們知道這個元件是一個頁面 function AllMetupsPage(){ return ( \u0026lt;div\u0026gt;AllMetupsPage\u0026lt;/div\u0026gt; ) } export default AllMeetupsPage Favorites.js NewMeetup.js 同上邏輯 改div內容跟function名字跟export名即可    我們使用 BrowserRouter 套件去定義哪些頁面何時要 load  1 2 3 4 5 6 7 8  // index.js import { BrowserRouter } from \u0026#34;react-router-dom\u0026#34;; // 初始化套件 確保他有在觀察url RouterDOM.render( \u0026lt;BrowserRouter\u0026gt; \u0026lt;APP /\u0026gt; \u0026lt;/BrowserRouter\u0026gt; );    搭配使用 Switch 渲染第一個符合路徑的元件  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // App.js import { Route } from \u0026#34;react-router-dom\u0026#34;; import AllMeetupsPage from \u0026#34;./pages/AllMeetups\u0026#34;; import NewMeetupsPage from \u0026#34;./pages/NewMeetups\u0026#34;; import FavoritesPage from \u0026#34;./pages/Favorites\u0026#34;; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Switch\u0026gt; // 避免/巢狀重複出現多個頁面內容 也可以直接exact  \u0026lt;Route path=\u0026#39;/\u0026#39; exact={true}\u0026gt; \u0026lt;AllMeetupsPage /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;Route path=\u0026#39;/newmeetup\u0026#39;\u0026gt; \u0026lt;NewMeetupsPage /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;Route path=\u0026#39;/favorites\u0026#39;\u0026gt; \u0026lt;FavoritesPage /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;/Switch\u0026gt; \u0026lt;/div\u0026gt; ); } export default App;   15. 用導覽列來練習 Link  導覽列一般會設置在 src 下方資料夾 layout，因為是整體佈局的元件 a href屬性可以用，但我們不想用伺服器傳 HTML，失去 SPA 優勢 import link 元件，會搭配to屬性加入路徑使用 \u0026lt;Link\u0026gt;tag 自動在 DOM 加入監聽，阻擋瀏覽器預設行為送出請求 且只會解析 url，修改網址列跟 load 相對應的元件(React/JavaScript)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  // MainNavigation.js  import { Link } from \u0026#39;react-router-dom\u0026#39; function MainNavigation() { return ( \u0026lt;header\u0026gt; \u0026lt;div\u0026gt; React Meetups\u0026lt;/div\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; \u0026lt;Link to=\u0026#39;/\u0026#39;\u0026gt;All Meetups\u0026lt;/Link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;Link to=\u0026#39;/newMeetup\u0026#39;\u0026gt;Add New Meetups\u0026lt;/Link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;Link to=\u0026#39;/favorites\u0026#39;\u0026gt;My favorites\u0026lt;/Link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;/header\u0026gt; ) } export default MainNavigation    導覽列 引入 App.js  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // App.js import { Route } from \u0026#34;react-router-dom\u0026#34;; import AllMeetupsPage from \u0026#34;./pages/AllMeetups\u0026#34;; import NewMeetupsPage from \u0026#34;./pages/NewMeetups\u0026#34;; import FavoritesPage from \u0026#34;./pages/Favorites\u0026#34;; import MainNavigation from \u0026#34;./components/layout/MainNavigation\u0026#34;; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;MainNavigation /\u0026gt; \u0026lt;Switch\u0026gt; \u0026lt;Route path=\u0026#39;/\u0026#39; exact={true}\u0026gt; \u0026lt;AllMeetupsPage /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;Route path=\u0026#39;/newmeetup\u0026#39;\u0026gt; \u0026lt;NewMeetupsPage /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;Route path=\u0026#39;/favorites\u0026#39;\u0026gt; \u0026lt;FavoritesPage /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;/Switch\u0026gt; \u0026lt;/div\u0026gt; ); } export default App;   16. CSS modules 來為元件加上樣式  CRA 本身有內建 CSS modules 需要在檔名使用 module.css 引入名稱自訂(e.g. classes)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // MainNavigation.js // classes會變成一個物件 import classes from \u0026#39;./MainNavigation.module.css\u0026#39; import { Link } from \u0026#39;react-router-dom\u0026#39; function MainNavigation() { return ( //module.css裡面的css樣式會變成key value pair  \u0026lt;header className={classes.header}\u0026gt; \u0026lt;div className={classes.logo}\u0026gt; React Meetups\u0026lt;/div\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; \u0026lt;Link to=\u0026#39;/\u0026#39;\u0026gt;All Meetups\u0026lt;/Link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;Link to=\u0026#39;/newMeetup\u0026#39;\u0026gt;Add New Meetups\u0026lt;/Link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;Link to=\u0026#39;/favorites\u0026#39;\u0026gt;My favorites\u0026lt;/Link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;/header\u0026gt; ) } export default App   17. 使用 map 迴圈渲染資料 React 能渲染出 JSX 元素裡的陣列  JSX expression{[\u0026lt;li\u0026gt;item1\u0026lt;/li\u0026gt;, \u0026lt;li\u0026gt;item2\u0026lt;/li\u0026gt;]} 或用 map 方法把元素 return 出來  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // pages/AllMeetup.js const DUMMY_DATA = [ { id: \u0026#34;m1\u0026#34;, title: \u0026#34;This is a first meetup\u0026#34;, image: \u0026#34;https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Stadtbild_M%C3%BCnchen.jpg/2560px-Stadtbild_M%C3%BCnchen.jpg\u0026#34;, address: \u0026#34;Meetupstreet 5, 12345 Meetup City\u0026#34;, description: \u0026#34;This is a first, amazing meetup which you definitely should not miss. It will be a lot of fun!\u0026#34;, }, { id: \u0026#34;m2\u0026#34;, title: \u0026#34;This is a second meetup\u0026#34;, image: \u0026#34;https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Stadtbild_M%C3%BCnchen.jpg/2560px-Stadtbild_M%C3%BCnchen.jpg\u0026#34;, address: \u0026#34;Meetupstreet 5, 12345 Meetup City\u0026#34;, description: \u0026#34;This is a first, amazing meetup which you definitely should not miss. It will be a lot of fun!\u0026#34;, }, ]; function AllMeetupsPage() { return ( \u0026lt;section\u0026gt; \u0026lt;h1\u0026gt;AllMeetupsPage\u0026lt;/h1\u0026gt; {DUMMY_DATA.map((el) =\u0026gt; { return \u0026lt;li key={el.id}\u0026gt;{el.title}\u0026lt;/li\u0026gt;; })} \u0026lt;/section\u0026gt; ); } export default AllMeetupsPage;   迴圈的元素設置 唯一值的 key  傳統演算法比對兩個節點差異，時間複雜度為 O 的 3 次方 為了渲染的效能，React 使用 heuristic 演算法比較內容變動的元素，但也可能因為沒有比對好(部分演算法假設跟現實不符)造成渲染出錯誤的元素 透過設置 key 告訴 React 你改動的元素，而非讓 React 自己比較元素內容差異 避免使用 index(元素完全位移), Math.random(key 值非固定)等方式來建立 key  18. 客製化元件的其他使用方式，目的在於讓元件專注在一件事 元件作為容器 Wrapper/Container 使用  設定 Container 包裹 children 內容  1 2 3 4 5 6 7  import classes from \u0026#34;./Container.module.css\u0026#34;; // 引入props.children children是每個元件都可以獲取的預設屬性，值是tag包覆的內容 function Container(props) { return \u0026lt;div className={classes.container}\u0026gt;{props.children}\u0026lt;/div\u0026gt;; } export default Container;    div 外用 Container 包裹  1 2 3 4 5 6 7 8  import Container from \u0026#34;../ui/Container\u0026#34;; function MeetUpItem(props) { return ( \u0026lt;Container\u0026gt; \u0026lt;div\u0026gt;some content\u0026lt;/div\u0026gt; \u0026lt;/Container\u0026gt; ); }   元件作為 Layout 使用(排版 body 內容)  Layout 放導覽列跟語意化標籤 main 包裹其他內容 在 components/layout 資料夾製作一個 Layout.js  1 2 3 4 5 6 7 8 9 10 11 12  import MainNavigation from \u0026#34;./MainNavigation\u0026#34;; import classes from \u0026#34;./Layout.module.css\u0026#34;; function Layout(props) { return ( \u0026lt;div\u0026gt; \u0026lt;MainNavigation /\u0026gt; \u0026lt;main className={classes.main}\u0026gt;{props.children}\u0026lt;/main\u0026gt; \u0026lt;/div\u0026gt; ); } export default Layout;    Layout 包裹路由內容  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // App.js import { Route } from \u0026#39;react-router-dom\u0026#39;; import AllMeetupsPage from \u0026#39;./pages/AllMeetups\u0026#39;; import NewMeetupsPage from \u0026#39;./pages/NewMeetups\u0026#39;; import FavoritesPage from \u0026#39;./pages/Favorites\u0026#39;; // 拿掉之前的MainNavigation 換成Layout import Layout from \u0026#39;./components/layout/Layout\u0026#39;; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Layout\u0026gt; \u0026lt;Switch\u0026gt; \u0026lt;Route path=\u0026#39;/\u0026#39; exact={true}\u0026gt; \u0026lt;AllMeetupsPage /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;Route path=\u0026#39;/newmeetup\u0026#39;\u0026gt; \u0026lt;NewMeetupsPage /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;Route path=\u0026#39;/favorites\u0026#39;\u0026gt; \u0026lt;FavoritesPage /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;/Layout\u0026gt; \u0026lt;/div\u0026gt; ); } export default App;   19. 加上表單  Page 新增一頁 裡面放表單元件  1 2 3 4 5 6 7 8 9  function NewMeetupPage() { return ( \u0026lt;section\u0026gt; \u0026lt;h1\u0026gt;Add New Meetup\u0026lt;/h1\u0026gt; \u0026lt;NewMeetupFrom\u0026gt; \u0026lt;/section\u0026gt; ); } export default NewMeetupPage;    新增表單元件 for 屬性在 React 要寫成 htmlFor  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  // NewMeetupForm.js import Container from \u0026#34;../ui/Container\u0026#34;; import classes from \u0026#34;./NewMeetupForm.module.css\u0026#34;; function NewMeetupForm() { return ( \u0026lt;Container\u0026gt; \u0026lt;form className={classes.form}\u0026gt; \u0026lt;div className={classes.control}\u0026gt; \u0026lt;label htmlFor=\u0026#39;title\u0026#39;\u0026gt;Title\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#39;text\u0026#39; id=\u0026#39;title\u0026#39; required /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className={classes.control}\u0026gt; \u0026lt;label htmlFor=\u0026#39;image\u0026#39;\u0026gt;Image\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#39;url\u0026#39; id=\u0026#39;image\u0026#39; required /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className={classes.control}\u0026gt; \u0026lt;label htmlFor=\u0026#39;address\u0026#39;\u0026gt;Address\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#39;text\u0026#39; id=\u0026#39;address\u0026#39; required /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className={classes.control}\u0026gt; \u0026lt;label htmlFor=\u0026#39;description\u0026#39;\u0026gt;Address\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#39;textarea\u0026#39; rows=\u0026#39;5\u0026#39; id=\u0026#39;description\u0026#39; required /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className={classes.control}\u0026gt; \u0026lt;label htmlFor=\u0026#39;description\u0026#39;\u0026gt;Address\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#39;textarea\u0026#39; rows=\u0026#39;5\u0026#39; id=\u0026#39;description\u0026#39; required /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className={classes.action}\u0026gt; \u0026lt;button\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/Container\u0026gt; ); } export default NewMeetupFrom;   20. 使用 useRef 獲取表單元素值  偵測表單內容有兩種做法   使用 useState 監聽每個 input onChange 事件，更新資料 使用 useRef 直接操作 DOM 元素   ref 還適合用在管理 focus、文字選擇、播放影音、整合第三方 DOM 函式庫、觸發動畫 非必要時不濫用 ref 操作 DOM 元素，多數元素保持用 State 管理 ref 建議以 callback 方式使用  1 2 3  // 元素綁定this.content，使用this.xxx呼叫相關屬性 \u0026lt;input type=\u0026#39;text\u0026#39; ref={(el) =\u0026gt; (this.content = el)} /\u0026gt;; this.content.focus();    引入 ref object，使用 current 屬性獲取 value  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  // NewMeetupForm.js import Container from \u0026#34;../ui/Container\u0026#34;; import classes from \u0026#34;./NewMeetupForm.module.css\u0026#34;; import { useRef } from \u0026#34;react\u0026#34;; function NewMeetupForm() { // 創造一個ref物件，帶有ref屬性，裡面有current屬性  const titleInputRef = useRef(); const imageInputRef = useRef(); const addressInputRef = useRef(); const descriptionInputRef = useRef(); function submitHandler(event) { // 阻擋瀏覽器預設事件，避免點下表單就會對伺服器發出請求  event.preventDefault(); // 獲得title目前input值  const enteredTitle = titleInputRef.current.value; const enteredImage = imageInputRef.current.value; const enteredAddress = addressInputRef.current.value; const enteredDescription = descriptionInputRef.current.value; // 創造一個物件管理  const meetupData = { title: enteredTitle, image: enteredImage, address: enteredAddress, description: enteredDescription, }; // send to server console.log(meetupData)  props.onAddMeetupData(meetupData); } return ( \u0026lt;Container\u0026gt; // 新增 submit 監聽  \u0026lt;form className={classes.form} onSubmit={submitHandler}\u0026gt; \u0026lt;div className={classes.control}\u0026gt; \u0026lt;label htmlFor=\u0026#39;title\u0026#39;\u0026gt;Title\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#39;text\u0026#39; id=\u0026#39;title\u0026#39; ref={titleInputRef} required /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className={classes.control}\u0026gt; \u0026lt;label htmlFor=\u0026#39;image\u0026#39;\u0026gt;Image\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#39;url\u0026#39; id=\u0026#39;image\u0026#39; ref={imageInputRef} required /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className={classes.control}\u0026gt; \u0026lt;label htmlFor=\u0026#39;address\u0026#39;\u0026gt;Address\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#39;text\u0026#39; id=\u0026#39;address\u0026#39; ref={addressInputRef} required /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className={classes.control}\u0026gt; \u0026lt;label htmlFor=\u0026#39;description\u0026#39;\u0026gt;Description\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#39;textarea\u0026#39; rows=\u0026#39;5\u0026#39; id=\u0026#39;description\u0026#39; ref={descriptionInputRef} required /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className={classes.action}\u0026gt; \u0026lt;button\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/Container\u0026gt; ); } export default NewMeetupFrom;    表單資料丟到父層  1 2 3 4 5 6 7 8 9 10 11 12 13 14  // pages/NewMeetup.js function NewMeetupPage() { // 表單資料meetupData  function addMeetupHandler(meetupData) { // send http req  } return ( \u0026lt;section\u0026gt; \u0026lt;h1\u0026gt;Add New Meetup\u0026lt;/h1\u0026gt; \u0026lt;NewMeetupForm onAddMeetupData={addMeetupHandler}\u0026gt; \u0026lt;/section\u0026gt; ); } export default NewMeetupPage;   21. API 串接 為什麼需要 API  前端的程式碼在 devtool 可以看到，透過 API 資料跟 server 要資料以確保安全 不然懂一點程式的人透過前端程式碼呼叫 server，可以盜取使用者個資，也可以把你 server 清空 可以用 Firebase Realtime Database 測試前端丟出去的 JSON 資料  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  function NewMeetupPage() { function addMeetupHandler(meetupData) { // Firebase realtime 資料庫的API後方加上/xxx.json等於一個大表  fetch(\u0026#39;firebaseAPI網址/xxx.json\u0026#39;, { method: \u0026#39;POST\u0026#39;, // body是JSON格式  body:JSON.stringify(meetupData), // 部分API會要求提供\u0026#39;Content-Type\u0026#39;  headers: { \u0026#39;Content-Type\u0026#39;:\u0026#39;application/json\u0026#39; } }) } return ( \u0026lt;section\u0026gt; \u0026lt;h1\u0026gt;Add New Meetup\u0026lt;/h1\u0026gt; \u0026lt;NewMeetupForm onAddMeetupData={addMeetupHandler}\u0026gt; \u0026lt;/section\u0026gt; ); } export default NewMeetupPage;   22. 使用 useHistory 跳轉頁面  history.goBack() 回上一頁 history.push(\u0026rsquo;/\u0026rsquo;) 到首頁，新增一個網址資料到陣列尾端 history.replace(\u0026rsquo;/\u0026rsquo;) 回首頁，直接取代 current entry 資料，不新增資料，當不希望使用者回上一頁可使用  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import { useHistory } from \u0026#34;react-router-dom\u0026#34;; function NewMeetupPage() { function addMeetupHandler(meetupData) { // Firebase realtime 資料庫的API後方加上/xxx.json等於一個大表  fetch(\u0026#34;firebaseAPI網址/xxx.json\u0026#34;, { method: \u0026#34;POST\u0026#34;, // body是JSON格式  body: JSON.stringify(meetupData), // 部分API會要求提供\u0026#39;Content-Type\u0026#39;  headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, }, }).then(() =\u0026gt; { history.replace(\u0026#34;/\u0026#34;); }); } }   23. 使用 useEffect  useEffect 可以用來限制元件不要每次渲染都執行所有的程式碼 第一個參數為函式，第二個是陣列，只有[]內容有變化才會執行 若沒加第二個參數等於每次都會執行，有用跟沒用一樣 若為空陣列，由於沒有相依任何變數，所以偵測不到變化，只會執行第一次 若裡面有變數，則變數有變化就會再執行一次 適合用在 fetch data、訂閱監聽事件、改變 DOM、輸出 log get 方法讓個別頁面獲取不同資料(把 dummyData 換成實際 server 資料)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  // pages/AllMeetup.js import { useState, useEffect } from \u0026#34;react\u0026#34;; function AllMeetupsPage() { const [isLoading, setIsLoading] = useState(true); const [meetups, setMeetups] = useState([]); useEffect(() =\u0026gt; { // fetch回傳promise  fetch(\u0026#34;firebaseUrl/meetups.json\u0026#34;) .then((response) =\u0026gt; { // 獲取body 使用.json方法 把json檔案變成JS object  // 因為.json return promise所以用then接 課程這邊專心在獲取資料 沒有寫到error處理  return response.json(); }) .then((data) =\u0026gt; { // 我們期望是陣列資料套入到模板，而firebase上的meetups資料是巢狀物件結構  // 最外層是一個object，每筆資料是一個key value pair  // meetups = {  // key1: {title:\u0026#39;\u0026#39;, image:\u0026#39;\u0026#39;, address:\u0026#39;\u0026#39;, description:\u0026#39;\u0026#39;},  // key2: {title:\u0026#39;\u0026#39;, image:\u0026#39;\u0026#39;, address:\u0026#39;\u0026#39;, description:\u0026#39;\u0026#39;}  // }  const meetups = []; for (const key in data) { // 解構出data  const meetups = { id: key, ...data[key], }; // 資料一筆筆推入陣列  meetups.push(meetup); } setIsLoading(false); setMeetups(data); }); }, []); if (isLoading) { return ( \u0026lt;section\u0026gt; \u0026lt;p\u0026gt;Loading...\u0026lt;/p\u0026gt; \u0026lt;/section\u0026gt; ); } // 這段不會等上面回傳資料，但不能用async function AllMeetupPage await fetch來處理  // 元件函式應是同步函式，不應該return promise而是JSX  // 可使用State條件渲染 loading  return ( \u0026lt;section\u0026gt; \u0026lt;h1\u0026gt;AllMeetupsPage\u0026lt;/h1\u0026gt; {meetups.map((el) =\u0026gt; { return \u0026lt;li key={el.id}\u0026gt;{el.title}\u0026lt;/li\u0026gt;; })} \u0026lt;/section\u0026gt; ); } export default AllMeetupsPage;    若沒使用 useEffect，當 useState 更新狀態會再跑一次元件，再 fetch 一次就會無限迴圈  24-1 useContext 管理全域 State (這個應該是最複雜的)  上面介紹過 useState 在單個元件的更新資料方法 如果需要管理全域的 State，可以用 props 傳遞 State 更新其他元件資料，但大專案會不好維護跟管理 也可以使用 redux，但 React 函式庫本身就有內建 context 管理 State 的 function 管理 State 的 context 一般會建立在 src/store 下(e.g. favorites-context.js)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  import { createContext, useState } from \u0026#34;react\u0026#34;; // 建立一個context物件 裡面放初始值 const FavoritesContext = createContext({ favorites: [], totalFavorites: 0, addFavorite: (favoriteMeetup) =\u0026gt; {}, removeFavorite: (favoriteMeetup) =\u0026gt; {}, itemIsFavorite: (favoriteMeetup) =\u0026gt; {}, }); // 更新我的最愛State的函式 用來管理這個函式裡的State 這邊加上export之後會從外部呼叫 export function FavoritesContextProvider(props) { const [userFavorites, setUserFavorites] = useState([]); // 建立三個處理我的最愛State的函式  function addFavoriteHandler(favoriteMeetup) { setUserFavorites((prevUserFavorites) =\u0026gt; { return prevUserFavorites.concat(favoriteMeetup); }); } function removeFavoriteHandler(meetupId) { setUserFavorites((prevUserFavorites) =\u0026gt; { return prevUserFavorites.filter((prev) =\u0026gt; prev.id !== meetupId); }); } function itemIsFavoriteHandler(meetupId) { return userFavorites.some((meetup) =\u0026gt; meetup.id !== meetupId); } // 新增一個 context object 透過value把值傳過去  const context = { // 把userFavorite的snapshot放在這裡，當State改變context物件也會改變  // 也會透過value={context}傳新的值到相關元件  favorites: userFavorites, totalFavorites: userFavorites.length, // 當其他元件要使用上方三個函式時，用pointer指向下面的key然後就會執行後面的函式，即上面的function  addFavorite: addFavoriteHandler, removeFavorite: removeFavoriteHandler, itemIsFavorite: itemIsFavoriteHandler, }; // Provider是內建的元件 必須包在所有會跟他互動的元件(e.g. App) value會傳值  return ( \u0026lt;FavoritesContext.Provider value={context}\u0026gt; {props.children} \u0026lt;/FavoritesContext.Provider\u0026gt; ); } // 輸出Favoritescontext export default FavoritesContext;    index.js 引用，讓全域都可以使用 context  1 2 3 4 5 6 7 8 9 10 11  // index.js import { BrowserRouter } from \u0026#34;react-router-dom\u0026#34;; import { FavoriteContextProvider } from \u0026#34;./store/favorite-context\u0026#34;; RouterDOM.render( \u0026lt;FavoriteContextProvider\u0026gt; \u0026lt;BrowserRouter\u0026gt; \u0026lt;APP /\u0026gt; \u0026lt;/BrowserRouter\u0026gt; \u0026lt;/FavoriteContextProvider\u0026gt; );   24-2 在元件引用 useContext  引用到 MeetupItem.js  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  // 點加入我的最愛就會把item加入陣列，更新按鈕文字 ... import FavoritesContext from \u0026#39;./../../store/favorite-context\u0026#39; function MeetUpItem(props) { function toggleFavoritesStatusHandler() { const favoritesCtx = useContext(FavoritesContext) const itemIsFavorite = favoriteCtx.itemIsFavorite(prop.id) function toggleFavoriteStatusHandler() { if(itemIsFavorite) { favoritesCtx.removeFavorite(prop.id) } else { // 更新陣列資料，就會透過favorite-context讓全域物件下相關資料都更新  favoritesCtx.addFavorite({ id: props.id, title: props.title, address: props.address, image: props.image, description: prop.description }) } } return ( \u0026lt;li className={classes.item}\u0026gt; \u0026lt;Container\u0026gt; ... \u0026lt;div\u0026gt; \u0026lt;button onClick={toggleFavoriteStatusHandler}\u0026gt;{itemIsFavorite ? \u0026#39;Remove\u0026#39; : \u0026#39;Add\u0026#39;}\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/Container\u0026gt; \u0026lt;/li\u0026gt; ); } }    引用到 FavoritesPage  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  ... import { useContext } from \u0026#39;react\u0026#39; import FavoritesContext from \u0026#39;./../store/favorite-context\u0026#39; // 顯示我的最愛item function FavoritesPage(){ const favoritesCtx = useContext(FavoritesContext) let content if (favoritesCtx.totalFavorites.length === 0){ content = \u0026lt;p\u0026gt;No Favorites yet\u0026lt;/p\u0026gt; } else { content = \u0026lt;MeetupList meetups={favoritesCtx.favorites}\u0026gt; } return \u0026lt;section\u0026gt; \u0026lt;h1\u0026gt;My Favorites\u0026lt;/h1\u0026gt; // array  {content} \u0026lt;/section\u0026gt; } export default FavoritesPage    引用到導覽列(放上我的最愛總數)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // MainNavigation.js ... import { useContext } from \u0026#39;react\u0026#39; import FavoritesContext from \u0026#39;./../../store/favorite-context\u0026#39; import { Link } from \u0026#39;react-router-dom\u0026#39; function MainNavigation() { const favoriteCtx = useContext(FavoritesContext) return ( \u0026lt;header\u0026gt; ... \u0026lt;li\u0026gt; \u0026lt;Link to=\u0026#39;/favorites\u0026#39;\u0026gt;My favorites \u0026lt;span\u0026gt;{favoriteCtx.totalFavorites.length}\u0026lt;/span\u0026gt; \u0026lt;/Link\u0026gt; \u0026lt;/li\u0026gt; ... \u0026lt;/header\u0026gt; ) } export default MainNavigation   最後想補充一下\u0026hellip;\n其實我覺得 Vue 也不錯啊（x)\n有好吃的語法糖：用@監聽事件，@submit.prevent.stop 就可阻止瀏覽器提交表單跟冒泡：動態 class，watch 深層監聽物件屬性，computed 動態更新，v-model 雙向綁定表單\u0026hellip;各種好吃的糖)\n原來暗藏一篇 Vue 推銷文，真是太邪惡了\n","date":"2022-01-06T00:00:00+08:00","image":"https://bacnotes.github.io/p/react-knowledge-101/photo-1633356122544-f134324a6cee_hu3d03a01dcc18bc5be0e67db3d8d209a6_61563_120x120_fill_q75_box_smart1.jpeg","permalink":"https://bacnotes.github.io/p/react-knowledge-101/","title":"自學React的你需要知道的一些知識｜React - The Complete Guide｜bacnotes備份筆記"},{"content":"JavaScript 的特性 high level 高階(語言)  高階是接近人類讀得懂的語言，低階是接近機器的 2 進位的機器碼(machine code) 例如 c 語言(低階語言)，需要處理宣告新變數時的記憶體 而高階語言的 python 跟 JavaScript 不需要，但效能不會有 c 語言好  prototype based object-oriented 物件導向  JavaScript 資料除了 primitives 都是物件 陣列也是物件，只是 key 為 index  1 2  let arr = [1, 2, 3] typeof arr //object   interpreted or just-in-time compiled  JavaScript 引擎會幫我們轉成 2 進位的機器碼  dynamic-typed 動態資料型態  宣告變數時不需要給予型別(C、Java、Ruby 要) 容易改變型別  single-threaded 單執行緒  一次只能執行一件事  garbage collected 有記憶體回收機制  有機制會自動移除記憶體中老舊或沒有使用的變數  multi-paradigm 可以同時使用多種風格來寫程式  可以用 Procedural Programming 程序化程式設計 可以用 Function Programming 函式程式設計 可以用 Object-Oriented Programming 物件導向程式設計  with first-class functions 一級函式  一級函式是一種特性，部分程式語言沒有，而 JavaScript 有 一級函式表示在這個語言函式可以被當作一個變數(variable)，賦值給其他變數或做為參數傳遞(functions are values)  non-blocking event loop concurrent model  由於單執行緒但又得處理同時發生的多種任務，容易阻塞 JavaScript 引擎會使用 event loop，一個背景執行的 task，任務執行完的結果會放到 call stack  JavaScript 引擎 v.s. 執行環境 runtime v.s.執行文本 context JavaScript 引擎  各家瀏覽器有自己的 JavaScript 引擎，用來執行 JavaScript Google 開發的 V8 引擎，不只用於 Chrome 還有 Node.js(可以在瀏覽器外執行 JavaScript) JavaScript 引擎包含一個 Call Stack(execution context)跟一個 Heap Heap 是非結構化的記憶體池，儲存所有物件 interpretation：程式碼轉成一行行執行的 code，再轉成機器碼 compilation：整包程式碼轉成 machine code(2 進位)，再執行程式 just-in-time compilation: 程式碼轉成 2 進位後立即執行(避免等待) 當一段程式碼進到引擎會執行下方程序  1 2 3 4  step1. parsing: JavaScript → AST(abstract syntax tree) 結構化JavaScript step2. compilation: AST → 2進位的機器碼 step3. execution: 在call stack執行 step2~3. optimization: 邊執行邊最佳化(在特別的thread執行，無法access)   JavaScript Runtime 執行環境   browser: JavaScript 引擎 + webAPIs + callback queue\n  call stack : 由上到下執行 stack 裡面每一行程式，變數的記憶體也是在這個階段建立(hoisting)，遇到需要呼叫 API 的非同步函式會把裡面的 call back function 丟到 webAPI 排程執行\n  webAPIs 處理非同步函式，當有收到回傳結果，會依照回傳時間順序把 callback function 傳到 callback queue\n  當 stack 清空時，callback queue 就會把 callback function 依序（queue先進先出)丟到 stack 裡執行\n  這整個過程就是 event loop，為了提高瀏覽器的使用體驗，不會被非同步函式等待過程阻塞的機制   node.js: JavaScript 引擎 + C ++ bindings \u0026amp; thread pool + callback queue (這邊知道的大概即可)\n  ＊stack 是先進後出(後進先出)的資料結構，queue 是先進先出的資料結構\nexecution context 執行文本 ＊為了跟執行環境 runtime 做名詞區隔，使用不同中文名稱指稱\n  執行文本包含\n\u0026ndash; variable environment 變數環境:包含 let const var 宣告, 函式, 參數 arguments obj\n\u0026ndash; scope chain 作用域鏈:讓個別函式可以 ref 到函式外的變數，會存在個別執行文本\n\u0026ndash; this:每個執行文本都有自己的 this，在創造階段時誕生(執行階段前)\n  有創造階段跟執行階段\n  箭頭函式沒有自己的 this 或參數，但可以使用父層的 this 或參數\n  執行順序\nstep1. 創造全域執行文本(top-level/not inside the function)\n＊ 只有非 function 的會被執行，因為 function 要被呼叫才會執行\n＊ 只會有一個 global execution context\nstep2. 執行全域執行文本(inside global EC)\nstep3. 執行函式等待 callback 回傳結果\n＊ 依序呼叫個別函式，個別函式的文本會被創造\n＊ call stack 的內容就是由這些個別函式跟文本所組成\n  scope 作用域 \u0026amp; scope chain 作用域鏈 global scope 全域  位於 function 跟 block 外 可以被所有地方存取  function scope 函式作用域  也被稱作 local scope 只能在函式內存取，嘗試存取會出現 error ES6 開始嚴格模式下也是 block scope  block scope(ES6 開始出現) 區塊作用域  let 跟 const 被限制只能在 block 範圍內存取 var 還是可以被 function scope 存取 ES6 開始嚴格模式下 function scope 也是 block scope(寫兩次因為很重要)  scope chain  當變數不存在現有 scope，無論是 block 或 function 都可以讀外面父層裡的變數 找不到時會一層層往外找(variable lookup)，完全找不到會出現 ReferenceError 只能往外找，不能往內 console.log(function 或 block 裡面的變數)會 ReferenceError sibling 之間不行互相讀取 每個 scope chain 都包含他的變數跟的父層的變數 scope chain 可以讀取的變數跟 function 在 call stack 執行順序無關  callstack v.s. scope chain  使用下方函式舉例 step1. 創造全域執行文本\n(全域變數環境：a=\u0026lsquo;Jonas\u0026rsquo;, first=fn, third=fn) step2. 執行全域執行文本，創造出個別執行文本\nfirst()作用域：可以獲取本地作用域跟父層的變數環境\n(變數環境：b=\u0026lsquo;Hello\u0026rsquo;, second=fn, a=\u0026lsquo;Jonas\u0026rsquo;, first=fn, third=fn)\nsecond()作用域：可以獲取本地作用域跟父層的變數環境\n(變數環境：c, b=\u0026lsquo;Hello\u0026rsquo;, second=fn, a=\u0026lsquo;Jonas\u0026rsquo;, first=fn, third=fn)\nthird()作用域：可以獲取本地作用域跟父層的變數環境\n(變數環境：d=\u0026lsquo;Hey\u0026rsquo;, a=\u0026lsquo;Jonas\u0026rsquo;, first=fn, third=fn) step3. 執行個別文本(執行函式)，等待 callback 回傳結果  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  const a = \u0026#39;Jonas\u0026#39;; first(); function first() { const b = \u0026#39;Hello\u0026#39;; second(); function second() { const c = \u0026#39;H1\u0026#39;; third(); } } function third() { const d = \u0026#39;Hey!\u0026#39;; console.log(d + c + b + a); // ReferenceError }   ＊下方是另一個範例，輸出結果用//表示，且視為單獨出現這行的狀況（彼此之間不影響）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  \u0026#39;use strict\u0026#39;; const firstName = \u0026#39;Jonas\u0026#39; function calcAge(birthYear) { const age = 2037 - birthYear function printAge() { // 執行時裡面沒有age，variable lookup往父層找  const output = `You are ${age}, born in ${birthYear}`; console.log(output); if (birthYear \u0026gt;= 1981 \u0026amp;\u0026amp; birthYear \u0026lt;= 1996) { var millenial = true; // 創造跟外面一樣變數名的新變數  const firstName = \u0026#39;Steven\u0026#39; const str = `you are a millenial, ${firstName}`; console.log(str); // 執行時裡面沒有firstName，往父層找 you are a millenial, Jonas  function add(a, b) { return a + b; } // 內部重新賦值output 下方會列印出新的值的output  output = \u0026#39;New output\u0026#39; } console.log(str); // 無法獲取內部變數 str is not defined  console.log(millenial); // var不是block scope是function scope因此可以獲取同function的變數 true  console.log(add(3,5)) //add function 嚴格模式下也是block scope 會ReferenceError，非嚴格模式下會是8  console.log(output) //\u0026#39;New output\u0026#39;  } printAge() return age } calcAge(1991) // You are 46, born 1991 console.log(age) // ReferenceError 無法獲取內部變數age printAge(); // ReferenceError 無法獲取內部變數 printAge()   總結  要了解變數存活的區域，哪裡可以獲取這些值 如何設計變數的位置跟獲取程式的變數 lexical scoping 是使用 function 跟 block 等封閉環境，控制變數存取 scope 宣告變數的環境，有 global 全域, function 函式跟 block 區塊三種作用域 所有 scope 都可以獲取父層的 scope，因為這是一條 scope chain  Hoisting 提升  表面上是可以在宣告前被使用 其實是在執行階段前，已經在創造階段就建立在變數環境(variable environment) 不同變數行為不同  函式宣告  函式宣告會提升 未宣告使用為實際值 變數存取範圍嚴格模式下為 block scope，非嚴格模式下為 function scope  var  var 會提升 未宣告使用為 undefined 變數存取範圍為 function scope  const/let  const 跟 let，技術上來說有提升但是未初始化 uninitialized 沒有可取用的值 未宣告使用下會被鎖在 TDZ(temporary dead zone) 變數存取範圍為 block scope  函式表達式跟箭頭函式  函式表達式跟箭頭函式若用 var 存取會提升 未宣告使用是 undefined，反之則跟 const/let 特性一樣 這也是為何在函式表達式中，我們無法使用在宣告變數前調用函式，而函式宣告可以不顧函式宣告順序，任何地方都可以調用  TDZ 是什麼 (ES6 開始出現)  TDZ 為變數初始化前的區塊 下圖 job 在被 const 宣告前被呼叫，會出現 ReferenceError cannot access \u0026lsquo;job\u0026rsquo; before initialization，需要宣告後才能被使用 但如果呼叫完全沒被創造的變數，會顯示另一種訊息 ReferenceError x is not defined 有 TDZ 比較容易抓出未宣告使用的錯誤 另一個 TDZ 存在好處是，因 const 無法重新賦值，所以無法設定 undefined 再給新的值，TDZ 可以讓 const 順利運作 hoisting 的好處：mutual recursion，讓 code 可讀性高，而 var 的 hoisting 算是副產物，後見之明看來不是好東東  ＊下方輸出結果用//表示，且視為單獨出現這行的狀況（彼此之間不影響）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // Variables console.log(me); // not defined console.log(job); // ReferenceError cannot access \u0026#39;job\u0026#39; before initialization console.log(year); // ReferenceError cannot access \u0026#39;job\u0026#39; before initialization  var me = \u0026#39;Jonas\u0026#39;; let job = \u0026#39;teacher\u0026#39;; const year = 1991; -- // Functions console.log(addDecl(2, 3)); // 5 console.log(addExpr(2, 3)); // cannot access \u0026#39;addExpr\u0026#39; before initialization console.log(addArrow(2, 3)); // undefined(2,3) -\u0026gt; // addArrow is not a function  function addDecl(a, b) { return a + b; } const addExpr = function (a, b) { return a + b; }; var addArrow = (a, b) =\u0026gt; a + b;    因為 hoisting 造成的 bug 範例，使用 const/let 可避免，養成先宣告變數再使用的好習慣  1 2 3 4 5 6 7 8 9 10 11  // 原本期待不存在product執行deleteShoppingCart() // 因為沒宣告變數就使用，值變成undefined // !undefined而變成true console.log(!numProducts); //true // !undefined is true if (!numProducts) deleteShoppingCart(); var numProducts = 10; function deleteShoppingCart() { console.log(\u0026#39;All products deleted!\u0026#39;); }    當用 var 宣告，會在 browser 的 window(全域變數)下多一個屬性  1 2 3 4 5 6 7  var x = 1; let y = 2; const z = 3; console.log(x === window.x); // true console.log(y === window.y); // false console.log(z === window.z); // false   this 是什麼?  所有執行文本下都會有的特別變數，值取決於被呼叫的方式 作為 Method(物件下的 function)呼叫時，this 是呼叫他的變數 一般函式呼叫，嚴格模式下 this 值是 undefined，非嚴格模式下為全域物件 箭頭函式沒有自己的 this，this 值取決於父層(parent scope) eventListener 呼叫時，指向觸發的元素 this 不會是函式自己，也不會是變數環境(Variable Environment) new, call, apply, bind 會於其他篇介紹  ＊下方輸出結果用//表示，且視為單獨出現這行的狀況（彼此之間不影響）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  // this Keyword in Practice console.log(this); //window object  const calcAge = function (birthYear) { console.log(2037 - birthYear); console.log(this); }; calcAge(1991); // 46 嚴格模式 this是undefined 非嚴格模式this是window object  const calcAgeArrow = birthYear =\u0026gt; { console.log(2037 - birthYear); console.log(this); }; calcAgeArrow(1980); // 父層的this window object  const jonas = { year: 1991, calcAge: function () { console.log(this); console.log(2037 - this.year); }, }; jonas.calcAge(); // 46 jonas呼叫 this是jonas  const matilda = { year: 2017, }; matilda.calcAge = jonas.calcAge; // copy calcAge method from jonas matilda.calcAge(); // matilda, 20  // this是動態的 const f = jonas.calcAge; // copy function to a new variable f(); // 一般函式方法呼叫this undefined, cannot read property \u0026#39;year\u0026#39; of undefined at calcAge   讓 this 指向父層的 2 種做法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  // var firstName = \u0026#39;Matilda\u0026#39;;  const jonas = { firstName: \u0026#39;Jonas\u0026#39;, year: 1991, calcAge: function () { // console.log(this); // jonas  console.log(2037 - this.year); // Solution 1 (ES6前) 在函式外定義self為this 取得jonas  // const self = this; // self or that  // const isMillenial = function () {  // console.log(self);  // console.log(self.year \u0026gt;= 1981 \u0026amp;\u0026amp; self.year \u0026lt;= 1996);  // };  // Solution 2 （modern) 使用箭頭函式，沒有自己的this，會往父層找  const isMillenial = () =\u0026gt; { console.log(this); console.log(this.year \u0026gt;= 1981 \u0026amp;\u0026amp; this.year \u0026lt;= 1996); }; isMillenial(); // 一般函式呼叫 嚴格模式下undefined 除非用self綁定this或用箭頭函式呼叫  }, greet: () =\u0026gt; { console.log(this); console.log(`Hey ${this.firstName}`); }, }; jonas.greet(); jonas.calcAge(); // 沒有solution狀況下 cannot read property of \u0026#39;year\u0026#39; of undefined   一般函式 v.s. 箭頭函式 物件內的函式  當使用一般函式會有自己的 this，可以取得 jonas.firsName 當使用箭頭函式會沒有自己的 this，會往父層取變數，bug 通常在這裡發生（可能取得 undefined 或真的有一個變數值) 全域避免使用 var  1 2 3 4 5 6 7 8 9 10 11 12  // 用 let/const 的話會是 undefined，使用 var 就會是\u0026#39;hey mirenda\u0026#39; var firstName = \u0026#39;mirenda\u0026#39; const jonas = { firstName: \u0026#39;Jonas\u0026#39;, year: 1991, // 箭頭函式沒有自己的this  greet: () =\u0026gt; { console.log(this); console.log(`Hey ${this.firstName}`); }, }; jonas.greet(); // window obj, hey mirenda   arguments  只存在一般函式，箭頭函式沒有  1 2 3 4 5 6 7 8 9 10 11 12  const addExpr = function (a, b) { console.log(arguments); return a + b; }; addExpr(2, 5); addExpr(2, 5, 8, 12); // 雖然function上面參數設定2個，但可以加上更多arguments存到Arguments陣列，可以loop加總這些參數等  var addArrow = (a, b) =\u0026gt; { console.log(arguments); return a + b; }; addArrow(2, 5, 8);    arguments 跟其餘運算子的搭配  1 2 3 4 5 6 7 8 9 10  const restaurant = { orderPizza: function(mainIngredients, ...otherIngredients) { console.log(mainIngredients) console.log(otherIngredients) } } restaurant.orderPizza(\u0026#39;mushrooms\u0026#39;, \u0026#39;onions\u0026#39;, \u0026#39;olives\u0026#39;, \u0026#39;spinach\u0026#39;) // mushrooms [ \u0026#39;onions\u0026#39;, \u0026#39;olives\u0026#39;, \u0026#39;spinach\u0026#39; ] restaurant.orderPizza(\u0026#39;mushrooms\u0026#39;) // mushrooms []    當函式很多 argument 不好記順序，可以傳入一個物件作為參數，函式會解構物件並執行函式 常用於第三方函式庫  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  const restaurant = { starterMenu: [\u0026#39;Focaccia\u0026#39;, \u0026#39;Bruschetta\u0026#39;, \u0026#39;Garlic Bread\u0026#39;, \u0026#39;Caprese Salad\u0026#39;], mainMenu: [\u0026#39;Pizza\u0026#39;, \u0026#39;Pasta\u0026#39;, \u0026#39;Risotto\u0026#39;], orderDelivery: function ({ starterIndex = 1, // 預設值  mainIndex = 0, // 預設值  time = \u0026#39;00:00\u0026#39;, // 預設值  address, }) { console.log( `Order received! ${this.starterMenu[starterIndex]}and ${this.mainMenu[mainIndex]}will be delivered to ${address}at ${time}` ); }, }; restaurant.orderDelivery({ time: \u0026#39;22:30\u0026#39;, address: \u0026#39;via del sole, 21\u0026#39;, mainIndex: 2, starterIndex: 2 }); // Order received! Garlic Bread and Risotto will be delivered to via del sole, 21 at 22:30  // 沒有全部參數 會用函式參數的預設值 restaurant.orderDelivery({ address: \u0026#39;via del sole, 21\u0026#39;, starterIndex: 2, }); // Order received! Garlic Bread and Pizza will be delivered to via del sole, 21 at 00:00   primitives v.s. objects  primitives 包含 數字、字串、布林、undefined、null、Symbol、BigInt，其他都是 objects primitives 記憶體存在 call stack objects 記憶體存在 Heap  primitives  let age = 30 給一個 call stack 的記憶體地址跟 30 的值(0001) let oldAge = age 傳 age 的 call stack 地址(0001)給 oldAge primitives 的值是 immutable（不可變更），當我們寫 age = 31 會再給一個新的記憶體的地址跟值給 age(0002)，而非修改原本的 30 的那塊記憶體(0001)的內容  objects  const me = {name: \u0026lsquo;Jonas\u0026rsquo;}，給一個 call stack 記憶體的地址跟 Heap 的地址 因為物件檔案可能太大，所以記憶體實際上是存在 Heap const friend = me，會傳 me 記憶體的地址給 friend friend.name = \u0026lsquo;mirenda\u0026rsquo; 物件跟上面的 primitives 不同，會改到 me 的值(D30F)，值參照同樣的 Heap 地址，並沒有另外再給一個新的記憶體，可以參考下方圖表的箭頭（只有一個)  常用淺拷貝方法  Object.assign 用於物件  1 2 3 4 5 6 7 8 9 10 11  const jessica = { firstName: \u0026#39;Jessica\u0026#39;, lastName: \u0026#39;Williams\u0026#39;, age: 27, family: [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;], }; const jessicaCopy = Object.assign({}, jessica); jessicaCopy.lastName = \u0026#39;Davis\u0026#39;; console.log(\u0026#39;Before marriage:\u0026#39;, jessica.lastName); // \u0026#39;Williams\u0026#39; console.log(\u0026#39;After marriage: \u0026#39;, jessicaCopy.lastName); // \u0026#39;Davis\u0026#39;    展開運算子 除了物件外也可用於 string、array、array-like、Set、Map 等可迭代物件  1 2  const arr = [1, 2, 3] const arrCopy = [...arr]   ","date":"2022-01-03T00:00:00+08:00","image":"https://bacnotes.github.io/p/javascript-behind-the-scenes/kanan-khasmammadov-7K8_U900tVc-unsplash_hu1499a893ce824cc10dc28f27c37e5d8f_1839383_120x120_fill_q75_box_smart1.jpg","permalink":"https://bacnotes.github.io/p/javascript-behind-the-scenes/","title":"JavaScript底層運作原理101｜The Complete JavaScript Course｜bacnotes備份筆記"},{"content":"完全沒有接觸過 JavaScript 語言的朋友們，可以先補足下方知識點再繼續閱讀唷\nJavaScript 基礎知識複習(1)\nJavaScript 基礎知識複習(2)\nDocument Object Model(DOM) 是什麼  將 HTML 元素變成文件物件模型，由節點 Node 組成，樹狀結構 讓 JavaScript 可以修改 HTML 內容跟改變 CSS 樣式(HTML 的 style 屬性) DOM 最上方結構是 document 物件，是我們對 DOM 的 entry point 節點之間有縱向的父子關係(parent/child)或橫向的兄弟關係(sibling) 第一個子元素通常是 HTML(也被稱作根元素)，下方通常有兩個子元素 head 跟 body，互為 sibling DOM 方法(e.g. querySelector)跟屬性(e.g. innerHTML)不屬於 JavaScript 這個語言，而是 WebAPIs(瀏覽器上使用 JavaScript 撰寫的 library)的一部分 我們可以用 JavaScript 去跟 WebAPIs 互動，像是 timer、fetch API  選取元素 選取單個元素 document.querySelector()  回傳相符的第一個元素  1 2  document.querySelector(\u0026#39;#id\u0026#39;) //id selector document.querySelector(\u0026#39;.classname\u0026#39;) //class selector   選取多個元素 document.querySelectorAll()  回傳所有相符的元素於一個 nodeList 類陣列 比單個元素多 index 與 length 屬性 只能使用部分陣列方法(e.g. forEach, index, length)  1 2  document.querySelectorAll(\u0026#39;.classname\u0026#39;) // class selector document.querySelectorAll(\u0026#39;li\u0026#39;) // type selector   選取多個元素中特定條件 1 2  // 選取tbody第一行內容 document.querySelectorAll(\u0026#39;.className tbody tr\u0026#39;)[0]   選取文字內容 innerHTML v.s. innerText v.s. textContent 下方是一段 HTML\n1 2 3 4  \u0026lt;section class=\u0026#34;left\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; class=\u0026#34;guess\u0026#34; /\u0026gt; \u0026lt;button class=\u0026#34;btn check\u0026#34;\u0026gt;Check!\u0026lt;/button\u0026gt; \u0026lt;/section\u0026gt;    innerHTML 選取元素下的整個 HTML 結構  1 2 3 4  console.log(document.querySelector(\u0026#39;.left\u0026#39;).innerHTML) //  \u0026lt;input type=\u0026#34;number\u0026#34; class=\u0026#34;guess\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;btn check\u0026#34;\u0026gt;Check!\u0026lt;/button\u0026gt;    innerText 選取整個 HTML 下可見(非 display:none)的文字 會讀取 CSS，效能較差  1 2 3 4  console.log(document.querySelector(\u0026#39;.left\u0026#39;).innerText) // Check!    textContent 選取整個 HTML 下的所有文字(包含空白) 不會讀取 CSS，效能較好  1 2 3 4 5  console.log(document.querySelector(\u0026#39;.left\u0026#39;).textContent) //  Check!   document.querySelector().value 選取表單元素值 1  document.querySelector(\u0026#39;.className\u0026#39;).value;   修改元素內容 在選取元素後加上 = 即可\n1  document.querySelector(\u0026#39;.className\u0026#39;).value = 1   修改 CSS 樣式 修改特定屬性 1 2 3 4  // 修改顏色 document.querySelector(\u0026#39;body\u0026#39;).style.background = \u0026#39;#ffffff\u0026#39; // 修改寬度 document.querySelector(\u0026#39;.number\u0026#39;).style.width = \u0026#39;10rem\u0026#39;   新增/切換/刪除/確認 class 1 2 3 4  document.classList.add(\u0026#39;hidden\u0026#39;); document.classList.toggle(\u0026#39;hidden\u0026#39;); document.classList.remove(\u0026#39;hidden\u0026#39;); document.classList.contains(\u0026#39;hidden\u0026#39;);   新增/切換/刪除/確認 屬性/回傳屬性值 1 2 3 4 5  document.setAttribute(\u0026#39;disable\u0026#39;); document.toggleAttribute(\u0026#39;disable\u0026#39;); document.removeAttribute(\u0026#39;disable\u0026#39;); document.hasAttribute(\u0026#39;disable\u0026#39;); // 是否包含指定屬性 return boolean document.getAttribute(\u0026#39;width\u0026#39;); // 回傳指定屬性值 e.g. 18rem 不存在會回傳null   設置監聽事件  第一個參數為事件，第二個為執行{}內容，第三個是否捕捉冒泡事件 第三個參數沒有設定時預設為 false 監聽冒泡事件，設定為 true 監聽捕捉事件  1  element.addEventListener(event, function, useCapture)   滑鼠點擊事件 click 1 2 3 4 5 6 7  // 選取按鈕跟呈現訊息元素 const guessButton = document.querySelector(\u0026#39;.check\u0026#39;) const message = document.querySelector(\u0026#39;.message\u0026#39;) // 用addEventListener監聽guessButton元素上的click事件 guessButton.addEventListener(\u0026#39;click\u0026#39;, function(){ console.log(\u0026#39;click\u0026#39;) })   按鍵事件 keydown v.s. keyup v.s. keypress  keydown 按下去時觸發(不放開會連續觸發) keyup 抬起來時觸發 keypress 按著時觸發(不放開會連續觸發)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // 任何鍵盤皆可觸發keypress事件 document.addEventListener(\u0026#39;keypress\u0026#39;, function(){ console.log(\u0026#39;key pressed\u0026#39;) }) // 任何鍵盤皆可觸發keydown事件 document.addEventListener(\u0026#39;keydown\u0026#39;, function(e){ //只在esc按鍵下觸發  if(e.key === \u0026#39;Escape\u0026#39;) { // 在modal\u0026#34;沒有\u0026#34;hidden class下，也就是顯示modal時觸發  if(!modal.classList.contains(\u0026#39;hidden\u0026#39;)) { console.log(\u0026#39;close modal\u0026#39;) } } })    keycode:每一個鍵盤都有一個對應的數字，可以到這裡查詢keycodeInfo  捕捉特定條件事件  監聽觸發事件元素  1 2 3  if(event.target) { console.log(\u0026#39;event\u0026#39;) }    監聽設置在父元素，下面可能有多個子元素，設置 data-* attribute，符合條件的才觸發  1 2 3  if(event.target.dataset.id === 變數) { console.log(\u0026#39;event\u0026#39;) }    設置 class，偵測有無特定 class 時觸發  1 2 3  if(!modal.classList.contains(\u0026#39;hidden\u0026#39;)) { console.log(\u0026#39;event\u0026#39;) }   其他常用事件  dblclick(雙擊滑鼠) resize(變更視窗大小) select(選取) focus(當元素處於 focus 聚焦狀態，e.g.聚焦在表單某一行 input) blur(當元素失去焦點狀態，e.g.點聚焦元素旁邊內容) DOMContentLoaded(HTML 檔案解析完成，樣式表跟外部資源還在下載時) scroll(捲軸滾動) submit(提交表單) mouseover(滑鼠移到目標) mouseenter(滑鼠移到目標，不會連續觸發) mousemove(滑鼠移動) mouseout(滑鼠離開目標) mouseleave(滑鼠離開目標，不會冒泡) mousedown(按下滑鼠) mouseup(滑鼠放開) contextmenu(按下滑鼠右鍵)  補充 早期選取元素的方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14  // 選取ID document.getElementById(\u0026#39;idName\u0026#39;) 同 document.querySelector(\u0026#39;#idName\u0026#39;) // 選取class name document.getElementsByClassName(\u0026#39;className\u0026#39;) 同 document.querySelectorAll(\u0026#39;.className\u0026#39;) // 選取HTMLCollection document.getElementsByTagName(\u0026#39;li\u0026#39;) 同 document.querySelector(\u0026#39;li\u0026#39;) // 選取name 属性的值 在不同瀏覽器的邏輯不同，避免使用 document.getElementsByName()   NodeList v.s. HTMLCollection  NodeList 為節點的集合，包含 HTML 元素節點和其他節點(e.g.屬性節點、文字節點等) HTMLCollection 為 HTML 元素集合，只有元素節點，不包含其他節點 HTMLCollection 多一個 nameItem()方法，可以回傳集合中 name 屬性和 id 屬性值的元素  ","date":"2022-01-02T00:00:00+08:00","image":"https://bacnotes.github.io/p/javascript-dom-manipulation/jade-seok-WOv2t_N6iwQ-unsplash_hueaef48dcbe256bb88acf1618f8b7005a_507165_120x120_fill_q75_box_smart1.jpg","permalink":"https://bacnotes.github.io/p/javascript-dom-manipulation/","title":"DOM操作基礎知識複習｜The Complete JavaScript Course｜bacnotes備份筆記"},{"content":"恭喜你來到第二篇 JavaScript 基礎知識複習(2)\n如果還沒看過 JavaScript 基礎知識複習(1)\n可以看完上一篇，再回來繼續閱讀唷！\n使用嚴格模式提高程式碼品質 在檔案最上方加 'use strict mode' ，會幫你檢查哪些不適當的撰寫程式方式，下方狀況會拋出錯誤\n 未宣告的全域變數 對於無法寫入的變數(e.g. NaN, undefined)或不存在的物件屬性賦值 刪除不能刪除的屬性(e.g. delete Object.prototype) 物件屬性不是唯一值 unique Function 名稱有重複 deleting plain names  1 2  var x; delete x; // !!! syntax error    使用到 reserved keywords  function  實踐 dry code，重複使用一樣的邏輯，傳不同的參數 parameter 是 function 的右邊的參數 argument 是用在實際呼叫的值 call = invoke = execute = run 都是執行(函式)的動詞  1 2 3 4 5 6  function fruitProcessor(applesCount, orangesCount) { const juice = `juice with ${applesCount}apples \u0026amp; ${orangesCount}oranges`; return juice; } fruitProcessor(2, 5); // \u0026#39;juice with 2 apples \u0026amp; 5 oranges\u0026#39; fruitProcessor(3, 4); // \u0026#39;juice with 3 apples \u0026amp; 4 oranges\u0026#39;   函式宣告 function declaration  呼叫後存到變數  1 2 3 4 5  function calcAge(birthYear) { return 2037 - birthYear; } const age = calcAge(2036); // 放在function前後都可以 因為hoisting console.log(age); // 1   函式表達式 function expression  匿名函式是 expression 會產生 value，存到左邊變數  1 2 3 4  const calcAge = function (birthYear) { return 2037 - birthYear; }; console.log(calcAge(2036)); // 1   箭頭函式 arrow function  ES6 語法，沒有自己的 this 若箭頭函式直接返回一個物件，必須在物件外面加上小括號  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  // 單行程式碼 不需要{}跟return const calcAge = (birthYear) =\u0026gt; 2037 - birthYear; console.log(calcAge(2036)); // 1  // 多行程式碼 需要{}跟return 程式會結束在return這行 const retireAge = (yourName, birthYear) =\u0026gt; { const age = 2037 - birthYear; const retirement = 65 - age; return `${yourName}retires in ${retirement}years`; }; console.log(retireAge(\u0026#34;bacnotes\u0026#34;, 2036)); // bacnotes retires in 64 years  // 單一參數時，小括號可以省略 const print = (a) =\u0026gt; { console.log(a); }; // 多個參數時，小括號不能省略 const print = (a, b) =\u0026gt; { console.log(a, b); }; // 單行程式碼要直接回傳物件時，則需要再套一層小括號，key value一樣{a:a, b:b} 寫 {a,b}即可 const print = (a, b) =\u0026gt; ({ a, b }); // 等於 const print = (a, b) =\u0026gt; { return { a, b, }; };   array 陣列 宣告陣列 1 2  const arrayA = [1, 2, 3]; const arrayB = new Array(123, 123, 123);   ＊JavaScript 的內建物件都不建議 new 作初始定義的。不過有一些特例是一定要的，例如 Date、Error 等等。\n陣列取值，序號從 0 開始 1 2 3  array[0] // 第1個元素值 array[n] // 第n+1個元素值 array[arr.length - 1] 陣列尾巴元素值   修改陣列元素值 1  arrayA[2] = 234;    const 不是不能修改值嗎？ 單獨修改元素值是可以的 如果是 arrayA = [\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;] 就不行，因為就表示重新賦值整個陣列 補充 immutable（不可變更）跟 mutable（可變更）：只有賦值時是傳值的 primitives 是 immutable，而賦值時是傳址的陣列、物件內部值是 mutable  想更了解傳值跟傳址在記憶體裡的運作方式，可以參考這一篇\nJavaScript 底層運作原理 101\narray 方法  array.push() 新增元素到陣列最後面，回傳陣列新的長度  1 2 3 4  const friends = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;]; const newFriend = friends.push(\u0026#34;e\u0026#34;); console.log(friends); // [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39; ] console.log(newFriend); // 5    array.pop() 刪除陣列最後一個元素 並回傳 刪除的元素值  1 2 3 4  const friends = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;]; const popFriend = friends.pop(); console.log(friends)[(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;)]; console.log(popFriend); // e    array.unshift() 新增元素到陣列最前面，回傳陣列新的長度  1 2 3 4  const friends = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;]; const unshiftFriend = friends.unshift(\u0026#34;z\u0026#34;); console.log(friends); // [ \u0026#39;z\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39; ] console.log(unshiftFriend); // 5    array.shift() 刪除陣列第一個元素，回傳刪除的元素值  1 2 3 4  const friends = [\u0026#34;z\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;]; const shiftFriend = friends.shift(); console.log(friends); // [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39; ] console.log(shiftFriend); // z    array.indexOf(element, fromIndex) 搜尋元素索引位置  1 2 3 4 5  const friends = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;]; const positionD = friends.indexOf(\u0026#34;d\u0026#34;); console.log(positionD); // 3 const positionL = friends.indexOf(\u0026#34;l\u0026#34;); console.log(positionL); // if not existed return -1    array.includes(element, fromIndex) 回傳陣列中是否有這個元素  1 2 3  const hasLowerCaseA = friends.includes(\u0026#34;a\u0026#34;); const hasUpperCaseA = friends.includes(\u0026#34;A\u0026#34;); console.log(hasLowerCaseA, hasUpperCaseA); // true, false   還有很多其他的 array 方法，可以參考這篇 陣列的處理方法 推薦這篇大大寫的JavaScript Array 陣列操作方法大全 ( 含 ES6 )\nobject 物件  key value pair value 可以儲存不同格式的資料  宣告物件 1 2 3 4 5 6 7  const jonas = { firstName: \u0026#34;Jonas\u0026#34;, lastName: \u0026#34;Schmedtmann\u0026#34;, age: 28, job: \u0026#34;teacher\u0026#34;, friends: [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;], };   dot notation 取值：物件.屬性 直觀簡潔，無法在[]裡面修改資料\n1  console.log(jonas.lastName); // \u0026#39;Schmedtmann\u0026#39;   bracket notation 取值：物件[\u0026lsquo;屬性\u0026rsquo;] 可以在[]裡面修改資料\n[]裡面是一個 expression，屬性記得用單引號包裹\n1 2 3 4  console.log(jonas[\u0026#34;lastName\u0026#34;]); // \u0026#39;Schmedtmann\u0026#39;  const nameKey = \u0026#34;Name\u0026#34;; console.log(jonas[\u0026#34;last\u0026#34; + nameKey]); // \u0026#39;Schmedtmann\u0026#39;   brackets notation 可以使用 expression，dot notation 無法 1 2 3 4 5 6 7 8 9 10 11 12 13 14  const interestedIn = prompt( \u0026#34;what do you want ot know about Jonas? Choose between firstName, lastName,age or job\u0026#34; ); // dot notation 無法用expression取得屬性(物件沒有interestedIn的屬性) console.log(jonas.interestedIn); // undefined  // bracket 可使用expression取得屬性 console.log(jonas[interestedIn]); // teacher  // 當屬性存在列印出屬性值，屬性不存在時列印出\u0026#39;data not existed\u0026#39; jonas[interestedIn] ? console.log(jonas[interestedIn]) : console.log(\u0026#34;data not existed\u0026#34;);   新增/修改元素值：使用 = 賦值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // dot notation jonas.location = \u0026#39;Portugal\u0026#39; // bracket notation jonas[\u0026#39;twitter\u0026#39;] = \u0026#39;@jonas\u0026#39; jonas.age = 82 console.log(jonas) // { firstName: \u0026#39;Jonas\u0026#39;, lastName: \u0026#39;Schmedtmann\u0026#39;, age: 82, job: \u0026#39;teacher\u0026#39;, friends: [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39; ], location: \u0026#39;Portugal\u0026#39;, twitter: \u0026#39;@jonas\u0026#39; } // 使用模板字串 console.log(`${jonas.firstName}has ${jonas.friends.length}friends, and his best friends is called ${jonas.friends[0]}`) // Jonas has 3 friends, and his best friends is called a   object 方法  物件的 function，習慣叫 method  1 2 3 4 5 6 7 8 9 10 11 12 13 14  const jonas = { firstName: \u0026#34;Jonas\u0026#34;, lastName: \u0026#34;Schmedtmann\u0026#34;, birthYear: 2000, age: 28, job: \u0026#34;teacher\u0026#34;, friends: [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;], // 方法  calcAge: function (birthYear) { return 2027 - birthYear; }, }; console.log(jonas.calcAge(2000)); // 27 console.log(jonas[\u0026#34;calcAge\u0026#34;](2000)); // 27    關於 this 的使用，有助於精簡程式碼 如果需要用一樣的物件，寫 this 就不需要修改寫死的變數  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const jonas = { firstName: \u0026#34;Jona\u0026#34;, lastName: \u0026#34;Schmedtmann\u0026#34;, birthYear: 2000, age: 28, job: \u0026#34;teacher\u0026#34;, friends: [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;], hasDriverLicense: true, calcAge: function () { // return 2027 - jonas.birthYear 寫字的名字會不好維護  this.age = 2027 - this.birthYear; return this.age; // 更新值就不用每次調用都重複計算，減少浪費效能  }, };   for 迴圈  for ([初始表達式]; [條件為真時會執行{}內容]; [更新表達式]) 適合確定迴圈次數時使用(e.g. by array 的元素長度或一個數字) 可用來精簡重複執行重複的程式碼  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 假設要執行10次，從0開始到9結束 // 從 i = 0 開始，當(i \u0026lt; 9)條件為true會執行{}內的內容，完成後i++ for (let i = 0; i \u0026lt; 9; i++) { console.log(`lifting weights repetition ${i}🏋️‍♀️ `) } // lifting weights repetition 0 🏋️‍♀️ lifting weights repetition 1 🏋️‍♀️ lifting weights repetition 2 🏋️‍♀️ lifting weights repetition 3 🏋️‍♀️ lifting weights repetition 4 🏋️‍♀️ lifting weights repetition 5 🏋️‍♀️ lifting weights repetition 6 🏋️‍♀️ lifting weights repetition 7 🏋️‍♀️ lifting weights repetition 8 🏋️‍♀️ lifting weights repetition 9 🏋️‍♀️    反向迴圈 Backwards loop  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 假設要執行10次，從9開始到0結束 // 從 i = 9 開始，當(i \u0026gt; 0)條件為true會執行{}內的內容，完成後i-- for (let i = 9; i \u0026gt;= 0; i--) { console.log(`lifting weights repetition ${i}🏋️‍♀️ `) } // lifting weights repetition 9 🏋️‍♀️ lifting weights repetition 8 🏋️‍♀️ lifting weights repetition 7 🏋️‍♀️ lifting weights repetition 6 🏋️‍♀️ lifting weights repetition 5 🏋️‍♀️ lifting weights repetition 4 🏋️‍♀️ lifting weights repetition 3 🏋️‍♀️ lifting weights repetition 2 🏋️‍♀️ lifting weights repetition 1 🏋️‍♀️ lifting weights repetition 0 🏋️‍♀️    陣列使用迴圈迭代元素  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // 範例1 迭代元素資料類型並放到另一陣列type const arr = [1, 2, 3]; const type = []; for (let i = 0; i \u0026lt; arr.length; i++) { console.log(arr[i]); // filling types array  type[i] = typeof arr[i]; } console.log(type); // [ \u0026#39;number\u0026#39;, \u0026#39;number\u0026#39;, \u0026#39;number\u0026#39; ]  // 範例2 迭代元素元素值並放到另一陣列ages const years = [1991, 2003, 2022, 1972]; const ages = []; for (let i = 0; i \u0026lt; years.length; i++) { ages.push(2038 - years[i]); } //[ 47, 35, 16, 66 ]  // 範例3 使用比較簡潔的forEach語法 列印出元素 const arr = [1, 2, 3]; arr.forEach(function (element) { console.log(element); });    continue: 跳出本次迴圈，執行下個迴圈(e.g. i = 2 → i = 3)  1 2 3 4 5 6 7 8  const arrayB = [\u0026#34;stringA\u0026#34;, \u0026#34;stringB\u0026#34;, 1, 2022 - 11, true]; for (let i = 0; i \u0026lt; arrayB.length; i++) { if (typeof arrayB[i] !== \u0026#34;string\u0026#34;) continue; console.log(arrayB[i], typeof arrayB[i]); } // stringA string // stringB string    break: 終止整個迴圈  1 2 3 4 5 6  for (let i = 0; i \u0026lt; arrayB.length; i++) { if (typeof arrayB[i] === \u0026#34;number\u0026#34;) break; console.log(arrayB[i], typeof arrayB[i]); } // stringA string // stringB string    巢狀迴圈  1 2 3 4 5 6  for (let i = 0; i \u0026lt; 4; i++) { console.log(`-----starting excercise ${i}`); for (let j = 1; j \u0026lt; 3; j++) { console.log(`-----lifting ${j}time🏋️‍♀️`); } }   while Loop  while (condition) 當條件為真，則會一直執行{} 適合不確定迴圈次數時使用(e.g. Math.random 的亂數)  1 2 3 4  while (i \u0026lt; 10) { text += \u0026#34;The number is \u0026#34; + i; i++; }    隨機 1-6 的骰子，骰到 6 才會停止  1 2 3 4 5 6 7 8 9 10  let dice = Math.floor(Math.random() * 6 + 1); // 隨機產生1~6的數字  while (dice !== 6) { console.log(`Your rolled a ${dice}`); dice = Math.floor(Math.random() * 6) + 1; if (dice === 6) console.log(`Loop is about to end...`); } // Math.floor() 回傳小於等於所給數字的最大整數。(正數時等於無條件捨去，負數時等於無條件進位) // Math.random() 回傳一個偽隨機小數(pseudo-random) 介於0到1之間(包含0，不包含1)   ＊以上是 JavaScript 的基礎複習，如果喜歡的話還可以繼續往下看唷。 JavaScript 進階函式知識｜ The Complete JavaScript Course\n","date":"2021-12-31T00:00:00+08:00","image":"https://bacnotes.github.io/p/javascript-fundamentals-part2/javascript_hu206ed96a14226138f3215dbd4aa48c79_350158_120x120_fill_box_smart1_3.png","permalink":"https://bacnotes.github.io/p/javascript-fundamentals-part2/","title":"JavaScript基礎知識複習(2)｜The Complete JavaScript Course｜bacnotes備份筆記"},{"content":"最近看到網路上文章有人推這堂 Udemy 的 JavaScript 課程，然後就買下來了\nThe Complete JavaScript Course - From Zero to Expert\n為什麼想上這堂課 由於整堂課有 69 小時，自己擷取的重點不一定符合所有階段的學習者，可能比較精簡 如果有看不懂的地方可以在下方留言，或建議還是來親自體驗一下這堂課\n下方也會加入一些自己過往學習JavaScript的筆記\n什麼是 ES6（ECMAScript6）？ 什麼是 ES6（ECMAScript6）？  ECMAScript 是一個規範，JavaScript 實作了這個規範 JavaScript 在 2015 年迎來了一次大更新，更新後的版本叫 ES6（ES2015），俗稱 Modern JavaScript 當你使用 Google 跟 StackOverflow 社群都找不到解答，閱讀這份文件ECMAScript也許會有助於你 debug 你可能聽過 Vue、React、Angular 這些不同的 JavaScript 套件或是框架，不過最後都會被打包成 JavaScript 在瀏覽器上運行。 隨著時代演進使用的框架可能會變，但熟悉 JavaScript 有助於未來與時俱進  ES6 新增了哪些語法  解構賦值\n\u0026ndash; 可以用精簡的語法來命名變數，可彈性修改變數名稱  1 2 3  const variable = { a: 1, b: 2, c: 3} const {a, b, c: cat} = variable //若想針對c做新變數命名為cat  console.log(a, b, cat) // 1 2 3   \u0026ndash; 可以用來定義預設值，由於我們從其他地方取用資料時可能會有預料外狀況，當沒有資料時有預設值套用比較保險\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  const restaurant = { starterMenu: [\u0026#39;Focaccia\u0026#39;, \u0026#39;Bruschetta\u0026#39;, \u0026#39;Garlic Bread\u0026#39;, \u0026#39;Caprese Salad\u0026#39;], } // 解構賦值時加入預設值[] 避免undefined const { menu = [], starterMenu: starters = [] } = restaurant console.log(menu, starters) // [] [ \u0026#39;Focaccia\u0026#39;, \u0026#39;Bruschetta\u0026#39;, \u0026#39;Garlic Bread\u0026#39;, \u0026#39;Caprese Salad\u0026#39; ]  // 函數使用預設參數 function check (a, b = 1, c = 2, d) { console.log(a, b, c, d) } check(1,3) // 1 3 2 undefined  // 物件方法使用預設參數 const restaurant = { orderDelivery: function ({ starterIndex = 1, // 預設值  mainIndex = 0, // 預設值  time = \u0026#39;00:00\u0026#39;, // 預設值  address, // 沒訂預設值  }) { console.log( `${starterIndex}, ${mainIndex}, ${time}, ${address}` ); }, }; restaurant.orderDelivery({}) // 1, 0, 00:00, undefined   \u0026ndash; 使用解構賦值不用另外宣告 temp 暫存變數，就可以互換變數值，很方便\n1 2 3 4 5 6 7 8 9 10  // 陣列範例 let [a, b] = [1, 2] [a, b] = [b, a] console.log(a, b) // 2 1 // 物件範例 let a = 1 let b = 2 const obj = {a: 11, b: 22} ({b, a} = obj) // 不能直接對block{}賦值，需要包在()中 console.log(a, b) // 22 11   \u0026ndash; 用解構賦值取出巢狀變數變得很簡單\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // 陣列範例  const nested = [1, 2, [3, 4]] const [i, ,[j, k]] = nested console.log(i, j, k) // 1 3 4  // 物件範例  const openingHours = { fri: { open: 0, // Open 24 hours  close: 24 }, }; const { fri: { open, close } } = openingHours console.log(open, close) // 0 24    Promise 語法\n\u0026ndash; 解決了 callback hell（難以維護的巢狀結構程式碼）\n\u0026ndash; ES7 有 async/await 更好讀 展開運算子\n\u0026ndash; 可以展開物件、做淺拷貝、合併陣列、把可迭代的物件（string、array、array-like、Set、Map）跟非迭代物件 objects 變成陣列，且不用新增變數  1 2 3 4 5 6  const arr = [1, 2, 3] const arrCopy = [...arr] const str = \u0026#39;Jonas\u0026#39; const letters = [...str] // [\u0026#39;J\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;]  console.log(...str) // J o n a s    其餘運算子\n\u0026ndash; 可以將陣列後方剩下的值存成一個陣列，解構賦值時好用（不會存取 skip,, 的 key 跟有出現過的 key）  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // 陣列範例 const [x, , ...y] = [13, 25, 33, 2]; console.log(x); // 13 console.log(y); // [33, 2]  // 物件範例  const restaurant = { openingHours: { thu: 12, fri: 13, sat: 12 } } const {sat, ...weekdays} = restaurant.openingHours console.log(weekdays) = {thu: 12, fri: 13}    箭頭函式\n\u0026ndash; 可以打較少的程式碼，提高程式碼可讀性\n\u0026ndash; 過往 this 值依照執行環境所有不同，不好判斷\n\u0026ndash; 而箭頭函式的 this 則是綁定定義他（而非呼叫他）的物件，看他身處在的 function scope 的 this 指向誰 \u0026ndash; 白話文：箭頭函式沒有自己的this，但可以使用父層的 this 模板字串\n\u0026ndash; 過往可以透過單引號或雙引號跟加號拼接字串，巢狀的時候需要雙引號包裹單引號(反過來則不行)\n\u0026ndash; 遇到拼接內容是 HTML 結構，換行需要加\\n，使用上麻煩閱讀上也不容易\n\u0026ndash; 想寫縮寫或所有格（e.g. I\u0026rsquo;m cool, bac\u0026rsquo;s）的英文內容可能遇到需要用跳脫字元\u0026quot;I'm\u0026quot;，而字串模板解決了上述不方便使用的問題  1 2 3 4  const yourName = \u0026#39;bacnotes\u0026#39;; const codeName = \u0026#39;JavaScript\u0026#39;; const string = `Hi I\u0026#39;m ${yourName}` And I love ${codeName}!!`;    Enhanced Object Literals\n屬性名跟本地變量名相同可以省略後面的冒號跟值 引入 class 類別\n作為 JavaScript 現有原型程式(prototype-based)繼承的語法糖 引入模組 Import and Export modules\n方便管理程式碼之間的相依性，非同步載入（過往 require 是同步語法）  JavaScript 在網頁渲染時執行位置  瀏覽器渲染過程：建立 DOM → 建立 CSSOM → 合併為 Render Tree → Layout（空間位置排版佈局） → Paint（繪製畫面，轉換成像素做呈現） 由於 JavaScript 在執行時，會停止渲染動作，阻塞 DOM 和 CSSOM 的建構過程 因此會建議把 script 放在 HTML 內容下方，也就是\u0026lt;/body\u0026gt;前  1 2 3 4  \u0026lt;body\u0026gt; ... \u0026lt;script src=\u0026#39;./script.js\u0026#39;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt;    如果為了效能想提早載入資源而希望把 script 放在\u0026lt;head\u0026gt;區塊，需要加一個defer屬性避免阻擋渲染過程（DOM 還在建立） 若使用async屬性，下載後會立刻執行但不保證順序，且請求回來後會停止解析，還是可能遇到 DOM 跟 CSSOM 還在生成，選不到元素，適合用在不會針對操作 DOM 的 script（e.g. Google Analytics）  變數命名限制  變數 variable 用來存取 value JavaScript 習慣小寫駝峰命名yourName，大寫開頭表示建構子 使用有意義的命名（e.g. firstJob、currentJob而非job1、job2） 不能用數字開頭當變數 不接受 - 符號（會當成減號) 變數內容只能包含數字、英文字、_、$ _跟$開頭的命名通常是有特別用途（e.g. 私有變數） 不能使用 Reserved keywords（e.g. new、function），但$new或_funtion是合法的 name 是 Reserved keywords，可以合法使用但可能有風險，寧願用firstName等等  error msg 與 console.log  SyntaxError: 語法結構錯誤（可能是括弧、拼字大小寫） ReferenceError: 引用錯誤（沒被定義、找不到檔案） RangeError: 超出參數範圍 TypeError: 型別錯誤 EvalError: eval()方法使用錯誤 URIError: url 錯誤 如果 console.log 結果無法在瀏覽器的 dev tools 顯示出來，點右邊齒輪確認勾選狀況(一般會是勾 default value)，可參考這篇 https://blog.csdn.net/xianyu_Padding/article/details/78013754  Data types 型別跟 Dynamic type  Number(整數/浮點數) String(文字) Boolean(true/false) Object(物件/陣列/函式) Undefined(已宣告無定義) null(空值/empty value) Symbol(ES2015) unique 且無法被改變的 value BigInt(ES2020) 大整數 非 number 可以保存的 value JavaScript 在命名變數時不用手動定義型別，同一個變數可以賦予不同型別的值 變數可能原本是數字，後面變成字串，這也是 bug 產生的風險(但現在也有 typescript XD) 確認變數型別typeof 變數 typeof 變數 得到的是固定的七種字串值:'undefined' 'object' 'boolean' 'number' 'string' 'function' 'symbol'  null v.s. undefined v.s. not defined  null 有宣告/有賦值 但是是一個空值 → 系統提示沒抓到元素 (e.g. array 當中 key 存在但值是空的) undefined 有宣告/沒賦值 → 系統提示沒有賦值 not defined 沒宣告/沒賦值 → 系統提示沒有宣告  宣告變數方式 let、const、var 從 ES6 開始有了const跟let兩種新的呼叫方式\n並且最小的區塊切分從function變成 block{}，避免變數污染的發生\n  let 跟 const 的差異\n\u0026ndash; let的變數隨時可以用 = 重新賦值\n\u0026ndash; const的變數無法用 = 重新賦值，適合用在常數，若為陣列或物件屬性的值還是可被改變\n\u0026ndash; const若為 primitives，不能做 var += var 的操作\n\u0026ndash; 由於值的變更有產生 bug 的風險，基本上宣告會使用const，若會重複賦值再用let\n\u0026ndash; 不會使用早期的宣告變數方式var，早期宣告變數方法只有var搭配function把作用域鎖在函式裡面，但若放在if else等區塊語句，會讓var宣告的變數洩漏到全域，造成變數污染\n  let 跟 const 的共同處\n\u0026ndash; 同區塊上不能重複宣告\n\u0026ndash; 區塊內宣告不會洩漏到全域\n  作用域\n\u0026ndash; var在主程式區是全域變數，在function內是區域變數\n\u0026ndash; 在 block 區塊語句（if、else、for、while 等）裡面用 var 宣告的變數，會洩漏到全域中，造成區域變數覆蓋全域變數\n  絕對不要直接命名而不使用let const var\n\u0026ndash; 像是job = 'code'\n\u0026ndash; 沒有 scope，會變成全域變數，而且不在控管下，會造成記憶體管理問題\n  算數運算子 Arithmetic Operator  + = * / ** % ++ -- 加減乘除 指數 取餘數 遞增 遞減 x++ 跟 ++x 有執行順序的差別，前者先列印結果再相加，後者先相加再列印結果 運算子還可以用做合併字串 字串1+ ' '+ 字串2，但現在合併字串多用 template literal  指派運算子 Assignment operators  = += -= *= /= %= 將等號右邊的值拷貝給左邊的變數資料  比較運算子 Comparison operators  == === != !== \u0026gt; \u0026gt;= \u0026lt; \u0026lt;= 可以用來把判斷的結果存在變數  1 2  console.log(age \u0026gt;= 18); // true 判斷用的參數 const isFullAge = age \u0026gt;= 18;   Operator precedence 運算子優先順序  MDN可以查詢，不用背有個概念即可 如果搞不懂順序，用()把確定要先執行的段落包起來，權重最高  1 2 3 4 5 6  () 21 * / 14 + - 13 \u0026gt; \u0026lt; 比較 11 \u0026amp;\u0026amp; 6 || 5    解釋了為何程式可以正確執行類似有許多運算子卻不會誤判執行順序  1 2 3 4  const now = 2039; const ageJonas = now - 1991; const ageSarah = now - 2003; console.log(now - 1991 \u0026gt; now - 2003); // true    = 執行順序右到左  1 2 3 4  let x, y x = y = 25 - 10 - 5 console.log(x, y) // 10 10 假設是左到右 x＝y時 y會是undefined 所以必須是右到左   顯性轉型 Type Conversion  String() 可以將 null 和 undefined 轉換為字串 toString() 可以將所有資料都轉換為字串\n但是要排除 null 和 undefined（TypeError: Cannot read property \u0026rsquo;toString\u0026rsquo; ） toString(value, radix) 可以轉 2 或 8 或 10 或 16 進位字串 JSON.stringify()轉成 JSON 字串\u0026quot;\u0026quot; parseInt(string, radix) 字串轉成數字，若第一個字符無法轉換為數字回傳 NaN Number() 字串轉成數字，undefined 回傳 NaN，null 回傳 0，true 回傳 1，false 回傳 0 Boolean() 如果沒傳值，或者是 0、-0、null、false、NaN、undefined、空字串會轉成 Boolean  隱性轉型 Coercion 運算子  - * /會轉成數字'23' - '10' - 3 // 10 +會轉成字串'23' + '10' // 2310 綜合 10 - 3 - 3 + '1' // 41 == === != !==  也會，可以看下方的嚴格的等號 v.s. 寬鬆的等號說明  if () 跟!  if (變數) 在 if 括弧裡的變數都會強制轉為 Boolean 程式沒寫好可能回傳 null、undefined、NaN 等，若當作條件判斷變成 false 容易造成判斷式錯誤，需要注意。  1 2 3 4 5 6  // 運算前確認型別 if (typeof a === typeof b) { console.log(a + b) } else { console.log(\u0026#39;need to check problem\u0026#39;) }    !(變數)也會讓變數強制轉型  1 2 3 4 5 6 7  !\u0026#39;Hello\u0026#39;; // false !0; // true !{}; // false !null; // true !undefined; // true !NaN; // true !\u0026#39;\u0026#39;; // true   Truthy \u0026amp; Falsy values  Falsy 包含： null、undefined、0、空字串、NaN(不等於自己)、false Big Int 0n 也是 Falsy -1是 true，{}是 true 以下為 Falsy 值導致的錯誤設計範例（設計流程時需注意 falsy）  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 狀況1 let height; if (height) { console.log(\u0026#39;defined\u0026#39;); } else { console.log(\u0026#39;not defined\u0026#39;); } // not defined  // 狀況2 let height = 0; if (height) { console.log(\u0026#39;defined\u0026#39;); } else { console.log(\u0026#39;not defined\u0026#39;); } // not defined 雖然有define為0 但因為0是falsy 所以顯示還是not defined // 此為設計錯誤導致顯示出非預期的結果   嚴格的等號=== v.s. 寬鬆的等號 ==  使用寬鬆的==，會發生會強制轉型，字串跟數字會相等 嚴格的等號會檢查資料型別，不會強制轉型 寬鬆的等號容易產生 bug，所以只會使用===跟!== \u0026quot;0\u0026quot; == false // true (\u0026ldquo;0\u0026quot;轉成數字 0，false 轉成 0)  有興趣可看這份MDN 一般相等比較表\n＊[]會先由toString()強制轉型為字串，再強制轉型為數字\nAND OR ! 邏輯運算子 用於 if 條件增加判斷  \u0026amp;\u0026amp; (AND)所有條件為 true 才會是 true || (OR)有一個條件是 true 就是 true  1 2 3 4 5 6  當a is false b is true !a // true a \u0026amp;\u0026amp; b // false a || b // true !a \u0026amp;\u0026amp; b // true a || !b // false   用於 short-circuiting  可以做為 if 條件判斷的 argument，要執行哪一段程式 也可以套用\u0026amp;\u0026amp;或||的邏輯，為變數賦值，讓程式碼更精簡 \u0026amp;\u0026amp; 可以檢查變數是否為true，true時才會執行後面的程式碼 || 可以當作處理例外情況，當左邊變數有問題，使用右邊預設值  1 2 3 4 5 6 7 8 9 10 11  // 不限資料型態 const a = var1 \u0026amp;\u0026amp; var2 (當左邊變數為true，才套用右邊的值，若為false會套用左邊值) console.log(3 \u0026amp;\u0026amp; \u0026#39;cat\u0026#39;) // \u0026#39;cat\u0026#39; console.log(0 \u0026amp;\u0026amp; null) // 0 console.log(\u0026#39;\u0026#39; \u0026amp;\u0026amp; 0) // \u0026#39;\u0026#39;  const a = var1 || var2 (當左邊變數為false，才套用右邊的值，若為true會套用左邊值) console.log(3 || \u0026#39;cat\u0026#39;) // 3 console.log(\u0026#39;\u0026#39; || null) // null console.log(undefined || 0 || \u0026#39;\u0026#39; || \u0026#39;hi\u0026#39; || 23) // \u0026#39;hi\u0026#39;   ?? Nullish Coalescing  當 null 或 undefined 才會回傳 (0 或\u0026rsquo;\u0026lsquo;不會)  1 2 3 4 5  const guests = restaurant.numGuests || 10 console.log(guests) // 10 // null or undefined const guestsCorrect = restaurant.numGuests ?? 10 console.log(guestsCorrect) // 10   表達式 statements v.s. 陳述式 expressions  表達式：會回傳結果\ne.g. 純值、變數、運算子、執行函式、正規表達式、函式表達式… 陳述式：會執行一些程式碼，可能是幾個單詞或是片段（不會是單一個字母），不會回傳結果\ne.g. 宣告（var、function）、流程控制（block、if…else）、迴圈（for、while）、其它（import, export）  流程判斷  if else  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 比較運算子來設定條件，可以搭配\u0026amp;\u0026amp; || !邏輯運算子設定更細緻的判斷 const accountName = prompt(\u0026#39;your accountName: 8 ~ 20 characters\u0026#39;); if (accountName \u0026gt; 8 \u0026amp;\u0026amp; accountName \u0026lt; 20) { console.log(\u0026#39;correct account length\u0026#39;); } else { // 不符合條件，提示使用者檢查帳號長度  console.log(\u0026#39;please check your account length\u0026#39;); } // 有三組以上條件，中間的條件會用else if標示，最後才是else if (a \u0026gt; 10) { console.log(\u0026#39;bigger than 10\u0026#39;); } else if (a === 10) { console.log(\u0026#39;equal to 10\u0026#39;); } else { console.log(\u0026#39;smaller than 10\u0026#39;); }    Ternary Operator（條件運算子）  1 2 3 4 5 6 7  // condition ? exprIfTrue : exprIfFalse const age = 20; const drink = age \u0026gt;= 18 ? \u0026#39;wine\u0026#39; : \u0026#39;water\u0026#39;; console.log(drink); // wine  // expression也可以放到模板字串 console.log(`I can drink ${age \u0026gt;= 18 ? \u0026#39;wine\u0026#39; : \u0026#39;water\u0026#39;}`); // I can drink wine    switch（比較少用，看情況還是可以使用）  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const time = \u0026#39;morning\u0026#39;; switch (time) { case \u0026#39;morning\u0026#39;: console.log(\u0026#39;go to school\u0026#39;); break; case \u0026#39;noon\u0026#39;: console.log(\u0026#39;eat lunch\u0026#39;); break; case \u0026#39;night\u0026#39;: console.log(\u0026#39;sleep\u0026#39;); break; default: console.log(\u0026#39;nothing\u0026#39;); }   JavaScript 小歷史 1 2 3 4 5 6 7  1995 Brendan Eich10天內創造了第一版JavaScript叫 mocha 1996 LiveScript → JavaScript 改名字希望吸引Java開發者，但無關乎Java這個程式語言 MS發布IE，從NetScape copyJavaScript叫JScript 擔心侵權改名，但還是很像的東西 為了長遠發展，需要標準化，於是提交給ECMA獨立機構 1997 ECMAscript ES1發布，大家使用一樣的標準跟規範開發 2009 ES5/ES2016(ECMAScript5) 有一些新feature 2015 ES6/ES2017(ECMAScript6) 新紀元   JavaScript 和瀏覽器的相容性  Backward compatibility: ES1 語法在現代瀏覽器還是相容的 Forwards compatibility: 舊版本 IE8 瀏覽器不理解新版本 JavaScript 的規範\n我們可以透過更新瀏覽器避免不相容 ES5: fully supported in all browsers IE9(2011) ES6 → ES2021: well supported in all modern browsers, not in older ones.\ncan use most features in production with transpiling and polyfilling 所以會使用 BABEL ES2022: ESNext future versions\ncan use some features in production with transpiling and polyfilling 先學 Modern JavaScript 但還是需要知道過往 JavaScript 運作方式\ne.g. const let v.s. var\ne.g. function construction v.s ES6 Class 關於Polyfills and transpilers  恭喜你看完這一篇 JavaScript 基礎知識複習(1)，休息一下再往下一篇前進吧！\nJavaScript 基礎知識複習(2)\n＊文章內容有錯誤的地方，都歡迎討論與指正 ＊以上是 JavaScript 的基礎介紹，未來還會撰寫其他進階的文章。\n","date":"2021-12-29T00:00:00+08:00","image":"https://bacnotes.github.io/p/javascript-fundamentals-part1/javascript_hu206ed96a14226138f3215dbd4aa48c79_350158_120x120_fill_box_smart1_3.png","permalink":"https://bacnotes.github.io/p/javascript-fundamentals-part1/","title":"JavaScript基礎知識複習(1)｜The Complete JavaScript Course｜bacnotes備份筆記"},{"content":"什麼是 Google Analytics \u0026amp; Google Search Console Google Analytics：分析流量來源與站內行為表現  可以看進站管道分布，包含直接流量、自然搜尋、社群網站、其他網站連結導入或是來自廣告等等 可以了解到達網頁(landing page)集中在哪些頁面 觀看使用者類型與進站後的使用者行為，像是停留時間，觀看了幾頁，跟離開頁面 確認是否跟原本規劃的網站體驗流程相似，或是在哪些頁面容易流失客戶 電商網站可以設定電子商務觀看電子商務報表(轉換率/收益/客單價等)，由於我們只是單純的部落格，未來如果有機會的話再來介紹  Google Search Console：分析自然搜尋流量與站外排名  可以從成效報表觀察流量的變化，曝光 \u0026gt; 點擊 \u0026gt; 點閱率 \u0026gt; 排序 分析有哪些關鍵字跟頁面帶來流量 分析自然流量的來源是來自哪些地方 定期提交 sitemap 幫助網址被收錄，或是移除想拿掉的網址（sitemap 記得也要同步拿掉) 確認網站還有哪一些待改進的體驗  安裝 Google Analytics  登入你要使用 GA 的 Google 帳號 進到 https://analytics.google.com/ 填寫帳戶名稱，資料共用設定這部分可以自行判斷 填寫資源名稱 填寫商家資訊 接受 Google Analytics(分析)服務條款合約 選擇平台(我是部落格所以選網頁) 填寫網站串流網址跟名稱 會得到一個評估 ID G-xxxxxxxx (舊版為UA開頭) 把評估 ID 貼到 config 檔案即可  GA4 將跨裝置的使用者行為串接起來，相較過去著重在停留時間、頁數，改以事件為核心的分析主體，對於數據的解讀方便許多\n使用 GA4 的即時報表確認資料是否已開始傳入\n或透過GTM/GA debugger套件確認是否有反應\nok 看起來成功囉！記得也檢查一下 404 頁面有無反應唷！\n安裝 Google search console  建議使用跟 GA 一樣的 Google 帳號 進到 https://search.google.com/search-console/welcome 選取資源類型，若跟我一樣是使用 GitHub pages 服務選右邊 填寫網址 驗證方法很多，因為剛剛已經安裝好 GA，帳號有編輯權，直接點第 3 種的 GA 驗證按鈕  ok 進到了資源頁面了！一般來說會需要等個 1 天時間跑資料\n在網站根目錄下建立 robots.txt 把 robots.txt 放在網站下的根目錄，使用hexo放在source資料夾下即可\n下方是一個常見的範例，網址填入自己的版本\n1 2 3  User-agent: * Allow: / Sitemap: https://bacnotes.github.io/sitemap.xml   ＊Google 支援所有格式的標準 Sitemap 通訊協定，但目前不支援在 Sitemap 中使用  屬性\n到 Google Search Console 提交 sitemap 生成靜態網頁的時候會自動產出 sitemap 檔案\n網址是\u0026lt;你的網站名\u0026gt;/sitemap.xml e.g. https://bacnotes.github.io/sitemap.xml\n提交位置在 Google Search Console 索引區塊的 Sitemap\n輸入你的 sitemap 網址即可，一般是 sitemap.xml\n使用 Google Search Console 的「要求建立索引」 發布文章後，會希望可以盡早被爬蟲爬取建立索引，hexo平台會自動生成sitemap 檔，很方便操作更新sitemap，但公司的行銷人員，可能不一定可以迅速取得工程師的即時協助\n這時候可以點 Google Search Console 上方的輸入框，輸入文章網址，按下 enter就可以建立排程請爬蟲來看看這個網址\n(也可以點側邊欄成效下方的網址審查，也會 focus 到這個框框)\n等待一段時間跑出結果\n點下方的「要求建立索引」，就會跟 Google 提交建立索引的要求且進入排程，爬蟲就會依照排程來看你剛剛提交的網址了\n跟 Google 提交 Sitemap 完之後，其他的搜尋引擎也需要嗎？ 我們用Statcounter看看目前搜尋引擎各家的市佔率\nStatcounter 是一個網站流量分析工具，主要提供網頁瀏覽器跟搜尋引擎的使用分佈的訊息\n以下是上個月各家搜尋引擎全球市占率，Google 有 91.4%的市佔率，而其他家(bing, Baidu, Yahoo!)市占率大約都在個位數\n由於我們的使用者主要是在台灣，把條件設定成台灣\nGoogle 還是一樣市占率最高，且比剛剛全球數據的市佔率還高，為 9 成 4\n看起來我們之後 SEO 還是專心於 Google，畢竟台灣大部分的使用者都使用 Google 搜尋\n最後，爬蟲大大快來我家吧\n","date":"2021-12-28T00:00:00+08:00","image":"https://bacnotes.github.io/p/google-seo-tools/myriam-jessier-VCtI-0qlVgA-unsplash_hu4b44d326edd3135b9f13e80e90e771b0_550794_120x120_fill_q75_box_smart1.jpg","permalink":"https://bacnotes.github.io/p/google-seo-tools/","title":"安裝SEO分析工具Google Analytics跟Google Search Console｜bacnotes備份筆記"},{"content":"關於部署的工具有很多，身為工程師的你一定聽過GitHub!\n為什麼用GitHub部署  因為免費(o) 因為用起來很親切，簡單又方便(o) 因為部署到生效的過程很快速(o) 因為部落格後面有GitHub域名很潮(x)  GitHub Pages是GitHub提供的免費靜態網頁託管服務\n雖然是免費，不過用起來體驗也很好\n那SEO表現呢? 這時候可以用ahrefs快速確認一下\nGitHub在網站權重跟外部連結數都有很好的表現\n拿medium來當對手的話呢\nGitHub 加十分 🙌\n跟另一個也是很常拿來建立部落格的平台，且SEO客製化程度較高的wordpress相比呢 GitHub 再加十分 🙌\n看起來是不錯的選擇唷！那麼來實作看看吧！\nGitHub Pages部署靜態網頁 GitHub Pages有兩種\n 專案型網址 https://username.github.io/reponame\n（一個帳號可以有很多個repo專案，每個專案都可以有一個靜態網頁） 帳號型網址 https://username.github.io\n（一個使用者帳號只會有一個，可以拿來經營個人網站）  專案型網址適合把Hugo這個部落格專案，備份到GitHub上(非部署)，執行步驟如下\n 新增一個GitHub Repo，Repo名自訂 cd到專案資料夾，輸入git init git branch -m main git add . git commit -m 'init project' # git msg 內容可自訂 git remote add origin \u0026lt;自訂repo網址\u0026gt;\n#如果電腦只有使用1組GitHub帳號，直接貼repo網址\n#如果電腦本身有多組GitHub帳號，確認@host名:git網址結構是否有調整正確，可回到上一篇確認  這樣一來電腦裡的Hugo專案不見也不用擔心囉～之後還可以git clone下來\n作為部署部落格本身使用，執行步驟如下\n 新增一個GitHub Repo，Repo名為username.github.io(須完全符合) 在專案資料夾路徑下輸入 hugo，會生成靜態頁面檔案於public資料夾 cd public git init git branch -m main git add . git config --local user.name aaa #不需要多組帳號管理可跳過 git config --local user.email aaa@email.com #不需要多組帳號管理可跳過 git commit -m 'deploy' # git msg 內容可自訂 git remote add origin \u0026lt;repo網址\u0026gt;\n#注意事項同專案型網址 git push -f --set-upstream origin main # 強制覆蓋之前的紀錄  好的，若依照順序有執行成功，可以開始寫腳本檔案了!\n自動化部屬腳本deploy.sh  在專案資料夾的根目錄建立deploy.sh檔，貼上下方文字 repo網址記得替換成自己的，option依照自己狀況調整即可  1 2 3 4 5 6 7 8 9 10 11 12 13  hugo cd public git init git branch -m main git add . git config --local user.name aaa #不需要多組帳號管理可跳過 git config --local user.email aaa@email.com #不需要多組帳號管理可跳過 git commit -m \u0026#39;deploy\u0026#39; git remote add origin \u0026lt;repo網址\u0026gt; # if you have .ssh/config setting, remember to replace with right structure git push -f -u origin main cd -   參考文章: 部署Hugo個人網頁至GitHub\n","date":"2021-12-26T00:00:00Z","image":"https://bacnotes.github.io/p/github-deploy-hugo/mohammad-rahmani-q1p2DrLBtko-unsplash_hu34ce0191b88a37780da4e3c1a288bda4_3436174_120x120_fill_q75_box_smart1.jpg","permalink":"https://bacnotes.github.io/p/github-deploy-hugo/","title":"只要3秒，使用GitHub一鍵部署你的Hugo部落格｜bacnotes備份筆記"},{"content":"Um\u0026hellip;在部署前卡到了 Github 多組帳號權限的問題\n如果你的電腦只有使用 1 組 GitHub 帳號，可以點下方連結直接到下一篇\n只要 3 秒，使用 GitHub 一鍵部署你的 Hugo 部落格\n為什麼要用一台電腦使用多組 GitHub 帳號 當遠距工作變成時代趨勢，工作時勢必會有 1 組公司用的 GitHub 帳號(或 GitLab 或…其他的雲端協作平台)，但自己在寫 side project 也會用到 1 組 GitHub 帳號，那麼辦第 2 組 GitHub 帳號就好了吧（就跟 google 帳號一樣？\n但你在 GitHub 的新帳號開了一個 Repo，在編輯器的 terminal 依序輸入下方指令\n1 2 3 4 5 6  git init git add . git commit -m \u0026#39;some msg\u0026#39; git branch -M main git remote add origin \u0026#39;your repo\u0026#39; git push -u origin main   就會發現在最後一步跳出這個訊息\n ERROR: Permission to userB/repo.git denied to userA fatal: 無法讀取遠端版本庫。\n 要 commit 的時候，被最初註冊的 userA 帳號 deny\nUm\u0026hellip;啊！\n之前的帳號有設定一組對應的 SSH key 讓 GitHub 驗證身份，應該是 SSH key 的問題吧？ 有 2 組帳號，生 2 組 key 應該就沒問題了吧！欸不對，我的 terminal 在 git push 的時候，怎麼知道哪組帳號對應哪個 SSH key…\n上網查了一下相關文章，發現可以寫一個 config 來讓不同帳號對應各自的 key\n管理多組 SSH key 流程如下 aaa 為範例，可自由代入你的帳號\n 產生 SSH key ssh-keygen -t rsa -C \u0026quot;aaa@example.com\u0026quot; 決定要儲存的檔名(路徑) 在 Enter file in which to save the key (/Users/XXX/.ssh/id_rsa):\n後方填入 /Users/aaa/.ssh/id_rsa_aaa\n*如果沒有新的命名，就會覆蓋原本的 id_rsa Enter passphrase(看個人，可以直接 enter 不設定密碼) Enter same passphrase again(如果有設定要再輸入一次，沒有就直接 enter) 把對應的公鑰(id_rsa_aaa.pub 裡面的文字)新增到 GitHub 的 SSH key，官方圖文教學 在.ssh 目錄下，touch 一個 config(不用副檔名)  1 2 3 4 5  Host gh.aaa HostName github.com User aaa PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_aaa   把 key 加入管理 ssh-add ~/.ssh/id_rsa_aaa 嘗試連線看看對應 host 是否有生效ssh -T git@gh.aaa  Hi aaa! You\u0026rsquo;ve successfully authenticated, but GitHub does not provide shell access.\n   看到上方訊息表示有成功連線囉！\n第 2 個帳號照著上方步驟寫在同個 config 檔案即可\n1 2 3 4 5 6 7 8 9 10 11  Host gh.aaa HostName github.com User aaa PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_aaa Host gh.bbb HostName github.com User bbb PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_bbb   注意：經過上面的設定檔後，repo 的位置會從預定的 git@github.com:ooo/ooo.git 變成 git@gh.aaa:ooo/ooo.git\n後續在新增 repo 連結時需注意，不然可能吃不到 config 設定檔唷\n參考文章: [Git] 多個 SSH Key 與帳號的設定(Mac)\n","date":"2021-12-25T00:00:00Z","image":"https://bacnotes.github.io/p/github-ssh-key/maria-ziegler-jJnZg7vBfMs-unsplash_hu3d03a01dcc18bc5be0e67db3d8d209a6_39928_120x120_fill_q75_box_smart1.jpeg","permalink":"https://bacnotes.github.io/p/github-ssh-key/","title":"關於SSH key與多組GitHub帳號切換｜bacnotes備份筆記"},{"content":"為什麼工程師要寫部落格 身為一個專業的工程師，你也許會需要\n 一台筆電(o) 持續學習(o) 跟容量大的腦袋來備份知識(x)  Um\u0026hellip;工程師的世界永遠有追不完的技術，自知腦容量沒有這麼大，記錄成部落格文字來比較可靠，而且\n 寫成部落格也有機會跟別人交流，也許還會有高手可以切磋(!\n 部落格架站選擇 - Jekyll, Hexo, Hugo, Gatsby 除了 hugo 外還有很多人氣的靜態網站生成器 Jekyll (Ruby) / Hexo (JavaScript) / Gatsby (React)等，也有很多比較文\n [Day06] Jekyll vs Hexo vs Hugo Hexo Hugo Vuepress Gatsby 静态网站生成器的选择  Hugo號稱部屬最快的框架，用 Go 語言寫的，也許未來有時間會想學學看這個 google 工程師團隊開發的語言，而且時間就是金錢啊！就先選用這個了！\n安裝 Hugo 如果是用 Mac，直接 homebrew 下載  如果沒用過 homebrew 套件管理軟體可以先下載homebrew brew install hugo 用 hugo version or hugo help 來檢查是否有新增成功  如果是用 Windows，可以使用 Chocolatey 下載   沒用過 ChocoLatey 套件管理工具的話，可以先參考這篇安裝說明\n用指令安裝程式\u0026ndash;Chocolatey\n  下載完後來安裝 Hugo\n  基礎版是choco install hugo -confirm\n  Sass/SCSS version 是 choco install hugo-extended -confirm\n  看之後部落格選擇的主題，會使用到 Sass/SCSS 語法的就選後者\n 依照官方影片說明，在 C:\\下方新增 Hugo 資料夾    Hugo 資料夾下新增 Sites 跟 bin 資料夾(Sites 是專案資料夾，bin 是儲存執行檔案用) 到Hugo Releases 下載安裝檔，解壓縮完的檔案丟到 bin 資料夾 新增 window 開發環境變數，在變數 PATH 下新增一個值叫C:\\Hugo\\bin，讓全域都可以執行 hugo 命令 到其他資料夾用 hugo version or hugo help 來檢查是否有新增成功  新增網站的專案資料夾 ＊以下用example.com為部落格網址作為範例，這邊根據自己的網站名做修改即可(mac 跟 windows 流程大同小異)\n window 的使用者 cd 到C:\\Hugo\\Sites\u0026gt;，mac 的使用者 cd 到你設定的專案資料夾 執行hugo new site example.com  選擇與安裝喜歡的主題  到Hugo Themes找喜歡的主題 我選用的是 hugo-theme-stack \u0026ndash; git clone你喜歡的主題到theme資料夾\n\u0026ndash; 一開始我們的部落格裡面沒有內容，hugo-theme-stack 有提供範例，exampleSite資料夾，我們用這個來覆蓋專案資料夾看看實際部落格效果 \u0026ndash; 在 example.com 網站資料夾下執行 hugo server\n\u0026ndash; 網址列查看http://localhost:1313  哇真的出現了!好感人啊！ 現在只有自己可以看到，下一篇會介紹如何使用 GitHub 來部署我們的部落格\n只要 3 秒，使用 GitHub 一鍵部署你的 Hugo 部落格\n參考文章: [Day07] Let\u0026rsquo;s Hugo!\n","date":"2021-12-23T00:00:00Z","image":"https://bacnotes.github.io/p/hugo-blog/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://bacnotes.github.io/p/hugo-blog/","title":"工程師的技術部落格要怎麼架？使用Hugo!｜bacnotes備份筆記"}]