[{"content":"數字檢查跟數字轉換 JavaScript 數字都是浮點數 1  console.log(23 === 23.0); // true   數字是 Base64 的 2 進位編碼 1 2  console.log(0.1 + 0.2); // 0.30000000000000004 console.log(0.1 + 0.2 === 0.3); // false   字串轉數字 Number 1  console.log(Number(\u0026#34;23\u0026#34;)); // 23   + 運算子    是 Number() 的簡寫    1  console.log(+\u0026#34;23\u0026#34;); // 23   解析數字 Number.parseInt(string[, radix])  此方法跟全局 parseInt()一樣 第一個參數為待轉成數字的字串。若 string 參數類型不是字串的話，會先將其轉成字串（相當於先執行 ToString 再執行 parseInt）空白值會被忽略，如果遇到不能轉為數字的字符，就不再進行下去，回傳已經轉好的部分，若無法轉為數自回傳 NaN 第二個參數為進位數，從 2 到 36，能代表該進位系統的數字。如果沒有指定 radix 的話，給出的結果會按照實做不同而異，通常預設值不是 10 進位，強烈建議填寫好進位參數避免非預期 bug  1 2 3 4 5 6 7 8 9 10 11  // parsing Number.parseInt === parseInt; // true  console.log(Number.parseInt(\u0026#34;30px\u0026#34;, 10)); // 30  // 開頭不能為字母 console.log(Number.parseInt(\u0026#34;e23\u0026#34;, 10)); // NaN // 整數 console.log(Number.parseInt(\u0026#34;2.5rem\u0026#34;)); // 2 // 浮點數 console.log(Number.parseFloat(\u0026#34;2.5rem\u0026#34;)); // 2.5   NaN 系列 何時出現 NaN (Not a Number)  NaN 是一個 Number 型態但強制轉成數字後無法用任何數字表現的結果 NaN !== NaN // true 回傳未定義 not defined 超出範圍 運算式有一個參數是 NaN  isNaN(value)  過往判斷 NaN 習慣用 isNaN(因為 NaN !== NaN)，但有些缺點，遇到非數字會強制轉型，容易出現非預期的狀況  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 正常使用狀況下 isNaN(NaN); // true 是NaN 回傳true isNaN(undefined); // true 是NaN 回傳true isNaN({}); // true 不是數字 回傳true isNaN(\u0026#34;37,5\u0026#34;); // true 不是數字 回傳true isNaN(37); // false 是數字 回傳false  // 布林值強制轉型 isNaN(true); // false 不是數字 強制轉1 變成數字 isNaN(null); // false 不是數字 強制轉0 變成數字  // 字串強制轉型 isNaN(\u0026#34;37\u0026#34;); // false 不是數字 強制轉37 為數字 isNaN(\u0026#34;37.37\u0026#34;); // false 不是數字 強制轉37.37 為數字 isNaN(\u0026#34;\u0026#34;); // false: 轉0  // 數字混合字串 isNaN(\u0026#34;123ABC\u0026#34;); // true: Number(\u0026#34;123ABC\u0026#34;)無法轉成功，為 NaN; 若parseInt(\u0026#34;123ABC\u0026#34;)會轉 123,   Number.isNaN(value)  檢查是否為 NaN，回傳布林值 注意不是非數字回傳 true，而是 NaN 回傳 true 使用 Number.isNaN 回傳結果則單純續多  1 2 3 4  console.log(Number.isNaN(20)); // false 不是NaN console.log(Number.isNaN(\u0026#34;20\u0026#34;)); // false 不是NaN console.log(Number.isNaN(+\u0026#34;20x\u0026#34;)); // true 表達式+\u0026#39;20x\u0026#39;為NaN console.log(Number.isNaN(23 / 0)); // false Infinity不是NaN   Number.isFinite(value)  適合確認是否為數字  1 2 3 4  console.log(Number.isFinite(20)); // true console.log(Number.isFinite(\u0026#34;20\u0026#34;)); // false console.log(Number.isFinite(+\u0026#34;20x\u0026#34;)); // false console.log(Number.isFinite(23 / 0)); // false   Number.isInteger(value)  適合確認是否為整數  1 2 3 4  console.log(Number.isInteger(20)); // true console.log(Number.isInteger(20.0)); // true console.log(Number.isInteger(20.5)); // false console.log(Number.isInteger(23 / 0)); // false   Math 運算系列跟取整數 開根號、平方 1 2 3 4  console.log(Math.sqrt(25)); // 5 console.log(5 ** 2); // 25 console.log(25 ** (1 / 2)); // 5 1 / 2需要括號 不然會算成12.5 console.log(8 ** (1 / 3));   找最大值、最小值 1 2 3  console.log(Math.max(5, 18, 23, 11, 2)); // 23 console.log(Math.max(5, 18, \u0026#34;23\u0026#34;, 11, 2)); // \u0026#39;23\u0026#39;也會強制轉型 23 console.log(Math.max(5, 18, \u0026#34;23px\u0026#34;, 11, 2)); // 轉失敗 NaN   圓周率 1 2  // Math.PI 為3.14159... console.log(Math.PI * Number.parseFloat(\u0026#34;10px\u0026#34;) ** 2); //314.159...   Math.random() 隨機產生 0~1 的小數，不包含 1 1 2 3 4 5 6 7  console.log(Math.random()); // 隨機產生 0... - 5...的小數 console.log(Math.random() * 6); // 隨機產生 1 - 6 的整數 console.log(Math.floor(Math.random() * 6 + 1));   Math.trunc() 去掉小數 1 2 3 4 5 6 7  // 隨機產生1~6的整數 骰子 console.log(Math.trunc(Math.random() * 6) + 1); // 產生一個介於min與max的隨機數(包含min max) function getRandomIntInclusive(min, max) { return Math.trunc(Math.random() * (max - min + 1)) + min; }   Math.round() 四捨五入 1 2  console.log(Math.round(23.3)); // 23 console.log(Math.round(23.9)); // 24   Math.ceil() 無條件往更大的值取整數 1 2 3 4  console.log(Math.ceil(23.3)); // 24 console.log(Math.ceil(23.9)); // 24 console.log(Math.ceil(-23.3)); // -23 console.log(Math.ceil(-23.9)); // -23   Math.floor() 無條件往更小的值取整數  正數時跟 Math.trunc() 結果一樣，負數則不同  1 2 3 4 5 6 7 8  console.log(Math.floor(23.3)); // 23 console.log(Math.floor(\u0026#34;23.9\u0026#34;)); // 23 console.log(Math.floor(-23.3)); // -24  // 正數跟Math.trunc() 相同 console.log(Math.trunc(23.3)); // 23 // 負數跟Math.trunc() 不同 console.log(Math.trunc(-23.3)); // -23   Number.prototype.toFixed()  使用定點小數表示法（fixed-point notation）來格式化數字。  1 2 3 4 5  // Rounding decimals console.log((2.7).toFixed(0)); console.log((2.7).toFixed(3)); console.log((2.345).toFixed(2)); console.log(+(2.345).toFixed(2));   餘數運算子 % 表格變色 1 2 3 4 5 6 7 8 9 10 11  const isEven = n =\u0026gt; n % 2 === 0 isEven(2) // true isEven(3) // false  // even cols change to blue background labelBalance.addEventListener(\u0026#39;click\u0026#39;, function() { [...document.querySelectorAll(\u0026#39;.movements__row\u0026#39;)].forEach(function, (row, i) { if (isEven(i) row.style.backgroundColor = \u0026#39;marined\u0026#39; }) })   Numeric Separators 數字分隔符  一樣的值，透過底線分割提高可讀性 Number()無法解析含有數字分隔的的數字，這個只適合用於手動建立的參數，而非 API 回傳字串類型的數字  1 2 3 4  const diameter1 = 2082432342; const diameter2 = 2_082_432_342; console.log(diameter1); // 2082432342 console.log(diameter2); // 2082432342    小數點  1 2  const fee = 15.000_3; console.log(fee); // 15.0003   BigInt  用來儲存更大的數字，因為一個數字能使用的記憶體有限 JavaScript 可以呈現的最大值是 9007199254740991，即(2 ** 53 - 1)，超過這個數字無法往上加 數字後面寫 n，或用 BigInt 包裹後會變成 BigInt  1 2 3 4  console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991 console.log(2 ** 53 - 1); // 9007199254740991 console.log(23423412312311n); // 23423412312311n console.log(BigInt(23423412312311)); // 23423412312311n   BigInt 運算  用 n 的形式無法跟其他數字相加，BigInt 只能跟 BigInt 運算 若 BitInt+d 字串，BitInt 一樣會轉成字串  1 2 3 4 5 6 7  const num = 23; const huge = 2342341231242352n; console.log(num + huge); // 數字跟BigInt相加會 error 因為不同類型 console.log(BigInt(num) + huge); // 2342341231242375n  console.log(12n / 3n); // 4n    判斷運算子\u0026gt; \u0026lt; =，用 n 的形式沒問題  1 2 3  console.log(20n \u0026gt; 15); //true console.log(20n === 20); // false console.log(20n == 20); // true   建立日期物件 Date.now()  回傳自 1970 年 1 月 1 日 00:00:00 (UTC) 到當前時間的毫秒數 Date.now() 的精度可能受到瀏覽器影響被取整數  1 2  const start = Date.now(); console.log(start); // 1647780438069   new Date()  new Date(): 沒有傳入任務參數到建構子，會依系統設定建立出代表當下時間的 Date 物件  1 2  console.log(new Date(2017, 0, 30)); // Mon Jan 30 2017 00:00:00 GMT+0800    new Date(value): value 是自世界標準時間（UTC） 1970 年 1 月 1 日 00:00:00 開始的毫秒整數值（注意：Unix timestamp是以秒而非毫秒為單位）  1 2  console.log(new Date(0)); // Thu Jan 01 1970 08:00:00 GMT+0800    new Date(dateString): 表示時間日期的字串。這個字串應該要能被 Date.parse() (en-US) 方法解析 new Date(\u0026ldquo;yyyy-mm-dd hh:mm:ss\u0026rdquo;) 符合所有瀏覽器格式  1 2 3  console.log(new Date(\u0026#34;2010/08/17 12:09:36\u0026#34;)); console.log(new Date(\u0026#34;Jan 30 2017\u0026#34;)); // Mon Jan 30 2017 00:00:00 GMT+0800    new Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]]); 傳入至少兩個參數，缺少日期的話會設為 1，其它參數則會被設定為 0。 備註：當傳入超過一個參數，且參數值超過它的合理範圍（例如：傳數值 13 到月份，或傳數值 70 給分鐘），相鄰的參數值將會被調整。例如： new Date(2013, 13, 1) 將等同於 new Date(2014, 1, 1) 都會建立代表 2014-02-01 的物件  1 2 3 4  console.log(new Date(2017, 10, 19, 14, 23, 1)); // Sun Nov 19 2017 14:23:01 GMT+0800 console.log(new Date(2017, 10)); // Wed Nov 01 2017 00:00:00 GMT+0800   取得日期物件的值  getFullYear(): 年 getMonth(): 月 getDate(): 日 getHours(): 時 getMinutes(): 分 getSeconds(): 秒  1 2 3 4 5  const future = new Date(2037, 10, 19, 14, 22); // Thu Nov 19 2037 14:22:00 GMT+0800 console.log(future.getFullYear()); // 2037 console.log(future.getMonth()); // 10 console.log(future.getDate()); // 19   修改日期物件的值  如果設定的 value 超出了合理範圍，會相對應的往前或往後推算 setFullYear(): 年 setMonth(): 月 setDate(): 日 setHours(): 時 setMinutes(): 分 setSeconds(): 秒  1 2 3 4 5 6 7  const future = new Date(2037, 10, 19, 14, 22); // Thu Nov 19 2037 14:22:00 GMT+0800 future.setFullYear(2022) future.setMonth(2)); future.setDate(3)) console.log(future) // Thu Mar 03 2022 14:22:00 GMT+0800   時間物件轉字串 .toISOString())  時區為UTC  1 2 3  const future = new Date(2037, 10, 19, 14, 22); // Thu Nov 19 2037 14:22:00 GMT+0800 console.log(future.toISOString()); // 2037-11-19T06:22:00.000Z   時間物件轉毫秒  回傳距離 1970 年 1 月 1 日 0 時 0 分 0 秒（UTC 時間）多久的毫秒數  1 2 3  const future = new Date(2037, 10, 19, 14, 22); // Thu Nov 19 2037 14:22:00 GMT+0800 console.log(future.getTime()); // 2142224520000   時間的運算  會先轉換成Time Stamp毫秒為單位  1 2 3 4 5 6  const future = Number(new Date(2037, 10, 19)) console.log(future) // 2142172800000  const calcDaysPassed = (date1, date2) =\u0026gt; Math.abs(date2 - date1) / (1000 * 60 * 60 * 24) const days = calcDaysPassed(new Date(2037, 10, 19), new Date(2037, 10, 24)) console.log(days) // 5   持續更新中\u0026hellip;\n","date":"2022-03-14T00:00:00+08:00","image":"https://bacnotes.github.io/p/math-number-date/pexels-photo-168784_hu20254ebf286f88ed55b1fa26f2cb8d47_51813_120x120_fill_q75_box_smart1.jpeg","permalink":"https://bacnotes.github.io/p/math-number-date/","title":"數字檢查轉換還有日期處理的那些小事｜bacnotes備份筆記"},{"content":"建立正規表達式物件  兩個斜線 / / new RegExp() 定值時，使用斜線的方法效能較佳 若內容會異動，匹配模式未知，用建構函式較佳  1 2 3 4  // 匹配完全符合abc的字串 const regex = /abc/; // 使用建構函式 const regex = new RegExp(\u0026#34;abc\u0026#34;);   Flag: 寫在//後面  i：不區分大小寫 m：多行，讓^$比對每一行的開頭跟結尾 g：全局(比對多個相符結果，而非只有一個，可以從尾巴找) 正規表示式有開啟 g flag，可以連續執行 exec() 逐一取得原始字串中所有的匹配字串 每次執行完 exec() 都會重設 lastIndex 為匹配字串後面接續的字元的索引位置。  1 2 3 4 5 6 7 8 9 10 11 12  var regex = /ab*/g; var str = \u0026#34;abbcdefabh\u0026#34;; var arr; while ((arr = regex.exec(str)) !== null) { var msg = \u0026#34;Found \u0026#34; + arr[0] + \u0026#34;. \u0026#34;; msg += \u0026#34;Next match starts at \u0026#34; + regex.lastIndex; console.log(msg); } // Found abb. Next match starts at 3 // Found ab. Next match starts at 9   正規表達式物件自帶方法  regex.test(測試內容) // 會回傳 true false 判斷是否匹配 regex.exec(測試內容) // 回傳陣列 匹配的全部字串/個別匹配字串/開始符合的 index 起始點/原始輸入字串  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // Match \u0026#34;quick brown\u0026#34; followed by \u0026#34;jumps\u0026#34;, ignoring characters in between // Remember \u0026#34;brown\u0026#34; and \u0026#34;jumps\u0026#34; // Ignore case const inputValue = \u0026#34;The Quick Brown Fox Jumps Over The Lazy Dog\u0026#34;; const regex = /quick\\s(brown).+?(jumps)/gi; const result = regex.exec(inputValue); console.log(result); // [ // \u0026#39;Quick Brown Fox Jumps\u0026#39;, // \u0026#39;Brown\u0026#39;, // \u0026#39;Jumps\u0026#39;, // index: 4, // input: \u0026#39;The Quick Brown Fox Jumps Over The Lazy Dog\u0026#39;, // groups: undefined // ]    這些字串方法也可以用正規表達式 search、match、replace、split 可以參考這篇字串的處理方法  特殊字元  ^：字串開頭為 (/^A/ 會匹配「An E」中的 A 不會匹配「an A」的 A) 寫在集合[]表示非 $：字串結尾為（/t$/ 會匹配「eat」中的 t 不會匹配「eater」中的 t） \\：下一個字元開始視為一般值而非運算式 \\b：字串邊界不能有英數或底線 \\B：字串邊界要有英數或底線 .：代替除了換行符號所有可能的字元（a.c 會匹配到 \u0026ldquo;aGc\u0026rdquo;, \u0026ldquo;a c\u0026rdquo;, \u0026ldquo;a_c\u0026rdquo;，但不能匹配 \u0026ldquo;a\\nc\u0026rdquo;，.ool 會匹配到 cool fool） |：或，不能放在最後面  字元代號  ()：匹配括弧中內相符字元順序（(sym)，結果可能有 sympathy、assym，sy(m|n) 會匹配 syn 或 sym） []：匹配括弧中的字元範圍，不分順序 [^]：匹配非括弧中的字元 [A-Z]：匹配大寫英文字母 [a-z]：匹配小寫英文字母 [0–9]：匹配數字 0–9，[^0-9] 匹配不含數字 0–9 red[1-3]：red1 red2 red3 都會匹配到 \\d：匹配數字 (digital) \\D：匹配非數字 \\w：匹配英數與底線，即 [A-Za-z0–9_] \\W：匹配非英數與底線，即 [^a-za-z0–9_] \\s：匹配泛空白字元，包含換行符號 tab space \\r \\n \\S：匹配非泛空白字元  匹配次數  {m}：匹配前面的運算式 m 次 {n,}：匹配前面的運算式最少 n 次 {m,n}：匹配前面的運算式 m 次到 n 次 {m,n}?：匹配前面的運算式 m 次到 n 次之間最少次的 *：至少 0 次，等於{0,}，有或無都可，匹配多次(bag01*: bag0 bag01 bag011 ) +：至少 1 次，等於 {1,}，至少要包含一個 ?：0 次或 1 次，等於{0,}，有或無都可(ha?t: ha hat)  常見 case 信箱\n1  const regex = /^\\w+([-+.\u0026#39;]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$/;   身分證\n1  const regex = /^[A-Z]{1}[1-2]{1}[0-9]{8}$/;   郵遞區號\n1  const regex = /^[1-9]\\d{4}$/;   手機\n1  const regex = /^09\\d{8}$/;   密碼要大小寫英文+數字+長度至少 8\n1  const regex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d]{8,}$/;   日期\n1 2 3 4 5 6  // 日 const regex = /(([0-2][1-9])|10|20|30|31)/; // 月 const regex = /((0[1-9])|(1[0-2]))/; // 年 const regex = /(19|20)\\d{2}/;   正規表達式測試工具 https://www.regextester.com/\n","date":"2022-03-06T00:00:00+08:00","image":"https://bacnotes.github.io/p/regular-expression/pexels-photo-7794425_hud76bb672323e27b5286a038ed903a966_45826_120x120_fill_q75_box_smart1.jpeg","permalink":"https://bacnotes.github.io/p/regular-expression/","title":"認識正規表達式RegExp (Regular Expression)｜bacnotes備份筆記"},{"content":"以下內容主要參考自 Vue JS 3 Tutorial for Beginners #10 - The Composition API\n使用 Composition API 的好處  Option API 撰寫的程式碼，資料四散在 data、methods、computed、props 等，Composition API 把變數、函式集中在 setup，方便複用邏輯，不需要為了套用到模板就要宣告在 data 或是 computed，直接丟 return 即可 提高可讀性，一個功能可能會寫在不同的 option API 區塊，閱讀上不方便，使用 Composition API 可以容易把同一個功能的程式碼整理在一起 mixin 也可以做到邏輯複用這件事，但有兩個缺點，一是被引用的 mixin 的跟引用的元件之間有隱式依賴，兩者無上下關係，你要重構元件的時候，跟 mixin 有關的東西不好改，因為改了也會影響其他有引用他的元件。 第二是裡面的變數可能會撞名，同一個元件裡面有一樣的屬性名稱，元件的變數名稱權重比 mixin 的大，會覆蓋 mixin 的，容易會產生 bug，如果這個 mixin 又是第三方套件的話\u0026hellip; 又會更難了，因為程式碼不是你寫的，你可能根本不會想到是這個問題。  Vue3 的生命週期 Vue3 的生命週期(對應在 Vue2 的生命週期名稱)\n setup(beforeCreate)：初始化 Vue 實例/事件跟生命週期 \u0026ndash; 尚無法讀取 data, computed, methods, watch/event callbacks \u0026ndash; 適合展示loading畫面，不適合fetch資料，還沒有data可以存 setup(created)：創建完實例(虛擬DOM) \u0026ndash; 設置 data, computed, methods, watch/event callbacks \u0026ndash; 尚無法讀取$el，適合 fetch 資料 onBeforeMount(beforeMount)：尚未掛載模板 \u0026ndash; 相關 render 函式首次被調用 onMounted(mounted)：實例掛載模板(真實DOM) \u0026ndash; el 被新創建的 vm.$el 替換 onBeforeUpdate(beforeUpdate)：data 更新但還沒重新渲染畫面 \u0026ndash; 適合在此更新資料 onUpdated(updated)：data 更新且渲染畫面完成 \u0026ndash; 可以取得更新的DOM onBeforeUnmount(beforeDestroy)：實例被銷毀前 \u0026ndash; 適合在此時卸載手動添加的監聽/訂閱 onUnmounted(destroyed)：實例被銷毀  如果希望在渲染畫面完畢才操作某些函式，在生命週期中使用 vm.$nextTick\nvue3 跟 vue2 混用時，vue3 的生命週期會優先執行   setup -\u0026gt; beforeCreate -\u0026gt; created -\u0026gt; onBeforeMount -\u0026gt; beforeMount -\u0026gt; onMounted -\u0026gt; mounted -\u0026gt; onBeforeUpdate -\u0026gt; beforeUpdate -\u0026gt; onUpdated -\u0026gt; updated -\u0026gt; onBeforeUnmount -\u0026gt; beforeDestroy -\u0026gt; onUnmounted -\u0026gt; destroyed\n  也可以透過 console.log()觀察順序\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt; script \u0026gt; // @ is an alias to /src  export default { name: \u0026#34;Home\u0026#34;, components: {}, // before mounted, before created  setup() { console.log(\u0026#34;setup\u0026#34;); }, created() { console.log(\u0026#34;created\u0026#34;); }, mounted() { console.log(\u0026#34;mounted\u0026#34;); } ... }; \u0026lt; /script\u0026gt;   在 setup()函式定義 data  setup()可以傳入 props 與 context setup(props, context)，但 script 要記得引入 props 如果需要解構，使用 toRefs  1 2 3 4 5 6 7 8 9 10 11 12  import { toRefs } from \u0026#39;vue\u0026#39; props: { title: String }, setup(props) { const { title } = toRefs(props) console.log(title.value) }    script 執行順序為 setup 函式內容，return 回傳模板所需變數跟方法(data, computed, methods, watch/event)，模板渲染內容 過往把要放在模板的變數定義在 data(){}，現在我們改在 setup()使用 ref 跟 reactive 定義資料來獲取響應式資料 使用 Option API 的時候常常需要寫 this 指向自己，compositionAPI 幾乎不需要管 this  template refs  ref : 可以使用任何型態的資料，在生命週期函式取資料時用變數.value(模板上則不需要.value)不會對 Object 或是 Array 內部的屬性做監聽，適合用於傳值的 primitives 也適合用於單層物件。 使用前需要先import {ref} from vue 雖然可以用於手動改變 DOM 內容，但實務上很少這樣綁定操作 下方為使用 primitives 的例子  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;home\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;home\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;My name is {{ name }} and my age is {{ age }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;handleClick\u0026#34;\u0026gt;Click\u0026lt;/button\u0026gt; // 點按鈕age++ \u0026lt;button @click=\u0026#34;age++\u0026#34;\u0026gt;add age by 1\u0026lt;/button\u0026gt; // input text值跟name變數雙向綁定 \u0026lt;input v-model=\u0026#34;name\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // 引用ref方法 import { ref } from \u0026#34;vue\u0026#34;; export default { name: \u0026#34;Home\u0026#34;, components: {}, setup() { let name = ref(\u0026#34;mario\u0026#34;); let age = ref(30); // 點按鈕改變值  const handleClick = () =\u0026gt; { name.value = \u0026#34;luigi\u0026#34;; age.value = 35; }; return { name, age, handleClick }; }, }; \u0026lt;/script\u0026gt;    下方為使用 Object 的例子 一樣 click 更新名稱跟年齡，點 add age by 1 年齡加 1，input text 值跟 name 變數雙向綁定  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;home\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;home\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;My name is {{ ninjaOne.name }} and my age is {{ ninjaOne.age }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;ninjaOne.age++\u0026#34;\u0026gt;add age by 1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;updateClick\u0026#34;\u0026gt;Click\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // 引用ref方法 import { ref } from \u0026#34;vue\u0026#34;; export default { name: \u0026#34;Home\u0026#34;, components: {}, setup() { const ninjaOne = ref({ name: \u0026#34;mario\u0026#34;, age: 30 }); const updateClick = () =\u0026gt; { ninjaOne.value.name = \u0026#34;luigi\u0026#34;; ninjaOne.value.age = 35; }; return { ninjaOne, updateClick }; }, }; \u0026lt;/script\u0026gt;   template reactive  reactive : 只接受 Object 或 Array ，可以做深層的監聽，取資料不用 .value，不建議用解構的方式取得內容，會失去 Vue 響應。 同上方 Object 例子的內容，一樣 click 更新名稱跟年齡，點 add age by 1 年齡加 1，input text 值跟 name 變數雙向綁定 差別在不需要套用 value  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;home\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;home\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;My name is {{ ninjaOne.name }} and my age is {{ ninjaOne.age }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;updateNinjaOne\u0026#34;\u0026gt;Click\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;My name is {{ ninjaTwo.name }} and my age is {{ ninjaTwo.age }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;updateNinjaTwo\u0026#34;\u0026gt;Click\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // 引用ref方法 import { ref, reactive } from \u0026#34;vue\u0026#34;; export default { name: \u0026#34;Home\u0026#34;, components: {}, setup() { const ninjaOne = ref({ name: \u0026#34;mario\u0026#34;, age: 30 }); const ninjaTwo = reactive({ name: \u0026#34;luigi\u0026#34;, age: 35 }); const updateNinjaOne = () =\u0026gt; { ninjaOne.value.name = \u0026#34;luigi\u0026#34;; ninjaOne.value.age = 35; }; const updateNinjaTwo = () =\u0026gt; { ninjaTwo.age = 45; }; return { ninjaOne, ninjaTwo, updateNinjaOne, updateNinjaTwo }; }, }; \u0026lt;/script\u0026gt;   Computed values  Composition API 一樣可以使用 Computed 來做運算 使用前需要import { computed } from vue 把運算邏輯包裹 Computed 函式，return 運算結果 下方範例為 Computed 包裹篩選陣列字詞運算  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;home\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;home\u0026lt;/h1\u0026gt; // 輸入搜尋字詞  \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;search\u0026#34; /\u0026gt; // 同步顯示搜尋字詞為何 \u0026lt;p\u0026gt;search term - {{ search }}\u0026lt;/p\u0026gt; // 輸出符合搜尋字詞的陣列字串 \u0026lt;div v-for=\u0026#34;name in matchingNames\u0026#34; :key=\u0026#34;name\u0026#34;\u0026gt;{{ name }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, computed } from \u0026#34;vue\u0026#34;; export default { name: \u0026#34;Home\u0026#34;, components: {}, setup() { const search = ref(\u0026#34;\u0026#34;); // 單層物件也可以使用ref觀察變化  const names = ref([ \u0026#34;mario\u0026#34;, \u0026#34;yoshi\u0026#34;, \u0026#34;luigi\u0026#34;, \u0026#34;toad\u0026#34;, \u0026#34;bowser\u0026#34;, \u0026#34;koopa\u0026#34;, \u0026#34;peach\u0026#34;, ]); // 篩選相關的搜尋字詞  const matchingNames = computed(() =\u0026gt; { return names.value.filter((name) =\u0026gt; name.includes(search.value)); }); return { names, search, matchingNames }; }, }; \u0026lt;/script\u0026gt;   watch  watch(監聽 dependency, ()=\u0026gt;{})，當 watch 的 dependency 有變化就執行後面的函式 後面執行函式自帶選擇性的使用的兩個參數分別為新值跟舊值 監聽深層物件加上第三個參數{deep: true} 希望載入就執行需要加上 immediate: true  1 2 3 4 5 6 7 8 9 10  watch( search, (newValue, OldValue) =\u0026gt; { console.log(\u0026#34;newValue, OldValue\u0026#34;); console.log(\u0026#34;watch\u0026#34;); }, { deep: true, immediate: true } );   watchEffect  watchEffect(() =\u0026gt; {}) 執行函式中的變數會自動添加成 dependency 元件初始化就會執行一次，後續 dependency 有變化也會執行  1 2 3  watchEffect(() =\u0026gt; { console.log(\u0026#34;watch\u0026#34;); }, search.value);   watch v.s. watchEffect  watch 可以明確指定需要依賴的屬性，watchEffect 則是依賴 callback 中使用到的屬性 watch 可以獲取新舊值，watchEffect 無法 watch 不會立即執行(除非有寫 immediate: true)，watchEffect 在元件初始化時就會執行一次 watchEffect 中 dependency 會被重複執行，動態新增加的 dependency 也會被收集  1 2 3 4 5 6 7 8 9 10 11  const counter = ref(0); const enabled = ref(false); watchEffect(() =\u0026gt; { if (enabled.value) console.log(counter.value); counter.value += 1; }); //watchEffect 立即執行，enabled是 false 所以dependency只有enabled counter.value += 1; // 無反應 enabled.value = true; // Effect 觸發，輸出1 counter.value += 1; //counter為dependency，輸出2 enabled.value = false; // 函式重新執行 無輸出 counter.value += 1; // 函式重新執行 無輸出 雖然counter是false 但還是dependency可能會觸發函式   什麼時候用watch或watchEffect？ 這篇推薦在大部分時候用 watch 顯式的指定依賴以避免不必要的重複觸發，也避免在後續代碼修改或重構時不小心引入新的 dependency。 watchEffect 適用於一些邏輯相對簡單，dependency 和邏輯強相關的場景\nVue Composition API 和 React 的 Hooks 的差異  React Hooks 在每次元件渲染時都會呼叫，需要透過 useEffect 跟 useCallback 相依參數來控制 Vue 的 setup() 每個元件例項只會在初始化時呼叫一次，狀態通過引用儲存在 setup() 的閉包內， Composition API 中不同的函式可作為迴圈或條件語句的一部分。而 Hook 不能在迴圈或條件語句下使用，因為每一個 Hook 的 next 是指向下一個 Hook，這些操作會改變順序，導致報錯。  1 2 3 4 5 6 7  function App() { const [name, setName] = useState(\u0026#34;demo\u0026#34;); // error  if (condition) { const [val, setVal] = useState(\u0026#34;\u0026#34;); } }    React Hooks 都在渲染閉包中執行，頻繁的渲染會產生許多閉包，給 GC 帶來不小壓力。Composition API 當值變化時，也不會重新觸發 setup 的執行，每次渲染不會反覆呼叫函式，減少 GC 壓力 Hook 若沒有設置正確的 dependency，設置在閉包的值會不變，Vue 的自動依賴跟嚮應式設計可以正確追蹤資料 不需要總是使用 useCallback 來快取傳給子元件的 callback 以防止過度更新  ","date":"2022-02-26T00:00:00+08:00","image":"https://bacnotes.github.io/p/vue-composition-api/Dup9I4d_huebbfad1edfa8e198fe68a27ac6a615ca_19543_120x120_fill_q75_box_smart1.jpeg","permalink":"https://bacnotes.github.io/p/vue-composition-api/","title":"介紹Vue3與Composition API｜bacnotes備份筆記"},{"content":"什麼是 Vue  Vue 是打造使用者介面的 JavaScript 漸進式框架(可依開發需求擴增功能 e.g. vue-router vuex) 以元件為中心的宣告式程式設計，無需直接操作 DOM，資料驅動畫面，透過雙向綁定讓資料有變化畫面也會響應，提高開發效率 實現關注點分離，把視覺呈現、資料等元素，放在單一檔案中，但又在技術上切分得很乾淨；template 專注在 HTML 結構，script 處理 JavaScript 邏輯，Style 則是撰寫樣式的部分，每一模組各自有獨立關注焦點 過往 DOM 操作，元素需要一個個用 CSS 選擇器選出來，而 Vue 只在單頁面創造一個容器\u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;；其他變數跟事件綁定則是使用語法糖直接寫在 HTML 上 SPA 單頁應用，不像過往跟 server 溝通，每次發請求收到新的 HTML 就會重新渲染頁面，Vue 可部分更新畫面，不需要整個頁面重新渲染，使用者體驗佳(伺服器傳送一次 HTML，就接管整個頁面的生命週期)；對比全端開發的多頁應用，則每次請求後都會再刷新一次頁面 程式碼較簡潔，可讀性高(相對沒有使用框架的狀況)，有助於後續協作跟維護  Framework 框架 v.s Library 函式庫  兩者都是幫助我們在開發時可以少寫一些 code 的工具 差異在於函式庫是我們決定呼叫的時機，而框架是我們依照邏輯去填寫框架所需要的資料，框架決定呼叫的時機 框架呼叫我們的代碼，我們的代碼呼叫函式庫 函式庫被包含在框架裡  framework 框架(e.g. Vue, React, Angular)  有自己的生命週期來決定調用這些資料跟方法的時機，裡面的資料跟方法該如何傳遞會有一定的規範，  Library 函式庫(e.g. day.js, SweetAlert)  類似套件的概念，透過函式庫的處理，可以獲取對應的回傳結果(格式轉換/彈跳視窗)  The Difference Between a Framework and a Library\n建構 Vue 專案 的方式 CDN   開發版：會有對應 console warnings https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\n  上線版：optimized for size and speed\nhttps://cdn.jsdelivr.net/npm/vue@2\n  優點：\n 依照地區最近的伺服器提供服務(透過不同節點提供當地使用者服務)，減少存取資料延遲 CDN 伺服器分擔流量，降低本來的 loading CDN 有快取，當服務突然有問題短時間還可以撐一下  缺點：\n 要付費 CDN 掛掉你的產品也會掛掉 每次網站更新，需要主動清除 CDN 快取，不然使用者會看到不夠即時的 資訊  Vue CLI  基於 Webpack 打包程式碼，透過讀取入口文件、解析依賴模組、收集 dependency、程式碼轉譯、打包合併、代碼優化，最終將高版本/離散的程式碼編譯打包成低版本/高兼容性的產物代碼建構成一個 JavaScript 的捆綁包，結合 webpack-dev-server 提供靜態資源 開發環境運行相對 Vite 慢，冷啟動跟熱加載都會隨著應用程式變大，等待時間更長，開發體驗較差 配置很齊全，舊瀏覽器相容性高  Vite  基於 ESM (ES Modules)，開發時使用 ESbuild(Go 語言撰寫)，依賴瀏覽器 ES6 Modules 的原生支持，在運行的時候直接發 HTTP 請求 JavaScript 模組 冷啟動跟熱加載快速，開發體驗速度快，開發時編譯的程式碼簡潔，舊瀏覽器相容性低 production 會使用 rollup 打包，開發編譯跟 production 打包是不同系統，可能少數狀況下會有不同行為  Vue 生命週期 在 SPA 應用，針對部分元件掛載/資料更新/卸載時有對應的生命週期適合操作，透過這些 Vue 內建的 Hook function 來介入\n beforeCreate：初始化 Vue 實例/事件跟生命週期  尚無法讀取 data, computed, methods, watch/event callbacks 適合展示 loading 畫面，不適合 fetch 資料，還沒有 data 可以存   created：創建完實例(虛擬 DOM)  設置 data, computed, methods, watch/event callbacks 尚無法讀取$el，適合 fetch 資料   beforeMount：尚未掛載模板  相關 render 函式首次被調用   mounted：實例掛載模板(真實 DOM)  el 被新創建的 vm.$el 替換   beforeUpdate：data 更新但還沒重新渲染畫面  適合在此更新資料，可重複呼叫   updated：data 更新且渲染畫面完成  可以取得更新的 DOM，可重複呼叫   beforeDestroy：實例被銷毀前  適合在此時卸載手動添加的監聽/訂閱   destroyed：實例被銷毀  父子元件的生命週期   掛載：父元件是在子元件 mounted 後才 mounted 父元件 beforeCreate 父元件 created 父元件 beforeMount 子元件 beforeCreate 子元件 created 子元件 beforeMount 子元件 mounted 父元件 mounted\n  資料更新 父元件 beforeUpdate 子元件 beforeUpdate 子元件 updated 父元件 updated\n  銷毀元件 父元件 beforeDestroy 子元件 beforeDestroy 子元件 destroyed 父元件 destroyed\n  Vue 跨元件傳遞資料   父傳子：Props 透過 props 把值從父層丟到子層，當元件距離很遠就會不好傳遞 props API\n  子傳父：emit 子層要改變父層狀態的話，可透過子層發送 emit 觸發父層的 methods 來更新狀態 emits API\n  兄弟層的傳遞： 需要搭配 event 往上傳，Props 往下傳 使用 EventBus（vue3 已移除，建議用 vuex 管理) $on: 監聽 $once: 監聽一次 $off: 取消監聽 $emit: 傳遞事件 created 即進行監聽，beforeDestroy 進行取消 可以參考這篇\n  vuex store 統一管理讓所有元件可跨層級獲取這些資料，若需要非同步觸發資料的更新，也可以用 action 來 emit 事件，然後透過 mutation 裡面的方法來更新資料\n  ＊避免濫用 vuex 管理所有資料，在傳遞不易或跟跨頁面（切換路由等）時使用（e.g. 驗證狀態/購物車/遊戲結果等)；父子元件就用本來的 props 或 emit 即可(e.g. fetch API 資料往下傳遞給各元件)\nEvent-bus Event-bus emit / on 事件，做跨層級傳遞，缺點是事件命名相同就會導致衝突，且監聽也需要做好管理，不需要的時候要記得清除，例如在多個路由切換時，若不同頁面使用了同一個事件名，會導致重複觸發事件的問題（因事件的監聽不會隨著元件的銷毀而跟著銷毀，要主動去註銷事件），且註銷也需要小心處理，沒註銷正確也有可能導致後續觸發失敗  專案資料夾配置 之前曾經看到過很完整的配置範例，包含 Sass 資料夾規劃\nvue 開發者工具 chrome extension 連結\nUser Story 概略版  輸入框一開始會是 focus 狀態，placeholder 有提示文字 有任務時輸入框會多一個 label 做出來的三角形按鈕 點三角形按鈕會全選所有任務 手動全選任務也會觸發三角形按鈕全選樣式 任務的 layout 是 checkbox/任務內容/刪除按鈕 雙擊選項編輯任務內容 footer 有 span 文字提示還有多少件事項沒完成，需考慮單複數 三個篩選器篩選不同狀態的任務 all/active/complete (不同路由)  CSS\n創建 Vue 實例  CDN 載入 Vue 後就有構造函式，我們可以透過 new Vue 創建實例，綁定對應 HTML 元素/容器 JavaScript 創建 Vue 實例，綁定 HTML 元素/容器 下方為 todomvc 簡單規劃區塊， #app 綁定 \u0026lt;div id =\u0026quot;#app\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;{{ title }}\u0026lt;/h1\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;main\u0026gt;\u0026lt;/main\u0026gt; \u0026lt;footer\u0026gt;\u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#34;#app\u0026#34;, data: { title: \u0026#34;todos\u0026#34;, // 屬性：值  }, }); \u0026lt;/script\u0026gt;   vue 模板語言跟表達式  雙括弧{{ 表達式 }}，若為變數會顯示 key 的對應 Value，跟 React 的{表達式}一樣，放在\u0026lt;HTML元素\u0026gt;{{ }}\u0026lt;/HTML元素\u0026gt;之間 如果變數被\u0026quot;\u0026ldquo;包著{{\u0026ldquo;變數\u0026rdquo;}}，會顯示純字串 用來形容 HTML 屬性用的變數會使用\u0026quot;\u0026quot;，\u0026lt;HTML元素 class=\u0026quot;變數\u0026quot;\u0026gt;\u0026lt;/HTML元素\u0026gt;  v-bind 動態綁定 data 屬性  :屬性名 data API 實現 JavaScript 跟 HTML 資料綁定 v-bind可以用縮寫符號:代替 當屬性值為 true 會出現，若值為null undefined false 屬性不會出現 :class可以異動 class name，但只能針對 vue 自己增加的做改變，不能動到原本生成的 由 completed 的布林值決定 text 樣式，\u0026lt;li :class=\u0026quot;completed\u0026quot;\u0026gt;text\u0026lt;/li\u0026gt;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;template\u0026gt; \u0026lt;li class=\u0026#34;todo\u0026#34; :class=\u0026#34;{ completed }\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; //也可以直接寫成一個key value物件  \u0026lt;li class=\u0026#34;todo\u0026#34; :class=\u0026#34;{ completed: true }\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; // 若單個屬性要插入多個值，可以運用陣列  \u0026lt;li class=\u0026#34;todo\u0026#34; :class=\u0026#34;[{ completed: true }, { edit: true }]\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#34;#app\u0026#34;, data: { completed: true, }, }); \u0026lt;/script\u0026gt;   v-for 迴圈  v-for=\u0026quot;(item, index) in items\u0026quot; :key=\u0026quot;item.id\u0026quot; items 可為陣列/物件/數字/字串/Iterables 物件迭代順序是根據 key，key 像是 MongoDB 內建的_id，vue 會用 key 確認資料是否有正常刪改，為了避免在 diff 演算後減少發生刪改後渲染有錯，且為了讓演算法有更好的效能，強烈建議要加上，但不要使用 index 如果一串資料中沒定義 id，可用 uuid 套件產出補上，不要用 index 作為 key。由於 index 對應的資料是浮動而非絕對位置，因此在比較虛擬 dom 跟真實 dom 的過程中會出錯 vue2 v-for 的優先順序高於 v-if，vue3 v-if 的優先順序高於 v-for，避免在同一元素上同時使用兩者，最好的做法是用 computed 篩選出列表再迴圈渲染 這邊的 item 物件也可以傳給下層 HTML 元素利用  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  \u0026lt;template\u0026gt; \u0026lt;li v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item.id\u0026#34; class=\u0026#34;item\u0026#34; :class=\u0026#34;{ completed: item.completed }\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;view\u0026#34;\u0026gt; \u0026lt;input class=\u0026#34;toggle\u0026#34; type=\u0026#34;checkbox\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;\u0026#34;\u0026gt;{{ item.title }}\u0026lt;/label\u0026gt; \u0026lt;button class=\u0026#34;destroy\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;edit\u0026#34; /\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { todos: [ { title: \u0026#39;todo1\u0026#39;, completed: true, }, { title: \u0026#39;todo2\u0026#39;, completed: false, }, { title: \u0026#39;todo3\u0026#39;, completed: false, }, ], }, } \u0026lt;/script\u0026gt;   v-on 監聽事件  @事件類型 v-on可以用縮寫符號@代替，@click @change @keyup 參數加上 $event，可以用來取得 DOM event 物件的值 v-for=\u0026ldquo;item in items\u0026quot;的結構裡，還可以傳物件給事件 @click=\u0026ldquo;事件類型(item 物件)\u0026rdquo; 由於 windows.event(全域 event 物件)已經被棄用，若事件方法有用到 event 物件設定$event參數以取得event物件，參數使用 $event，@click=\u0026quot;事件類型($event)\u0026quot;，以取得觸發事件內部參數 常見的按鍵.enter .esc .space 等有專用修飾符不需要再另記 key code 鍵盤支援清單 常見的事件修飾符.stop(阻擋冒泡) .prevent(阻擋預設事件重載頁面) .capture(向下捕獲方式觸發) .self(限定指定元素本身觸發) .once(只觸發一次) .passive(滾動事件延遲，讓行動端不卡)，修飾符可以串連 事件綁定的方法 callback function 寫在 script 的 methods 裡面 input 綁定事件參數差異  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  \u0026lt;template\u0026gt; // input綁定任意鍵觸發handleKeyup方法，並傳入newTodo變數  \u0026lt;input v-model=\u0026#34;newTodo\u0026#34; @keyup=\u0026#34;handleKeyup(newTodo)\u0026#34; type=\u0026#34;text\u0026#34; class=\u0026#34;new-todo\u0026#34; autofocus placeholder=\u0026#34;what needs to be done？\u0026#34; /\u0026gt; // input限制enter鍵觸發handleKeyup，並傳入newTodo變數  \u0026lt;input v-model=\u0026#34;newTodo\u0026#34; @keyup.enter=\u0026#34;handleKeyup(newTodo)\u0026#34; type=\u0026#34;text\u0026#34; class=\u0026#34;new-todo\u0026#34; autofocus placeholder=\u0026#34;what needs to be done？\u0026#34; /\u0026gt; // 透過$event 來拿到 event 物件  \u0026lt;input v-model=\u0026#34;newTodo\u0026#34; @keyup=\u0026#34;handleKeyup(newTodo, $event)\u0026#34; type=\u0026#34;text\u0026#34; class=\u0026#34;new-todo\u0026#34; autofocus placeholder=\u0026#34;what needs to be done？\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // 測試有無成功觸發事件，console出傳入參數，名稱任意 methods: { handleKeyup2(inputContent, event) { console.log(inputContent, event); } } \u0026lt;/script\u0026gt;   v-model 雙向綁定 input 跟資料  v-bind + v-on 的結合，只適合用在表單元素 v-bind 資料 → 畫面，v-on 畫面 → 資料 v-model 初始值優先看 data 裡面的值，表單上寫的checked selected屬性會忽略  1 2 3 4 5 6 7 8 9 10  \u0026lt;template\u0026gt; // 綁定在 input 寫一個 v-model=\u0026#34;data對應屬性\u0026#34;  \u0026lt;input v-model=\u0026#34;newTodo\u0026#34; type=\u0026#34;text\u0026#34; class=\u0026#34;new-todo\u0026#34; autofocus placeholder=\u0026#34;what needs to be done？\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt;   1 2 3 4 5 6 7  new Vue({ el: \u0026#34;#app\u0026#34;, data: { newTodo: \u0026#34;\u0026#34;, //新增一個屬性 初始值空的字串\u0026#39;\u0026#39;  // ...  }, });     不同類型的 input 會偵測不同事件，更新不同屬性\n  type = text textarea元素 偵測到 input 事件會更新 value (\u0026lt;input\u0026gt;, \u0026lt;select\u0026gt; \u0026lt;textarea\u0026gt; 元素的 value 被修改時會觸發 input 事件) ＊ textarea 標籤中間的雙括弧不會雙向綁定，只會單向顯示資料內容，不要用這個 ( \u0026lt;textarea\u0026gt;{{text}}\u0026lt;/textarea\u0026gt; ) 使用 v-model\nhttps://vuejs.org/v2/guide/forms.html\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;template\u0026gt; \u0026lt;input v-model=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;span\u0026gt;Multiline message is:\u0026lt;/span\u0026gt; \u0026lt;p style=\u0026#34;white-space: pre-line;\u0026#34;\u0026gt;{{ message }}\u0026lt;/p\u0026gt; \u0026lt;textarea v-model=\u0026#34;message\u0026#34; placeholder=\u0026#34;add multiple lines\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#34;#app\u0026#34;, data: { text: \u0026#34;\u0026#34;, message: \u0026#34;\u0026#34;, }, }); \u0026lt;/script\u0026gt;    type = checkbox type= radio 單複選偵測 change 事件，抓取 checked 值(true/false)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  \u0026lt;template\u0026gt; // 單選radio  \u0026lt;input type=\u0026#34;radio\u0026#34; id=\u0026#34;one\u0026#34; value=\u0026#34;One\u0026#34; v-model=\u0026#34;picked\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;one\u0026#34;\u0026gt;One\u0026lt;/label\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; id=\u0026#34;two\u0026#34; value=\u0026#34;Two\u0026#34; v-model=\u0026#34;picked\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;two\u0026#34;\u0026gt;Two\u0026lt;/label\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;span\u0026gt;Picked: {{ picked }}\u0026lt;/span\u0026gt; // 單選checkbox \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;checked\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;checkbox\u0026#34;\u0026gt;{{ checked }}\u0026lt;/label\u0026gt; \u0026lt;br /\u0026gt; // 多選checkbox，綁定陣列，透過\u0026#34;checkedNames\u0026#34; 將對應的value傳入陣列，顯示勾選的名字 \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;jack\u0026#34; value=\u0026#34;Jack\u0026#34; v-model=\u0026#34;checkedNames\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;jack\u0026#34;\u0026gt;Jack\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;john\u0026#34; value=\u0026#34;John\u0026#34; v-model=\u0026#34;checkedNames\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;john\u0026#34;\u0026gt;John\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;mike\u0026#34; value=\u0026#34;Mike\u0026#34; v-model=\u0026#34;checkedNames\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;mike\u0026#34;\u0026gt;Mike\u0026lt;/label\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;span\u0026gt;Checked names: {{ checkedNames }}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#34;#app\u0026#34;, data: { picked: \u0026#34;\u0026#34;, checked: true, checkedNames: [], }, }); \u0026lt;/script\u0026gt;    select下拉選單偵測change事件，更新value值  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u0026lt;template\u0026gt; //\u0026#34;selected\u0026#34; 將勾選的value 傳到陣列顯示  \u0026lt;select v-model=\u0026#34;selected\u0026#34;\u0026gt; \u0026lt;option disabled value=\u0026#34;\u0026#34;\u0026gt;Please select one\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;A\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;B\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;C\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;span\u0026gt;Selected: {{ selected }}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#34;#app\u0026#34;, data: { selected: \u0026#34;\u0026#34;, }, }); \u0026lt;/script\u0026gt;   新增 todo  引入 uuid 套件，在 script 測試 alert(uuidv4()) 把 newTodo 內容加上新屬性 uuid 產出的 id，push 到 data 裡面的 todos 陣列 新增完後把 newTodo 清空(避免按 enter 會增加一樣的內容) 空白 return 提示內容為空  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  \u0026lt;template\u0026gt; \u0026lt;input v-model=\u0026#34;newTodo\u0026#34; @keyup.enter=\u0026#34;addTodo(newTodo, $event)\u0026#34; type=\u0026#34;text\u0026#34; class=\u0026#34;new-todo\u0026#34; autofocus placeholder=\u0026#34;what needs to be done？\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#34;#app\u0026#34;, data: { newTodo: \u0026#34;\u0026#34;, // update dummy data with id  todos: [ { id: uuidv4(), title: \u0026#34;todo1\u0026#34;, completed: true, }, { id: uuidv4(), title: \u0026#34;todo2\u0026#34;, completed: false, }, { id: uuidv4(), title: \u0026#34;todo3\u0026#34;, completed: false, }, ], }, methods: { addTodo() { const title = this.newTodo.trim(); console.log(this.newTodo); if (!title) { return; } // 每筆資料都增加 id 屬性，值帶入 uuidv4()  this.todos.push({ id: uuidv4(), title: this.newTodo, completed: false, }); this.newTodo = \u0026#34;\u0026#34;; }, }, }); \u0026lt;/script\u0026gt;   刪除 todo  要找到對應元素需要 id，透過參數回傳  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  \u0026lt;template\u0026gt; \u0026lt;ul class=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;todo in todos\u0026#34; class=\u0026#34;todo\u0026#34; :class=\u0026#34;{ completed: todo.completed }\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;view\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; class=\u0026#34;toggle\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;\u0026#34;\u0026gt;{{ todo.title }}\u0026lt;/label\u0026gt; \u0026lt;!-- 帶入 todo 參數 --\u0026gt; \u0026lt;button @click=\u0026#34;removeTodo(todo)\u0026#34; class=\u0026#34;destroy\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;edit\u0026#34; /\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { newTodo: \u0026#39;\u0026#39;, todos: [ { id: uuidv4(), title: \u0026#34;todo1\u0026#34;, completed: true }, { id: uuidv4(), title: \u0026#34;todo2\u0026#34;, completed: false }, { id: uuidv4(), title: \u0026#34;todo3\u0026#34;, completed: false } ], }, methods: { ... removeTodo(todo){ // 留下非點擊到的todo  this.todos = this.todos.filter(todo =\u0026gt; todo.id !== todo.id) } } }) \u0026lt;/script\u0026gt;   動態切換 todo 刪除線樣式(雙向綁定)  點 label 切換會有打勾變化，是 checkbox 本身有無 checked 的樣式，還沒跟資料狀態綁定，需要在使用者點擊核選方塊時，改變刪除線樣式 先前用:todo.completed 屬性來動態顯示刪除線 :class=\u0026quot;{completed: todo.completed}，現在把 todo.completed 資料狀態用 v-model=\u0026ldquo;todo.completed\u0026quot;綁定回 input 的 checked 值（這個是 vue 預設 v-model 使用情境) 此當我們畫面操作改變 checked 值 todo.completed 值也會連動 資料 completed 初始值要設定好，確認沒有寫反  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  \u0026lt;template\u0026gt; \u0026lt;li v-for=\u0026#34;todo in todos\u0026#34; :key=\u0026#34;todo.id\u0026#34; class=\u0026#34;todo\u0026#34; :class=\u0026#34;{ completed: todo.completed }\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;view\u0026#34;\u0026gt; // \u0026#34;todo.completed\u0026#34; 為真與否也會影響:class // 如果completed:false就會這個v-bind綁定就會消失 \u0026lt;input v-model=\u0026#34;todo.completed\u0026#34; class=\u0026#34;toggle\u0026#34; type=\u0026#34;checkbox\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;\u0026#34;\u0026gt;{{ todo.title }}\u0026lt;/label\u0026gt; \u0026lt;button @click=\u0026#34;removeTodo(todo)\u0026#34; class=\u0026#34;destroy\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;edit\u0026#34; /\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#34;#app\u0026#34;, data: { newTodo: \u0026#34;\u0026#34;, todos: [ { id: uuidv4(), title: \u0026#34;todo1\u0026#34;, completed: true, }, { id: uuidv4(), title: \u0026#34;todo2\u0026#34;, completed: false, }, { id: uuidv4(), title: \u0026#34;todo3\u0026#34;, completed: false, }, ], }, }); \u0026lt;/script\u0026gt;   條件渲染：v-show 和 v-if  清單為空時， main 跟 footer 跟 toggle all 的 icon 也會消失 用 todos.length 來判斷清單為空，依條件顯示 footer \u0026amp; main 根據條件隱藏的元素加上 v-show=\u0026ldquo;todos.length\u0026rdquo; v-if：適合切換頻率小，不希望出現在 DOM tree，不希望使用者打開 DevTool 就看到隱藏的內容 v-show：只是加上 display: none 讓使用者看不到，仍保留在 DOM tree，適合切換頻率高的元件  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;template\u0026gt; // 清單為空為false不會顯示 但DOM會有下方這行且加上屬性display:none \u0026lt;footer class=\u0026#34;footer\u0026#34; v-show=\u0026#34;todos.length\u0026#34;\u0026gt; // 清單為空為false不會顯示 這行在DOM會顯示為\u0026lt;!----\u0026gt; \u0026lt;footer class=\u0026#34;footer\u0026#34; v-if=\u0026#34;todos.length\u0026#34;\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { newTodo: \u0026#34;\u0026#34;, todos: [ ... ] }, }) \u0026lt;/script\u0026gt;    組合 v-if、v-else、v-else-if 來控制流程  `\n1 2 3 4 5 6 7 8 9 10 11 12 13  // if else \u0026lt;template\u0026gt; \u0026lt;div v-if=\u0026#34;Math.random() \u0026gt; 0.5\u0026#34;\u0026gt;Now you see me\u0026lt;/div\u0026gt; \u0026lt;div v-else\u0026gt;Now you don\u0026#39;t\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; ```vue // if else-if else \u0026lt;template\u0026gt; \u0026lt;div v-if=\u0026#34;type === \u0026#39;A\u0026#39;\u0026#34;\u0026gt;A\u0026lt;/div\u0026gt; \u0026lt;div v-else-if=\u0026#34;type === \u0026#39;B\u0026#39;\u0026#34;\u0026gt;B\u0026lt;/div\u0026gt; \u0026lt;div v-else-if=\u0026#34;type === \u0026#39;C\u0026#39;\u0026#34;\u0026gt;C\u0026lt;/div\u0026gt; \u0026lt;div v-else\u0026gt;Not A/B/C\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt;    當 todos.length 為 false 只留 No footer 文字  1 2 3 4 5 6  \u0026lt;template\u0026gt; \u0026lt;footer class=\u0026#34;footer\u0026#34; v-if=\u0026#34;todos.length\u0026#34;\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;div v-else\u0026gt;No footer\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt;   computed 需運算再放到畫面上的資料  computed API 跟 data 一樣會 return 值 會建立一個快取，值沒有變化就不會重新運算，相較 methods 每次重新渲染就會呼叫一次方法，computed 效能較好（類似 react 的 useState) 可以用來實作運算邏輯，當資料有改變就會更新  篩選 all active complete  運用陣列的 filter 方法來篩選 all active complete todos 篩選 function 用 filters 封裝 active 數量顯示在 footer 新增變數 filteredOption，設定狀態 all active completed 透過按鈕觸發 setFilterdOption 更新狀態 改用 filteredTodos 來渲染清單內容，computed 裡新增 filteredTodos  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  \u0026lt;template\u0026gt; // 清單  \u0026lt;ul class=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;todo in filteredTodos\u0026#34; :key=\u0026#34;todo.id\u0026#34; class=\u0026#34;todo\u0026#34; :class=\u0026#34;{ completed: todo.completed }\u0026#34; \u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; // footer \u0026lt;strong\u0026gt;{{ activeTodos }}\u0026lt;/strong\u0026gt; items left // 篩選按鈕 \u0026lt;ul class=\u0026#34;filters\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#/all\u0026#34; @click=\u0026#34;setFilteredOption(\u0026#39;all\u0026#39;)\u0026#34;\u0026gt;All\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#/active\u0026#34; @click=\u0026#34;setFilteredOption(\u0026#39;active\u0026#39;)\u0026#34;\u0026gt;Active\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#/completed\u0026#34; @click=\u0026#34;setFilteredOption(\u0026#39;completed\u0026#39;)\u0026#34; \u0026gt;Completed\u0026lt;/a \u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // 過於分散 // const allTodos = (todos) =\u0026gt; todos // const activeTodos = (todos) =\u0026gt; todos.filter((todo) =\u0026gt; !todo.completed) // const completedTodos = (todos) =\u0026gt; todos.filter((todo) =\u0026gt; todo.completed)  const filters = { all: (todos) =\u0026gt; todos, active: (todos) =\u0026gt; todos.filter((todo) =\u0026gt; !todo.completed), completed: (todos) =\u0026gt; todos.filter((todo) =\u0026gt; todo.completed), }; new Vue({ el: \u0026#34;#app\u0026#34;, data: { ... filteredOption: \u0026#34;all\u0026#34;, }, methods: { setFilteredOption(filteredOption) { this.filteredOption = filteredOption; }, }, computed: { activeTodos() { return filters.active(this.todos).length; }, // bracket notation  filteredTodos() { return filters[this.filteredOption](this.todos); // filters.all(this.todos)  // filters.active(this.todos)  // filters.completed(this.todos)  }, }, }); \u0026lt;/script\u0026gt;   被選擇的按鈕樣式  被點的會掛上 selected 取消原先點的 selected 用 v-bind 的 true 會顯示屬性 false 不會顯示屬性實作 selected(不用另外定義 data)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  \u0026lt;template\u0026gt; \u0026lt;footer class=\u0026#34;footer\u0026#34; v-show=\u0026#34;todos.length\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;todo-count\u0026#34;\u0026gt; \u0026lt;strong\u0026gt;{{ activeTodos }}\u0026lt;/strong\u0026gt; {{ activeTodos | pluralize }} left \u0026lt;/span\u0026gt; \u0026lt;ul class=\u0026#34;filters\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#/all\u0026#34; :class=\u0026#34;{ selected: filteredOption === \u0026#39;all\u0026#39; }\u0026#34; v-on:click=\u0026#34;setFilteredOption(\u0026#39;all\u0026#39;)\u0026#34; \u0026gt;All\u0026lt;/a \u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#/active\u0026#34; :class=\u0026#34;{ selected: filteredOption === \u0026#39;active\u0026#39; }\u0026#34; v-on:click=\u0026#34;setFilteredOption(\u0026#39;active\u0026#39;)\u0026#34; \u0026gt;Active\u0026lt;/a \u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#/completed\u0026#34; :class=\u0026#34;{ selected: filteredOption === \u0026#39;completed\u0026#39; }\u0026#34; v-on:click=\u0026#34;setFilteredOption(\u0026#39;completed\u0026#39;)\u0026#34; \u0026gt;Completed\u0026lt;/a \u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;button v-on:click=\u0026#34;removeCompleteTodos(todos)\u0026#34; class=\u0026#34;clear-completed\u0026#34;\u0026gt; Clear completed \u0026lt;/button\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/template\u0026gt;   filters (vue3 移除，可用 computed 代替)  {{ 變數 | filters 的方法 }} 常用於大小寫 / 單複數 / 時間格式 / 貨幣格式 當 activeTodos 為 1，回傳 item，超過則傳 items  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  \u0026lt;template\u0026gt; ... \u0026lt;span class=\u0026#34;todo-count\u0026#34;\u0026gt; \u0026lt;strong\u0026gt;{{ activeTodos }}\u0026lt;/strong\u0026gt; {{ activeTodos | pluralize }} left \u0026lt;/span\u0026gt; ... \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { ... }, methods: { ... }, filters: { toUpperCase(words) { return words.toUpperCase(); } pluralize(n) { return n \u0026gt; 1 ? \u0026#39;items\u0026#39; : \u0026#39;item\u0026#39; } } }) \u0026lt;/script\u0026gt;   清空已完成項目  removeCompleteTodos(todos)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;template\u0026gt; \u0026lt;button v-on:click=\u0026#34;removeCompleteTodos(todos)\u0026#34; class=\u0026#34;clear-completed\u0026#34;\u0026gt; Clear completed \u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; ... methods: { removeCompleteTodos(todos){ this.todos = this.todos.filter((todo) =\u0026gt; todo.completed === false); } } ... \u0026lt;/script\u0026gt;   LocalStorage 保存資料  saveStorage 掛載 created 後，預設值已經定義在 created 階段。原本在 data 寫的 todos 預設值可以刪除  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;script\u0026gt; ... created() { // 取出時JSON.parse()轉JavaScript物件  // 當沒有資料時給他一個空陣列 不然如果是null會造成連鎖錯誤  this.todos = JSON.parse(localStorage.getItem(\u0026#39;STORAGE_KEY\u0026#39;))|| [] }, methods: { saveStorage() { // 存入時搭配 JSON.stringify() 轉成字串  localStorage.setItem(STORAGE_KEY, JSON.stringify(this.todos)) } } ... \u0026lt;/script\u0026gt;   watch 監控資料變化  淺層監聽：陣列內資料數量增減（預設） watc API  1 2 3 4 5 6 7 8 9 10  \u0026lt;script\u0026gt; new Vue({ // 一旦 todos 有變化，就會執行{}裡的內容。  watch: { todos() { this.saveStorage(); }, }, }); \u0026lt;/script\u0026gt;    深層監聽：陣列資料屬性改變  1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;script\u0026gt; new Vue({ watch: { // 為了帶入deep屬性 把todos 改寫  todos: { handler: function () { console.log(\u0026#34;saveStorage\u0026#34;); //測試用  this.saveStorage(); }, deep: true, //開啟深層監聽  }, }, }); \u0026lt;/script\u0026gt;   編輯 todo  雙擊觸發編輯模式，加上.editing 樣式（display:block /none 切換） 編輯模式(focus 狀態)按下 Enter 完成編輯並解除編輯模式 編輯模式按下 ESC 跟離開輸入框 (blur 事件)取消編輯並解除編輯模式 完成編輯時(Enter)內容是空白的話，會刪除這個 id 的空白 todo（內容不得為空) 新增 currentEditTodo 來管理編輯內容 currentEditTodo 使用 v-model 進行雙向綁定，type 即時更新 currentEditTodo 完成編輯時覆寫回原本的 todos  動態添加 editing 樣式  當 todo 的 id === currentEditTodo.id，input 加上 editing 的 class 原本已經有:class 了，用物件包裹兩個 key value  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  \u0026lt;template\u0026gt; \u0026lt;ul class=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;todo in filteredTodos\u0026#34; :key=\u0026#34;todo.id\u0026#34; class=\u0026#34;todo\u0026#34; :class=\u0026#34;{ completed: todo.completed, editing: todo.id === currentEditTodo.id, }\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;view\u0026#34;\u0026gt; \u0026lt;input v-model=\u0026#34;todo.completed\u0026#34; class=\u0026#34;toggle\u0026#34; type=\u0026#34;checkbox\u0026#34; /\u0026gt; // 雙click就可以取得物件 todo是v-for的元素 \u0026lt;label @dblclick=\u0026#34;editTodo(todo)\u0026#34;\u0026gt;{{ todo.title }}\u0026lt;/label\u0026gt; \u0026lt;button class=\u0026#34;destroy\u0026#34; @click=\u0026#34;removeTodo(todo)\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; // edit這邊的input加上v-model，就可以讓資料跟畫面連動  \u0026lt;input v-model=\u0026#34;currentEditTodo.title\u0026#34; type=\u0026#34;text\u0026#34; class=\u0026#34;edit\u0026#34; /\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; data: { newTodo: \u0026#34;\u0026#34;, todos: [ ], currentEditTodo:[], filteredOption: \u0026#34;all\u0026#34; } method: { editTodo(todo){ // 複製todo 如果直接寫= {todo}會指稱到同一個物件記體，改到原始資料  this.currentEditTodo = { ...todo } }, } \u0026lt;/script\u0026gt;   取消編輯（回到原來沒有 editing 狀態）  cancelEdit 把 this.currentEditTodo 變成一個空物件 當 currentEditTodo 被清空後 v-bind 的條件 todo.id === currentEditTodo.id 無法成立 editing 屬性消失，畫面也從輸入框變回一般的顯示狀態 esc 鍵綁定 keyup 事件  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026lt;template\u0026gt; \u0026lt;input v-model=\u0026#34;currentEditTodo.title\u0026#34; type=\u0026#34;text\u0026#34; class=\u0026#34;edit\u0026#34; @keyup.esc=\u0026#34;cancelEdit\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; ... methods: { cancelEdit() { this.currentEditTodo = {} }, } ... \u0026lt;/script\u0026gt;   完成編輯  按下 enter(click 事件)或點其他地方(blur 事件)就把 currentEditTodo 換進去 this.todo 裡面 把編輯完成的 currentEditTodo，放入 todos 陣列中 id 相同的位置 編輯狀況下修改最後是空白的話，直接刪除這個項目 放入後清空 currentEditTodo，li 上的 editing 樣式會同時消失  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  \u0026lt;template\u0026gt; \u0026lt;input v-model=\u0026#34;currentEditTodo.title\u0026#34; type=\u0026#34;text\u0026#34; class=\u0026#34;edit\u0026#34; @keyup.esc=\u0026#34;cancelEdit\u0026#34; @keyup.enter=\u0026#34;doneEdit\u0026#34; @blur=\u0026#34;doneEdit\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; methods: { doneEdit() { // map複製一份id 與 currentEditTodo 對應的新內容。否則就原封不動更新到this.todos  this.todos = this.todos.map(todo =\u0026gt; { // 兩者id一樣代表在修改狀態 沒在修改時this.currentEdit是空物件  if (todo.id === this.currentEditTodo.id) { return { ...this.currentEditTodo } } else { return todo } // trim完變成空字串 內容強制轉型false會被過濾掉  }).filter(todo =\u0026gt; todo.title.trim()) this.currentEditTodo = {} }, } \u0026lt;/script\u0026gt;   全部勾選/取消 所有 todo 打勾上方 label #toggle-all 也會連動打勾  點擊 label 也能選到 checkbox，所以樣式是做在 label 上 html 架構 label 位於 input 後方，但畫面上呈現在 input 架構之前，利用 position 調整位置 css 上是用偽元素做\u0026gt;的 content 並把旋轉 90 度 設計一個 computed 屬性回傳 todos 是否全部完成 用 activeTodos === 0 判斷 雙向綁定 input 切換 todos 裡全部項目 checked 完成狀態  1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;template\u0026gt; // 在 true/false 值改變時，都會觸發  \u0026lt;input id=\u0026#34;toggle-all\u0026#34; class=\u0026#34;toggle-all\u0026#34; type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;allDone\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; ... computed: { allDone() { return this.activeTodos === 0 }, } ... \u0026lt;/script\u0026gt;   最上方的打勾下方所有清單也會打勾  切換 todos 裡全部項目的 completed 屬性，每次點擊都會切換 true/false 用展開運算子 \u0026hellip; 把 todo 內容全部拷貝一份，然後再針對想要修改的 completed 屬性重新設定  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026lt;script\u0026gt; methods: { allDone: { // 下面全打勾 連動上面toggle all  get() { return this.activeTodos === 0 }, // 上面打勾就會下面completed都會變成completed  set(value) { this.todos = this.todos.map((todo) =\u0026gt; ({ ...todo, completed: value })) } } } \u0026lt;/script\u0026gt;   directives 自定義屬性  讓不同的 Vue 實例可以共享指令 第一個參數一定要帶入想綁定的元素 element 第二個參數 binding 下有很多屬性 value, oldValue，詳細可參考這裡 做好指令可以在 template 裡用 v-todo-focus 來使用  編輯模式自動 focus 表單  當 v-todo-focus 回傳 true，就為該元素呼叫 focus() 方法，讓游標鎖定到編輯輸入框裡  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  \u0026lt;template\u0026gt; // 把 v-todo-focus 放到 input  當 todo.id 和 currentEditTodo.id 相同時，就代表該 to-do 正在編輯模式中 \u0026lt;input v-model=\u0026#34;currentEditTodo.title\u0026#34; v-todo-focus=\u0026#34;todo.id === currentEditTodo.id\u0026#34; type=\u0026#34;text\u0026#34; class=\u0026#34;edit\u0026#34; @keyup.esc=\u0026#34;cancelEdit\u0026#34; @keyup.enter=\u0026#34;doneEdit\u0026#34; @blur=\u0026#34;doneEdit\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; new Vue({ //...  directives: { // 在 JavaScript 的物件 key 帶入特殊符號，需要把 key 設定成字串  \u0026#34;todo-focus\u0026#34;: function (el, binding) { if (binding.value) { el.focus(); } }, }, }); \u0026lt;/script\u0026gt;   Option API v.s. Composition API  Option API(data, methods, 生命週期)裡面定義的 property 可以用 this.property 獲取 this 指向元件實例本身  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  \u0026lt;script\u0026gt; export default { // Properties returned from data() becomes reactive state  // and will be exposed on `this`.  data() { return { count: 0, }; }, methods: { increment() { this.count++; }, }, mounted() { console.log(`The initial count is ${this.count}.`); }, }; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;count is: {{ count }}\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt;    屬性不使用箭頭函式，會影響裡面的 this 綁定，一開始就會變成全域 window，而不是在呼叫的時候才知道是誰 建議寫法為  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;script\u0026gt; methods: () { // 寫法1  someFunction () { // this會是元件  } // 寫法2  someFunction：function() { // this會是元件  } // 勿使用箭頭函式  removeTodo: () =\u0026gt; { // this 會指向global context  } } \u0026lt;/script\u0026gt;    想多了解 Composition API 可以參考這篇 介紹 Vue3 與 Composition API  ","date":"2022-02-24T00:00:00+08:00","image":"https://bacnotes.github.io/p/vue-todomvc/Dup9I4d_huebbfad1edfa8e198fe68a27ac6a615ca_19543_120x120_fill_q75_box_smart1.jpeg","permalink":"https://bacnotes.github.io/p/vue-todomvc/","title":"用TodoMVC 複習 Vue 跟 Option API｜bacnotes備份筆記"},{"content":"前端驗證時機有三種 當使用者點 submit  等使用者輸入完所有內容再跳出錯誤訊息 沒辦法在輸入完成就告訴使用者有無錯誤，要等到最後，回饋不及時  當 input lose focus  跳到下一個input時再跳出錯誤訊息 回饋即時，但input需紀錄未被點擊過狀態  獲取當前表單輸入值 useState  使用 useState 定義初始值跟 set 新值的函式名稱 觸發事件，使用 event.target.value 捕捉 input 值 適合需要立即驗證、即時捕捉每個 keystroke 的 input  useRef  使用 useRef 綁定指定 DOM input 元素，存在一個變數(通常會命名 xxxRef) 觸發事件，透過綁定的變數.current.value 獲取值 input 初始值可以透過綁定的變數名.current 獲得 適合不用獲取每個 keystroke 輸入的 input  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  import { useRef, useState } from \u0026#34;react\u0026#34;; const SimpleInput = (props) =\u0026gt; { const nameInputRef = useRef(); const [enteredName, setEnteredName] = useState(\u0026#34;\u0026#34;); const nameInputChangeHandler = (event) =\u0026gt; { setEnteredName(event.target.value); }; const formSubmissionHandler = (event) =\u0026gt; { event.preventDefault(); console.log(enteredName); const enteredValue = nameInputRef.current.value; console.log(enteredValue); // nameInputRef.current.value = \u0026#39;\u0026#39;; =\u0026gt; NOT IDEAL, DON\u0026#39;T MANIPULATE THE DOM  setEnteredName(\u0026#34;\u0026#34;); }; return ( \u0026lt;form onSubmit={formSubmissionHandler}\u0026gt; \u0026lt;div className=\u0026#39;form-control\u0026#39;\u0026gt; \u0026lt;label htmlFor=\u0026#39;name\u0026#39;\u0026gt;Your Name\u0026lt;/label\u0026gt; \u0026lt;input ref={nameInputRef} type=\u0026#39;text\u0026#39; id=\u0026#39;name\u0026#39; onChange={nameInputChangeHandler} value={enteredName} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#39;form-actions\u0026#39;\u0026gt; \u0026lt;button\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; ); }; export default SimpleInput;   submit 搭配 keystroke事件 更新表單值驗證  驗證內容為確認表單內容不為空白：trim()完後的結果不為空字串，或 if(! 變數.trim()) 回饋使用者驗證結果：在 input 欄位下方加上 p 的欄位 條件渲染顯示 e.g. 使用 nameInputIsInvalid \u0026amp;\u0026amp; some err msg，加上 invalid 樣式 為了不要太早就呈現出 err msg，多加上一個狀態有無 touched 做判斷 新增變數作為錯誤訊息渲染判斷(nameInputIsInvalid)，當不符合驗證且有 touched 過才會顯示，!enteredNameIsValid \u0026amp;\u0026amp; enteredNameTouched; 下方範例為 useState 獲取表單值  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  import { useState } from \u0026#34;react\u0026#34;; const SimpleInput = (props) =\u0026gt; { // 有新的enteredName就會驗證一次是否空白，re-evaluate(重跑下方函式)  const [enteredName, setEnteredName] = useState(\u0026#34;\u0026#34;); const [enteredNameTouched, setEnteredNameTouched] = useState(false); // 驗證是否為空白  const enteredNameIsValid = enteredName.trim() !== \u0026#34;\u0026#34;; const nameInputIsInvalid = !enteredNameIsValid \u0026amp;\u0026amp; enteredNameTouched; const nameInputChangeHandler = (event) =\u0026gt; { setEnteredName(event.target.value); }; const formSubmissionHandler = (event) =\u0026gt; { event.preventDefault(); // 提交後touched狀態改true  setEnteredNameTouched(true); // 沒過驗證  if (!enteredNameIsValid) { return; } // 過了驗證，還原表格  setEnteredName(\u0026#34;\u0026#34;); setEnteredNameTouched(false); }; const nameInputClasses = nameInputIsInvalid ? \u0026#34;form-control invalid\u0026#34; : \u0026#34;form-control\u0026#34;; return ( \u0026lt;form onSubmit={formSubmissionHandler}\u0026gt; \u0026lt;div className={nameInputClasses}\u0026gt; \u0026lt;label htmlFor=\u0026#39;name\u0026#39;\u0026gt;Your Name\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#39;text\u0026#39; id=\u0026#39;name\u0026#39; onChange={nameInputChangeHandler} value={enteredName} /\u0026gt; {nameInputIsInvalid \u0026amp;\u0026amp; ( \u0026lt;p className=\u0026#39;error-text\u0026#39;\u0026gt;Name must not be empty.\u0026lt;/p\u0026gt; )} \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#39;form-actions\u0026#39;\u0026gt; \u0026lt;button\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; ); }; export default SimpleInput;   提早在 input lose focus(blur) 時觸發 touched  條件渲染錯誤訊息的兩個條件：驗證沒過且 touched 為真 除了 submit 有一個 touched 更新為 true，新增一個 blur 監聽更新 touched 狀態 當 input blur 事件觸發，更新 touched 狀態為 true  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  import { useState } from \u0026#39;react\u0026#39;; const SimpleInput = (props) =\u0026gt; { const [enteredName, setEnteredName] = useState(\u0026#34;\u0026#34;); const [enteredNameTouched, setEnteredNameTouched] = useState(false); const enteredNameIsValid = enteredName.trim() !== \u0026#39;\u0026#39;; const nameInputIsInvalid = !enteredNameIsValid \u0026amp;\u0026amp; enteredNameTouched; const nameInputChangeHandler = (event) =\u0026gt; { setEnteredName(event.target.value); }; // 新增這段 blur即touched過  const nameInputBlurHandler = event =\u0026gt; { setEnteredNameTouched(true); }; ... return ( \u0026lt;form onSubmit={formSubmissionHandler}\u0026gt; \u0026lt;div className={nameInputClasses}\u0026gt; \u0026lt;label htmlFor=\u0026#39;name\u0026#39;\u0026gt;Your Name\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#39;text\u0026#39; id=\u0026#39;name\u0026#39; onChange={nameInputChangeHandler} // blur監聽 onBlur={nameInputBlurHandler} value={enteredName} /\u0026gt; {nameInputIsInvalid \u0026amp;\u0026amp; ( \u0026lt;p className=\u0026#39;error-text\u0026#39;\u0026gt;Name must not be empty.\u0026lt;/p\u0026gt; )} \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#39;form-actions\u0026#39;\u0026gt; \u0026lt;button\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; ); }; export default SimpleInput;   使用 Custom Hook 管理多個元素驗證  一個 input 就寫了這麼多程式碼，那 10 個 input 就\u0026hellip; 使用上篇文章提到的 Custom Hook，創造一個 input Hook 來處理共同邏輯 驗證的邏輯每個 input 可能條件不同，傳入 function 收 input 內容，讓條件彈性化  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  import { useState } from \u0026#34;react\u0026#34;; // 傳入一個validateValue function驗證enteredValue const useInput = (validateValue) =\u0026gt; { const [enteredValue, setEnteredValue] = useState(\u0026#34;\u0026#34;); const [isTouched, setIsTouched] = useState(false); const valueIsValid = validateValue(enteredValue); const hasError = !valueIsValid \u0026amp;\u0026amp; isTouched; const valueChangeHandler = (event) =\u0026gt; { setEnteredValue(event.target.value); }; const inputBlurHandler = (event) =\u0026gt; { setIsTouched(true); }; const reset = () =\u0026gt; { setEnteredValue(\u0026#34;\u0026#34;); setIsTouched(false); }; return { value: enteredValue, isValid: valueIsValid, hasError, valueChangeHandler, inputBlurHandler, reset, }; }; export default useInput;    引用到元件中  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121  import useInput from \u0026#34;../hooks/use-input\u0026#34;; // 驗證邏輯 const isNotEmpty = (value) =\u0026gt; value.trim() !== \u0026#34;\u0026#34;; const isEmail = (value) =\u0026gt; value.includes(\u0026#34;@\u0026#34;); const BasicForm = (props) =\u0026gt; { // 套用custom hook，取新變數名區隔狀態  const { value: firstNameValue, isValid: firstNameIsValid, hasError: firstNameHasError, valueChangeHandler: firstNameChangeHandler, inputBlurHandler: firstNameBlurHandler, reset: resetFirstName, //驗證邏輯  } = useInput(isNotEmpty); const { value: lastNameValue, isValid: lastNameIsValid, hasError: lastNameHasError, valueChangeHandler: lastNameChangeHandler, inputBlurHandler: lastNameBlurHandler, reset: resetLastName, //驗證邏輯  } = useInput(isNotEmpty); const { value: emailValue, isValid: emailIsValid, hasError: emailHasError, valueChangeHandler: emailChangeHandler, inputBlurHandler: emailBlurHandler, reset: resetEmail, //驗證邏輯  } = useInput(isEmail); let formIsValid = false; // 都過了才可以提交  if (firstNameIsValid \u0026amp;\u0026amp; lastNameIsValid \u0026amp;\u0026amp; emailIsValid) { formIsValid = true; } const submitHandler = (event) =\u0026gt; { event.preventDefault(); if (!formIsValid) { return; } console.log(\u0026#34;Submitted!\u0026#34;); console.log(firstNameValue, lastNameValue, emailValue); //提交後還原狀態  resetFirstName(); resetLastName(); resetEmail(); }; // 動態驗證error樣式  const firstNameClasses = firstNameHasError ? \u0026#34;form-control invalid\u0026#34; : \u0026#34;form-control\u0026#34;; const lastNameClasses = lastNameHasError ? \u0026#34;form-control invalid\u0026#34; : \u0026#34;form-control\u0026#34;; const emailClasses = emailHasError ? \u0026#34;form-control invalid\u0026#34; : \u0026#34;form-control\u0026#34;; return ( \u0026lt;form onSubmit={submitHandler}\u0026gt; \u0026lt;div className=\u0026#39;control-group\u0026#39;\u0026gt; \u0026lt;div className={firstNameClasses}\u0026gt; \u0026lt;label htmlFor=\u0026#39;name\u0026#39;\u0026gt;First Name\u0026lt;/label\u0026gt; // value綁定狀態 onChange變更值 onBlur觸發驗證  \u0026lt;input type=\u0026#39;text\u0026#39; id=\u0026#39;name\u0026#39; value={firstNameValue} onChange={firstNameChangeHandler} onBlur={firstNameBlurHandler} /\u0026gt; {firstNameHasError \u0026amp;\u0026amp; ( \u0026lt;p className=\u0026#39;error-text\u0026#39;\u0026gt;Please enter a first name.\u0026lt;/p\u0026gt; )} \u0026lt;/div\u0026gt; \u0026lt;div className={lastNameClasses}\u0026gt; \u0026lt;label htmlFor=\u0026#39;name\u0026#39;\u0026gt;Last Name\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#39;text\u0026#39; id=\u0026#39;name\u0026#39; value={lastNameValue} onChange={lastNameChangeHandler} onBlur={lastNameBlurHandler} /\u0026gt; {lastNameHasError \u0026amp;\u0026amp; ( \u0026lt;p className=\u0026#39;error-text\u0026#39;\u0026gt;Please enter a last name.\u0026lt;/p\u0026gt; )} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className={emailClasses}\u0026gt; \u0026lt;label htmlFor=\u0026#39;name\u0026#39;\u0026gt;E-Mail Address\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#39;text\u0026#39; id=\u0026#39;name\u0026#39; value={emailValue} onChange={emailChangeHandler} onBlur={emailBlurHandler} /\u0026gt; {emailHasError \u0026amp;\u0026amp; ( \u0026lt;p className=\u0026#39;error-text\u0026#39;\u0026gt;Please enter a valid email address.\u0026lt;/p\u0026gt; )} \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#39;form-actions\u0026#39;\u0026gt; \u0026lt;button disabled={!formIsValid}\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; ); }; export default SimpleInput;   ","date":"2022-02-18T00:00:00+08:00","image":"https://bacnotes.github.io/p/react_input_form/pexels-pixabay-261621_hu3d03a01dcc18bc5be0e67db3d8d209a6_2765134_120x120_fill_q75_box_smart1.jpg","permalink":"https://bacnotes.github.io/p/react_input_form/","title":"React 如何處理表單元素｜bacnotes備份筆記"},{"content":"什麼是 Custom Hook?  Hook 是 React 內建的 JavaScript 函式，而 Custom Hook 就是我們自創的 JavaScript 函式，用來複用程式碼邏輯 Custom Hook 邏輯共享，但元件獲取到的變數狀態彼此都是獨立的，不用擔心會互相影響  如何打造 Custom Hook?  在 src 下面創一個 hooks 資料夾，創一個 use 開頭的 js 檔案 e.g. use-counter.js（檔名不一定要 use 開頭，取名 use 開頭是為了方便辨識這是一個 Hook） hook 元件裡面的變數一定要 use 開頭  Hook 使用範例 計數器範例  條件判斷執行邏輯，預設+1，如果參數為 false 則改為-1  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  import { useState, useEffect } from \u0026#34;react\u0026#34;; // 設定 forwards參數，判斷計算邏輯，且相依下方的useEffect const useCounter = (forwards = true) =\u0026gt; { const [counter, setCounter] = useState(0); useEffect(() =\u0026gt; { const interval = setInterval(() =\u0026gt; { if (forwards) { setCounter((prevCounter) =\u0026gt; prevCounter + 1); } else { setCounter((prevCounter) =\u0026gt; prevCounter - 1); } }, 1000); return () =\u0026gt; clearInterval(interval); }, [forwards]); return counter; }; export default useCounter;     在不同元件裡面 counter 狀態不會互相影響，彼此獨立運作，const [counter, setCounter] = useState(0);\n  計數器+元件引用計數器 Hook\n  1 2 3 4 5 6 7 8 9 10  import Card from \u0026#34;./Card\u0026#34;; import useCounter from \u0026#34;../hooks/use-counter\u0026#34;; const ForwardCounter = () =\u0026gt; { // return的counter狀態存到變數  const counter = useCounter(); return \u0026lt;Card\u0026gt;{counter}\u0026lt;/Card\u0026gt;; }; export default ForwardCounter;    計數器-元件引用計數器 Hook  1 2 3 4 5 6 7 8  import { useState, useEffect } from \u0026#34;react\u0026#34;; import Card from \u0026#34;./Card\u0026#34;; const BackwardCounter = () =\u0026gt; { // return的counter狀態存到變數  const counter = useCounter(false); return \u0026lt;Card\u0026gt;{counter}\u0026lt;/Card\u0026gt;; };   http Hook 範例  http 發送請求時，可以使用 hook 針對不同 url 發送 get/post 等請求 requestConfig 用物件包裹發送請求參數(url, method, headers, body 等屬性)，彈性設計參數，可用於各種請求 useCallback 記住 async 記憶體位置，後續放在 dependency 才不會 loop  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  // hook import { useState, useCallback } from \u0026#34;react\u0026#34;; const useHttp = () =\u0026gt; { const [isLoading, setIsLoading] = useState(false); const [error, setError] = useState(null); // 請求參數放於requestConfig物件，元件使用Hook時需要傳入  // applyData參數傳入元件自己的方法，傳入伺服器回傳的data  const sendRequest = useCallback(async (requestConfig, applyData) =\u0026gt; { setIsLoading(true); setError(null); try { const response = await fetch(requestConfig.url, { // 有提供參數則套用參數，沒有提供參數則套用預設值  method: requestConfig.method ? requestConfig.method : \u0026#34;GET\u0026#34;, headers: requestConfig.headers ? requestConfig.headers : {}, body: requestConfig.body ? JSON.stringify(requestConfig.body) : null, }); if (!response.ok) { throw new Error(\u0026#34;Request failed!\u0026#34;); } const data = await response.json(); applyData(data); } catch (err) { setError(err.message || \u0026#34;Something went wrong!\u0026#34;); } setIsLoading(false); }, []); // return isLoading error 的狀態，sendRequest收到的結果  return { isLoading, error, sendRequest, }; }; export default useHttp;    App 元件引用 http Hook load 資料庫的 task 內容  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  // app import React, { useEffect, useState, useCallback } from \u0026#34;react\u0026#34;; import Tasks from \u0026#34;./components/Tasks/Tasks\u0026#34;; import NewTask from \u0026#34;./components/NewTask/NewTask\u0026#34;; import useHttp from \u0026#34;./hooks/use-http\u0026#34;; function App() { const [tasks, setTasks] = useState([]); // 存return的http狀態跟async function到變數  // sendRequest取新函式名為fetchTasks，用來指向下方fetchTasks  const { isLoading, error, sendRequest: fetchTasks } = useHttp(); useEffect(() =\u0026gt; { // 把task放到transformTasks管理  const transformTasks = (tasksObj) =\u0026gt; { const loadedTasks = []; for (const taskKey in tasksObj) { loadedTasks.push({ id: taskKey, text: tasksObj[taskKey].text }); } // 陣列任務更新到狀態  setTasks(loadedTasks); }; // 參數對應的是async(requestConfig, applyData)  fetchTasks( { url: \u0026#34;https://react-http-6b4a6.firebaseio.com/tasks.json\u0026#34; }, transformTasks ); }, [fetchTasks]); const taskAddHandler = (task) =\u0026gt; { setTasks((prevTasks) =\u0026gt; prevTasks.concat(task)); }; return ( \u0026lt;React.Fragment\u0026gt; \u0026lt;NewTask onAddTask={taskAddHandler} /\u0026gt; \u0026lt;Tasks items={tasks} loading={isLoading} error={error} onFetch={fetchTasks} /\u0026gt; \u0026lt;/React.Fragment\u0026gt; ); } export default App;    新增 task 使用 http Hook  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  import Section from \u0026#34;../UI/Section\u0026#34;; import TaskForm from \u0026#34;./TaskForm\u0026#34;; import useHttp from \u0026#34;../../hooks/use-http\u0026#34;; const NewTask = (props) =\u0026gt; { const { isLoading, error, sendRequest: sendTaskRequest } = useHttp(); const createTask = (taskText, taskData) =\u0026gt; { const generatedId = taskData.name; // firebase-specific =\u0026gt; \u0026#34;name\u0026#34; contains generated id  const createdTask = { id: generatedId, text: taskText }; props.onAddTask(createdTask); }; const enterTaskHandler = async (taskText) =\u0026gt; { // 參數對應的是async(requestConfig, applyData)  sendTaskRequest( { url: \u0026#34;https://react-http-6b4a6.firebaseio.com/tasks.json\u0026#34;, method: \u0026#34;POST\u0026#34;, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, }, body: { text: taskText }, }, // 透過bind綁定，第二個參數會變成呼叫這個函式的第一個參數  // this在這裡不重要所以設定null  // 上方taskData等其他的參數還是會傳入，這邊只是先預處理  createTask.bind(null, taskText) ); }; return ( \u0026lt;Section\u0026gt; \u0026lt;TaskForm onEnterTask={enterTaskHandler} loading={isLoading} /\u0026gt; {error \u0026amp;\u0026amp; \u0026lt;p\u0026gt;{error}\u0026lt;/p\u0026gt;} \u0026lt;/Section\u0026gt; ); };   對Custom Hook的應用有興趣的話，可以繼續看Custom Hook在表單上的應用 ","date":"2022-02-14T00:00:00+08:00","image":"https://bacnotes.github.io/p/react-custom-hook/pexels-photo-4792079_huedb1de06238105eb33e5398c8db3f05b_52755_120x120_fill_q75_box_smart1.jpeg","permalink":"https://bacnotes.github.io/p/react-custom-hook/","title":"React 使用Custom Hook複用程式碼邏輯｜bacnotes備份筆記"},{"content":"不會改變原始資料 \u0026lt;\u0026ndash; 參數為值 \u0026ndash;\u0026gt;\nslice()  array.slice([start[, end]]) 跟展開運算子 [\u0026hellip;array]一樣常被用作淺拷貝 回傳一個新陣列物件，為原陣列選擇之 start 至 end（end index 元素不包含在回傳結果）的淺拷貝 可以不傳參數(start 預設 0，end 預設 array.length) 可單傳 start 參數或 start end 都傳 接受負數，slice(2, -1) 代表拷貝陣列中第三個元素至倒數第二個元素  1 2 3 4 5 6 7 8 9 10 11 12 13  const animals = [\u0026#34;ant\u0026#34;, \u0026#34;bison\u0026#34;, \u0026#34;camel\u0026#34;, \u0026#34;duck\u0026#34;, \u0026#34;elephant\u0026#34;]; animals.slice(); // [\u0026#39;ant\u0026#39;, \u0026#39;bison\u0026#39;, \u0026#39;camel\u0026#39;, \u0026#39;duck\u0026#39;, \u0026#39;elephant\u0026#39;]  animals.slice(2); // [\u0026#34;camel\u0026#34;, \u0026#34;duck\u0026#34;, \u0026#34;elephant\u0026#34;]  animals.slice(2, 4); // [\u0026#34;camel\u0026#34;, \u0026#34;duck\u0026#34;]  animals.slice(-2); // [\u0026#34;duck\u0026#34;, \u0026#34;elephant\u0026#34;]   concat()  var newArray = oldArray.concat(value1[, value2[, \u0026hellip;[, valueN]]]) 合併兩個或多個陣列。回傳一個包含呼叫者陣列本身的值，作為代替的是回傳一個新陣列 跟展開運算子[\u0026hellip;arr, \u0026hellip;arr2] 一樣  1 2 3 4 5  const array1 = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]; const array2 = [\u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;]; array1.concat(array2); // [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;]   join()  array.join([separator]) 回傳合併所有陣列元素的字串 separator 為用來隔開陣列中每個元素的字串。如果必要的話，separator 會自動被轉成字串型態。如果未傳入此參數，陣列中的元素將預設用英文逗號（「, 」）隔開。如果 separator 是空字串，合併後，元素間不會有任何字元。 任何 undefined 或 null 的元素都會被視為空字串處理。 假如 arr.length 為 0，將回傳空字串。  1 2 3 4 5  var a = [\u0026#34;Wind\u0026#34;, \u0026#34;Rain\u0026#34;, \u0026#34;Fire\u0026#34;]; a.join(); // \u0026#39;Wind,Rain,Fire\u0026#39; a.join(\u0026#34;\u0026#34;); // \u0026#39;WindRainFire\u0026#39; a.join(\u0026#34;, \u0026#34;); // \u0026#39;Wind, Rain, Fire\u0026#39; a.join(\u0026#34; + \u0026#34;); // \u0026#39;Wind + Rain + Fire\u0026#39;   flat() (IE 沒有支援)  var newArray = arr.flat([depth]); 函數以遞迴方式將特定深度的子陣列重新串接成為一新的陣列 第一個參數為指定巢狀陣列展開的深度，預設為 1 當遭遇空元素時，flat()函數會自動清除陣列中空的元素  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  var arr1 = [1, 2, [3, 4]]; // 巢狀1層 arr1.flat(); // [1, 2, 3, 4]  var arr2 = [1, 2, [3, 4, [5, 6]]]; // 巢狀1層 arr2.flat(); // [1, 2, 3, 4, [5, 6]]  var arr3 = [1, 2, [3, 4, [5, 6]]]; // 巢狀2層 arr3.flat(2); // [1, 2, 3, 4, 5, 6]  // 相加帳戶中所有金額 const accounts = [{ owner: \u0026#34;Jonas Schmedtmann\u0026#34;, movements: [200, 450, -400, 3000, -650, -130, 70, 1300], interestRate: 1.2, // %  pin: 1111, }, { owner: \u0026#34;Jessica Davis\u0026#34;, movements: [5000, 3400, -150, -790, -3210, -1000, 8500, -30], interestRate: 1.5, pin: 2222, }, { owner: \u0026#34;Steven Thomas Williams\u0026#34;, movements: [200, -200, 340, -300, -20, 50, 400, -460], interestRate: 0.7, pin: 3333, }, { owner: \u0026#34;Sarah Smith\u0026#34;, movements: [430, 1000, 700, 50, 90], interestRate: 1, pin: 4444, }, ]; // 不同物件中的某個屬性為陣列，將陣列值丟到一個新陣列 // 攤平陣列中巢狀結構（單層) // 加總 const overallBalance = accounts .map((el) =\u0026gt; el.movements) .flat() .reduce((el, mov) =\u0026gt; el + mov, 0);   flatMap() (IE 沒有支援)  var new_array = arr.flatMap(function callback(currentValue[, index[, array]]) { // return element for new_array }[, thisArg]) 幾乎等同 map().flat()，但比分別調用這兩個方法效能更好  1 2 3 4 5 6  // 不同物件中的某個屬性為陣列，將陣列值丟到一個新陣列 // 攤平陣列中巢狀結構（單層) // 加總 const overallBalance = accounts .flatMap((el) =\u0026gt; el.movements) .reduce((el, mov) =\u0026gt; el + mov, 0);   \u0026lt;\u0026ndash; 參數為 callback \u0026ndash;\u0026gt;\nmap()  var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg]) 把元素丟到函式裡執行，並回傳一個新陣列 callback 可以收三個參數（當前處理元素、當前處理元素 index、正在操作的陣列） 可以用作淺拷貝  1 2 3 4 5 6 7  const array = [1, 4, 9, 16]; // pass a function to map const map = array.map((x) =\u0026gt; x * 2); console.log(map); // [2, 8, 18, 32]   filter()  var newArray = array.filter(callback(element[, index[, array]])[, thisArg]) 回傳通過該函式檢驗之元素所構成的新陣列 callback 可以收三個參數（當前處理元素、當前處理元素 index、正在操作的陣列）  1 2 3 4 5 6 7 8 9 10 11 12 13  const words = [ \u0026#34;spray\u0026#34;, \u0026#34;limit\u0026#34;, \u0026#34;elite\u0026#34;, \u0026#34;exuberant\u0026#34;, \u0026#34;destruction\u0026#34;, \u0026#34;present\u0026#34;, ]; const result = words.filter((word) =\u0026gt; word.length \u0026gt; 6); console.log(result); // [\u0026#34;exuberant\u0026#34;, \u0026#34;destruction\u0026#34;, \u0026#34;present\u0026#34;]   reduce()  array.reduce(callback[accumulator, currentValue, currentIndex, array], initialValue) 迭代到的陣列元素，回傳 accumulator，accumulator 是累加處理結果（累加是邏輯的累加不一定是數值累加） callback 可以收四個參數（accumulator 累加器處理結果、當前處理元素、當前處理元素 index、正在操作的陣列） 若有傳入 initialValue，則由索引 0 之元素開始，若無則自索引 1 之元素開始 空陣列呼叫 reduce() 方法且沒有提供累加器初始值，將會發生錯誤 可以把陣列變成一個計算結果，結果可以是數字/物件各種形式  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  // a is accumulator, b is currentValue  // 累加 const array = [1, 2, 3, 4]; const reducer = (a, b) =\u0026gt; a + b; const added = array.reduce(reducer)); console.log(added) // 6  // 找max最大值 const movements = [200, 450, -400, 3000, -650, -130, 70, 1300] const reducer = (a, b) =\u0026gt; { if (a \u0026gt; b) return a else return b } const maxValue = movements.reduce(reducer) console.log(maxVlue) // 3000  // 攤平巢狀陣列 const array = [ [0, 1], [2, 3], [4, 5] ] const reducer = (a, b) =\u0026gt; a.concat(b) const flattened = array.reduce((reducer), []); console.log(flattened) // [0, 1, 2, 3, 4, 5]  // 計數器 const names = [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;Tiff\u0026#39;, \u0026#39;Bruce\u0026#39;, \u0026#39;Alice\u0026#39;] const reducer = (allNames, name) =\u0026gt; { if (name in allNames) { allNames[name]++; } else { allNames[name] = 1; } return allNames; }, const countedNames = names.reduce(reducer, {}); console.log(countedNames) // { \u0026#39;Alice\u0026#39;: 2, \u0026#39;Bob\u0026#39;: 1, \u0026#39;Tiff\u0026#39;: 1, \u0026#39;Bruce\u0026#39;: 1 }   find()  array.find(callback[, thisArg]) 回傳第一個滿足所提供之測試函式的元素值 查找不到會回傳 undefined callback 可以收三個參數（當前處理函數、當前處理函數 index、正在操作的陣列）  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // 查找含有特定屬性的物件 const accounts = [{ owner: \u0026#34;Jonas Schmedtmann\u0026#34;, movements: [200, 450, -400, 3000, -650, -130, 70, 1300], interestRate: 1.2, // %  pin: 1111, }, { owner: \u0026#34;Jessica Davis\u0026#34;, movements: [5000, 3400, -150, -790, -3210, -1000, 8500, -30], interestRate: 1.5, pin: 2222, }, { owner: \u0026#34;Steven Thomas Williams\u0026#34;, movements: [200, -200, 340, -300, -20, 50, 400, -460], interestRate: 0.7, pin: 3333, }, { owner: \u0026#34;Sarah Smith\u0026#34;, movements: [430, 1000, 700, 50, 90], interestRate: 1, pin: 4444, }, ]; const account = accounts.find((account) =\u0026gt; account.owner === \u0026#34;Jessica Davis\u0026#34;); console.log(account); // 查找數值大於10 const array = [5, 12, 8, 130, 44]; const found = array.find((element) =\u0026gt; element \u0026gt; 10); console.log(found); // 12   findIndex() v.s. indexOf()  array.findIndex(callback[, thisArg]) 回傳第一個滿足所提供之測試函式的元素索引，若找不到會回傳-1 callback 可以收三個參數（當前處理元素、當前處理元素 index、正在操作的陣列） indexOf(element, fromIndex) 也可以搜尋元素索引位置，但參數通常是給一個 primitives 值 findIndex()期望參數為一個 callback，可以處理複雜邏輯  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // 刪除特定筆資料 btnCloseAccount.addEventListener(\u0026#34;click\u0026#34;, (e) =\u0026gt; { e.preventDefault(); const index = accounts.findIndex( (account) =\u0026gt; account.username === currentAccount.username ); accounts.splice(index, 1); }); const array = [5, 12, 8, 130, 44]; const isLargeNumber = (element) =\u0026gt; element \u0026gt; 13; console.log(array.findIndex(isLargeNumber)); // 3   at()  功能類似 find()，array.at(index)等於 array[index] 回傳索引的元素，通常用來取最尾端的元素 允許正整數和負整數。負整數從數組中的最後一項開始倒數 找不到元素回傳 undefined  1 2 3 4 5 6 7 8 9 10 11  const array = [5, 12, 8, 130, 44]; let index = 2; console.log(`index ${index + 1}is ${array.at(index)}`); // \u0026#34;index 2 is 8\u0026#34;  index = -2; console.log(`index ${index + 1}is ${array.at(index)}`); // \u0026#34;index -2 is 130\u0026#34;   some()  arr.some(callback[, thisArg]) some() 測試陣列中是否至少有一個元素，符合該函式條件，回傳結果為 true false callback 可以收三個參數（當前處理元素、當前處理元素 index、正在操作的陣列）  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  const array = [1, 2, 3, 4, 5]; // checks whether an element is even const even = (element) =\u0026gt; element % 2 === 0; console.log(array.some(even)); // true  // 檢查是否有任一存款紀錄 const movements = [200, 450, -400, 3000, -650, -130, 70, 1300]; const anyDeposit = movements.some((mov) =\u0026gt; mov \u0026gt; 0); console.log(anyDeposit); // true  // 借貸條件為，曾存款過且需有一筆存款金額大於等於借貸金額10% 假設借貸30000 需要有一筆大於3000的存款 btnLoan.addEventListener(\u0026#34;click\u0026#34;, function(e) { e.preventDefault(); const amount = Number(inputLoanAmount.value); const condition = (mov) =\u0026gt; mov \u0026gt;= amount * 0.1; if (amount \u0026gt; 0 \u0026amp;\u0026amp; currentAccount.movements.some(condition)) { currentAccount.movements.push(amount); updateUI(currentAccount); } });   every()  arr.every(callback[, thisArg]) every() 方法會測試陣列中的所有元素是否都通過函式條件，回傳結果為 true false callback 可以收三個參數（當前處理元素、當前處理元素 index、正在操作的陣列）  1 2 3 4 5 6  const isBelowThreshold = (currentValue) =\u0026gt; currentValue \u0026lt; 40; const array1 = [1, 30, 39, 29, 10, 13]; console.log(array1.every(isBelowThreshold)); // true   會改變原始資料 push()、pop()、shift()、unshift()可以參考這篇的array 方法\n\u0026lt;– 參數為值 –\u0026gt;\nsplice()  array.splice(start[, deleteCount[, item1[, item2[, \u0026hellip;]]]]) 回傳一個包含被刪除的元素陣列 如果只有一個元素被刪除，依舊是回傳包含一個元素的陣列。若沒有元素被刪除，則會回傳空陣列。 多數時候不在意回傳值而是修改後的陣列資料，可以用來取代陣列某個索引的元素，可以新增元素也可以刪除元素 start 是改動點，若大於陣列長度，起始點為陣列長度。若為負，起始點為-1。複數絕對值大於陣列長度，則起始點為 0 deleteCount 為刪除元素數量 array.splice(-1) 等於 array.pop()  1 2 3 4 5 6 7 8 9 10 11 12 13 14  const months = [\u0026#34;Jan\u0026#34;, \u0026#34;March\u0026#34;, \u0026#34;April\u0026#34;, \u0026#34;June\u0026#34;]; months.splice(1, 0, \u0026#34;Feb\u0026#34;); // 起始點1，刪除0個元素，並插入元素\u0026#39;Feb\u0026#39; // []  console.log(months); // [\u0026#34;Jan\u0026#34;, \u0026#34;Feb\u0026#34;, \u0026#34;March\u0026#34;, \u0026#34;April\u0026#34;, \u0026#34;June\u0026#34;]  months.splice(4, 1, \u0026#34;May\u0026#34;); // 作為取代方法，起始點4 刪除1元素 並插入元素\u0026#39;May\u0026#39; // [ \u0026#39;June\u0026#39; ]  console.log(months); // [\u0026#34;Jan\u0026#34;, \u0026#34;Feb\u0026#34;, \u0026#34;March\u0026#34;, \u0026#34;April\u0026#34;, \u0026#34;May\u0026#34;]   reverse()  array.reverse() 回傳反轉後的陣列  1 2 3 4  const array = [\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;]; array.reverse(); // [\u0026#34;three\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;one\u0026#34;]   \u0026lt;\u0026ndash; 參數為 callback \u0026ndash;\u0026gt;\nsort()  arr.sort([compareFunction]) 對一個陣列的所有元素進行排序，並回傳此陣列。排序不一定是穩定的（stable） 由於依賴執行環境的實作，所以並不能保證排序的時間及空間複雜度 預設的排序順序是根據字串的 Unicode 編碼位置（code points）而定，可以用第一個參數 compareFunction(a, b)自定義比較邏輯  1 2 3 4 5 6 7 8 9 10  function compare(a, b) { if (在某排序標準下 a 小於 b) { return -1; } if (在某排序標準下 a 大於 b) { return 1; } // a 必須等於 b  return 0; }    若 compareFunction(a, b) 的回傳值小於 0，則會把 a 排在小於 b 之索引的位置，即 a 排在 b 前面。  1 2  // 若 a 小於 b ，a - b \u0026lt; 0 a會被丟到前面，由小排到大 movements.sort((a, b) =\u0026gt; a - b);    若 compareFunction(a, b) 的回傳值大於 0，則會把 b 排在小於 a 之索引的位置，即 b 排在 a 前面。  1 2  // 若 a 大於 b ，b - a \u0026lt; 0，a會被丟到後面，由大排到小 movements.sort((a, b) =\u0026gt; b - a);    若 compareFunction(a, b) 回傳 0，則 a 與 b 皆不會改變彼此的順序，但會與其他全部的元素比較來排序。備註：ECMAscript 標準並不保證這個行為，因此不是所有瀏覽器（如 Mozilla 版本在 2003 以前）都遵守此行為。 compareFunction(a, b) 在給予一組特定元素 a 及 b 為此函數之兩引數時必須總是回傳相同的值。若回傳值不一致，排序順序則為 undefined。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 展示的function const displayMovements = function(movements, sort = false) { // 有要sort才會使用排序後資料(copy資料)  const movs = sort ? movements.slice().sort((a, b) =\u0026gt; a - b) : movements movs.forEach( ...render function ) } let sorted = false btnSort.addEventListener(\u0026#39;click\u0026#39;, function(e) { e.preventDefault() // 改變畫面  displayMovements(currentAccount.movements, !sorted) // 更新狀態  sorted = !sorted })   針對每個元素處理  原始資料可改可不改，看函式邏輯 可以只迭代 render 在畫面上，也可修改資料 e.g. 新增物件屬性等  forEach()  array.forEach(callback(currentValue [, index [, array]])[, thisArg]) 對每個陣列內的元素執行一次函式的內容，不會回傳執行結果，但可以修改原來的陣列 callback 可以收三個參數（當前處理元素、當前處理元素 index、正在操作的陣列） forEach 無法從迴圈跳出，會執行完畢  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // 交易紀錄 const array = [100, 300, -250, 200, 300, -20, 50, -100]; array.forEach((el, index, array) =\u0026gt; { if (el \u0026gt; 0) { console.log(`${index + 1}: you deposited ${el}dollars`); } else { console.log(`${index + 1}: you withdrew ${Math.abs(el)}dollars`); } }); // 等於之前的for of 搭配array.entries()同時取出index(key) value for (const [index, el] of array.entries()) { if (el \u0026gt; 0) { console.log(`${index + 1}: you deposited ${el}dollars`); } else { console.log(`${index + 1}: you withdrew ${Math.abs(el)}dollars`); } } // 0: you deposited 100 dollars // 1: you deposited 300 dollars // 2: you withdrew 250 dollars // 3: you deposited 200 dollars // 4: you deposited 300 dollars // 5: you withdrew 20 dollars // 6: you deposited 50 dollars // 7: you withdrew 100 dollars    forEach 用在 set 跟 map  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // set const currenciesUnique = new Set([\u0026#34;USD\u0026#34;, \u0026#34;EUR\u0026#34;, \u0026#34;GBP\u0026#34;]); currenciesUnique.forEach((el, _, map) =\u0026gt; { console.log(`${el}: ${el}`); }); // USD: USD // EUR: EUR // GBP: GBP  // map const currencies = new Map([ [\u0026#34;USD\u0026#34;, \u0026#34;United States dollar\u0026#34;], [\u0026#34;EUR\u0026#34;, \u0026#34;Euro\u0026#34;], [\u0026#34;GBP\u0026#34;, \u0026#34;Pound sterling\u0026#34;], ]); currencies.forEach((el, index, map) =\u0026gt; { console.log(`${index + 1}: ${el}`); }); // USD: United States dollar // EUR: Euro // GBP: Pound sterling    增加物件屬性  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  const accounts = [{ owner: \u0026#34;Jonas Schmedtmann\u0026#34;, movements: [200, 450, -400, 3000, -650, -130, 70, 1300], interestRate: 1.2, // %  pin: 1111, }, { owner: \u0026#34;Jessica Davis\u0026#34;, movements: [5000, 3400, -150, -790, -3210, -1000, 8500, -30], interestRate: 1.5, pin: 2222, }, { owner: \u0026#34;Steven Thomas Williams\u0026#34;, movements: [200, -200, 340, -300, -20, 50, 400, -460], interestRate: 0.7, pin: 3333, }, { owner: \u0026#34;Sarah Smith\u0026#34;, movements: [430, 1000, 700, 50, 90], interestRate: 1, pin: 4444, }, ]; const createUsernames = (array) =\u0026gt; { array.forEach((account) =\u0026gt; { accounts.username = acc.owner .toLowerCase() .split(\u0026#34; \u0026#34;) .map((name) =\u0026gt; name[0]) .join(\u0026#34;\u0026#34;); }); };   產生 Array 跟注入元素方法 new Array()  陽春版手動放陣列元素  1  const arr = new Array(1, 2, 3);   new Array，搭配 fill() 注入元素  fill() 方法會將陣列中索引的第一個到最後一個的每個位置全部填入一個靜態的值 arr.fill(value[, start[, end]])，start 預設 0，end 預設陣列長 元素區間為 [start, end)，意即包含 start 但不包含 end  1 2 3 4 5 6 7 8 9  const arr = new Array(7); // [ \u0026lt;7 empty items\u0026gt; ] arr.fill(1); // [1, 1, 1, 1, 1, 1, 1]  const arr2 = new Array(7); arr2.fill(1, 3, 5); // index 3開始到 index 4 注入元素1 //[ \u0026lt;3 empty items\u0026gt;, 1, 1, \u0026lt;2 empty items\u0026gt; ]   Array.from()  Array.from() 方法會從類陣列（array-like）或是可迭代（iterable）物件建立一個新的 Array 實體 第一個參數是 arrayLike 將類陣列或可迭代物件轉換成陣列 第二個參數是 Map 函式迭代陣列中的每一個元素 第三個參數是函式執行時的 this 對象  1 2 3 4 5 6 7 8 9 10 11 12 13  const y = Array.from({ length: 7 }, () =\u0026gt; 1); console.log(y); // [1,1,1,1,1,1,1]  const z = Array.from({ length: 7 }, (_, i) =\u0026gt; i + 1); // [1,2,3,4,5,6,7]  console.log(Array.from(\u0026#34;foo\u0026#34;)); // Array [\u0026#34;f\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;o\u0026#34;]    querySelectorAll 選到的 nodeList 可以先用 Array.from 方法轉陣列  1 2 3 4 5 6 7 8  // 選取需要的div元素，取出textContent labelBalance.addEventListener(\u0026#39;click\u0026#39;, function() =\u0026gt; { const movementsUI = Array.from( document.querySelectorAll(\u0026#39;.movements__value\u0026#39;), el =\u0026gt; Number(el.textContent.replace(\u0026#39;€\u0026#39;, \u0026#39;\u0026#39;)) console.log(movementsUI) const movementsUI2 = [...document.querySelectorAll(\u0026#39;.movements__value\u0026#39;)] ) })   小練習  slice concat forEach  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 寫一個\u0026#39;checkDogs\u0026#39; 功能 收兩個陣列參數，依序列印第幾隻狗夠是成年或幼年/幾歲 //TEST DATA 1: Julia\u0026#39;s data [3, 5, 2, 12, 7], Kate\u0026#39;s data [4, 1, 15, 8, 3]  //TEST DATA 2: Julia\u0026#39;s data [9, 16, 6, 8, 3], Kate\u0026#39;s data [10, 5, 6, 1, 4] const checkDogs = function(arr1, arr2) { // [...arr1]  // 排除第一個跟最後兩筆錯誤資料  dogsJulia = arr1.slice(1, 4); dogsKate = arr2.slice(); // 合併兩組陣列  allDogs = dogsJulia.concat(dogsKate); // console文字 大於等於3算adult 小於算puppy  allDogs.forEach((el, index) =\u0026gt; { const dogType = el \u0026gt;= 3 ? \u0026#34;adult\u0026#34; : \u0026#34;puppy\u0026#34;; console.log(`Dog ${index + 1}is an ${dogType}and is ${el}years old`); }); };    map filter reduce  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // TEST DATA 1: [5, 2, 4, 1, 15, 8, 3] // TEST DATA 2: [16, 6, 10, 5, 6, 1, 4]  // 寫一個calcAverageHumanAge 換算成平均人類年齡  const calcAverageHumanAge = function(ages) { // 狗狗年齡換算人類邏輯 若\u0026lt;=2 直接*2; 若\u0026gt;2 初始值16 + 年齡*4  const humanAges = ages .map((age) =\u0026gt; (age \u0026lt;= 2 ? age * 2 : 16 + age * 4)) .filter((age) =\u0026gt; age \u0026gt;= 18); // 排除換算年齡小於18的狗狗  .reduce((sum, age, i, arr) =\u0026gt; sum + age / arr.length, 0) // 狗狗換算平均年齡  // 下方reduce若沒有設定初始值 結果會有錯  // const avg = adults.reduce((sum, age, i, arr) =\u0026gt; sum + age / arr.length, 0)  // 2 3. (2+3)/2 = 2.5 === 2/2+3/2 = 2.5  return avg; }; calcAverageHumanAge([5, 2, 4, 1, 15, 8, 3]);    綜合練習 三元運算子算是兩行，不會隱含 return count++ 跟 ++count 差異  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106  // challenge #3 // data const account1 = { owner: \u0026#34;Jonas Schmedtmann\u0026#34;, movements: [200, 450, -400, 3000, -650, -130, 70, 1300], interestRate: 1.2, // %  pin: 1111, }; const account2 = { owner: \u0026#34;Jessica Davis\u0026#34;, movements: [5000, 3400, -150, -790, -3210, -1000, 8500, -30], interestRate: 1.5, pin: 2222, }; const account3 = { owner: \u0026#34;Steven Thomas Williams\u0026#34;, movements: [200, -200, 340, -300, -20, 50, 400, -460], interestRate: 0.7, pin: 3333, }; const account4 = { owner: \u0026#34;Sarah Smith\u0026#34;, movements: [430, 1000, 700, 50, 90], interestRate: 1, pin: 4444, }; const accounts = [account1, account2, account3, account4]; // 1-1 所有帳戶存款紀錄加總 map flat const overAllBalance = accounts .map((el) =\u0026gt; el.movements) .flat() // 變成一維陣列  .filter((el) =\u0026gt; el \u0026gt; 0) .reduce((sum, el) =\u0026gt; sum + el); console.log(overAllBalance); // 1-2 所有帳戶存款紀錄加總 flatMap const overAllBalance = accounts .flatMap((el) =\u0026gt; el.movements) // 變成一維陣列  .filter((el) =\u0026gt; el \u0026gt; 0) .reduce((sum, el) =\u0026gt; sum + el); console.log(overAllBalance); // 25180  // 2 大於1000存款記錄有幾筆 // reduce 第二個參數為初始值 複習計數器用法 // sum++先return 再+ ; ++sum 先+再return const numDeposit1000 = accounts .flatMap((el) =\u0026gt; el.movements) // 如果寫sum++ 每次都先return 0 給accumulator 再+1 累加結果就永遠是0  .reduce((count, el) =\u0026gt; (el \u0026gt; 1000 ? ++count : count), 0); console.log(numDeposit1000); // 5  // 3 reduce 回傳結果為{存款記錄筆數: 提款記錄筆數:}  const balanceCounter = accounts .flatMap((el) =\u0026gt; el.movements) // 如果寫sum++ 每次都先return 0 給accumulator 再+1 累加結果就永遠是0  .reduce( (sums, el) =\u0026gt; { el \u0026gt; 0 ? (sums.deposits += el) : (sums.withdraws += el); // 這邊有+= 運算 非單行 記得加return  return sums; }, { deposits: 0, withdraws: 0 } ); console.log(balanceCounter); // {deposits: 25180, withdraws: -7340}  // 更簡潔的寫法  const balanceCounter = accounts .flatMap((el) =\u0026gt; el.movements) // 如果寫sum++ 每次都先return 0 給accumulator 再+1 累加結果就永遠是0  .reduce( (sums, el) =\u0026gt; { sums[el \u0026gt; 0 ? \u0026#34;deposits\u0026#34; : \u0026#34;withdraws\u0026#34;] += el; return sums; }, { deposits: 0, withdraws: 0 } ); console.log(balanceCounter); // 4. 格式轉換器 this is a nice title -\u0026gt; This Is a Nice Title // array.includes(element) const covertTitleCase = function(title) { const exceptions = [\u0026#34;a\u0026#34;, \u0026#34;an\u0026#34;, \u0026#34;and\u0026#34;, \u0026#34;the\u0026#34;, \u0026#34;but\u0026#34;, \u0026#34;or\u0026#34;, \u0026#34;on\u0026#34;, \u0026#34;in\u0026#34;, \u0026#34;with\u0026#34;]; const titleCase = title .toLowerCase() .split(\u0026#34; \u0026#34;) .map((word) =\u0026gt; exceptions.includes(word) ? word : word[0].toUpperCase() + word.slice(1) ) .join(\u0026#34; \u0026#34;); return titleCase; }; //    綜合練習2  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  // challenge #4 // TEST DATA: // const dogs = [ // { weight: 22, curFood: 250, owners: [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;] }, // { weight: 8, curFood: 200, owners: [\u0026#39;Matilda\u0026#39;] }, // { weight: 13, curFood: 275, owners: [\u0026#39;Sarah\u0026#39;, \u0026#39;John\u0026#39;] }, // { weight: 32, curFood: 340, owners: [\u0026#39;Michael\u0026#39;] } // ];  // 1. calculate the recommended food portion and add it to the object as a new property. Do NOT create a new array, simply loop over the array. Forumla: recommendedFood = weight ** 0.75 * 28. (The result is in grams of food, and the weight needs to be in kg)  // 2. Find Sarah\u0026#39;s dog and log to the console whether it\u0026#39;s eating too much or too little. HINT: Some dogs have multiple owners, so you first need to find Sarah in the owners array, and so this one is a bit tricky (on purpose)  // 3. Create an array containing all owners of dogs who eat too much (\u0026#39;ownersEatTooMuch\u0026#39;) and an array with all owners of dogs who eat too little (\u0026#39;ownersEatTooLittle\u0026#39;).  // 4. Log a string to the console for each array created in 3., like this: \u0026#34;Matilda and Alice and Bob\u0026#39;s dogs eat too much!\u0026#34; and \u0026#34;Sarah and John and Michael\u0026#39;s dogs eat too little!\u0026#34;  // 5. Log to the console whether there is any dog eating EXACTLY the amount of food that is recommended (just true or false)  // 6. Log to the console whether there is any dog eating an OKAY amount of food (just true or false)  // 7. Create an array containing the dogs that are eating an OKAY amount of food (try to reuse the condition used in 6.)  // 8. Create a shallow copy of the dogs array and sort it by recommended food portion in an ascending order (keep in mind that the portions are inside the array\u0026#39;s objects)   ","date":"2022-02-11T00:00:00+08:00","image":"https://bacnotes.github.io/p/array-methods/pexels-photo-7988086_hu32d02208a7a23794672f78ec0a2370e0_145353_120x120_fill_q75_box_smart1.jpeg","permalink":"https://bacnotes.github.io/p/array-methods/","title":"陣列的處理方法｜bacnotes備份筆記"},{"content":"React 如何與資料庫互動  React 會透過 Backend APP 來存取資料庫 由於前端的程式碼透過 devtool 很容易被看光光，直接由前端 APP 存取資料庫等於曝光了資料庫的讀寫入口 因此前後端分離，前端透過 API 串接後端資料，除了考量到程式之間的關注點分離外，安全性也比較高  使用 fetch API 接收資料  fetch API 是瀏覽器內建的 API，可以發送 Http 請求或接收 Http 回應 搭配 Response.json()方法  1 2 3  response.json().then((data) =\u0026gt; { // do something with your data });   使用 Promise, then 接收 Data 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  function App() { const [movies, setMovies] = useState([]); function fetchMoviesHandler() { // fetch預設為get所以不用寫method  fetch(\u0026#34;https://swapi.dev/api/films/\u0026#34;) .then((response) =\u0026gt; { // 使用Response.json()把response body 轉成JavaScript物件並返回一個Promise  return response.json(); }) // Promise需要用then接住 並使用data來抓取裡面的資料  .then((data) =\u0026gt; { // 這邊把[{}, {}, {}]物件資料用map迭代取出，map返回一個新陣列  const transformedMovies = data.results.map((movieData) =\u0026gt; { // 物件key設定成component裡面的名字（因資料庫欄位名不一定對應）  return { id: movieData.episode_id, title: movieData.title, openingText: movieData.opening_crawl, releaseDate: movieData.release_date, }; }); setMovies(transformedMovies); }); } return ( \u0026lt;React.Fragment\u0026gt; \u0026lt;section\u0026gt; \u0026lt;button onClick={fetchMoviesHandler}\u0026gt;Fetch Movies\u0026lt;/button\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section\u0026gt; \u0026lt;MoviesList movies={movies} /\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/React.Fragment\u0026gt; ); } export default App;   改寫為 async await 加上錯誤處理  搭配 try catch 加上 Loading Fetch API doesn\u0026rsquo;t 不會把錯誤狀態代碼 404 視為錯誤，只要有成功回傳就會 200 所以我們可以自己加一段判斷在 try 裡面 當 Response 有問題拋出錯誤 if (!response.ok \u0026amp;\u0026amp; response.status !== 200) error 記得也要用 useState 控制  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  function App() { const [movies, setMovies] = useState([]); const [isLoading, setIsLoading] = useState(false); const [error, setError] = useState(null); async function fetchMoviesHandler() { setIsLoading(true); try { // fetch預設為get所以不用寫method  const response = await fetch(\u0026#34;https://swapi.dev/api/films/\u0026#34;); // The method returns a promise, so you have to wait for the JSON  if (!response.ok \u0026amp;\u0026amp; response.status !== 200) { throw new Error(\u0026#34;Something went wrong\u0026#34;); } const data = await response.json(); const transformedMovies = data.results.map((movieData) =\u0026gt; { return { id: movieData.episode_id, title: movieData.title, openingText: movieData.opening_crawl, releaseDate: movieData.release_date, }; }); setMovies(transformedMovies); } catch (error) { setIsLoading(false); setError(error.message); } setIsLoading(false); } return ( \u0026lt;React.Fragment\u0026gt; \u0026lt;section\u0026gt; \u0026lt;button onClick={fetchMoviesHandler}\u0026gt;Fetch Movies\u0026lt;/button\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section\u0026gt; // 沒在Loading且有資料顯示MovieList  {!isLoading \u0026amp;\u0026amp; movies.length \u0026gt; 0 \u0026amp;\u0026amp; \u0026lt;MoviesList movies={movies} /\u0026gt;} // 沒在Loading且無資料顯示沒找到電影  {!isLoading \u0026amp;\u0026amp; movies.length === 0 \u0026amp;\u0026amp; !error \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Found no movies.\u0026lt;/p\u0026gt;} {!isLoading \u0026amp;\u0026amp; error \u0026amp;\u0026amp; \u0026lt;p\u0026gt;{error}\u0026lt;/p\u0026gt;} {isLoading \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Loading...\u0026lt;/p\u0026gt;} \u0026lt;/section\u0026gt; \u0026lt;/React.Fragment\u0026gt; ); }    重構一下程式碼，把 render 的 JSX 變單純一點  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  function App() { const [movies, setMovies] = useState([]); const [isLoading, setIsLoading] = useState(false); const [error, setError] = useState(null); const fetchMoviesHandler = useCallback(async () =\u0026gt; { setIsLoading(true); setError(null); try { const response = await fetch(\u0026#34;https://swapi.dev/api/films/\u0026#34;); if (!response.ok) { throw new Error(\u0026#34;Something went wrong!\u0026#34;); } const data = await response.json(); const transformedMovies = data.results.map((movieData) =\u0026gt; { return { id: movieData.episode_id, title: movieData.title, openingText: movieData.opening_crawl, releaseDate: movieData.release_date, }; }); setMovies(transformedMovies); } catch (error) { setError(error.message); } setIsLoading(false); }, []); let content = \u0026lt;p\u0026gt;Found no movies.\u0026lt;/p\u0026gt;; if (movies.length \u0026gt; 0) { content = \u0026lt;MoviesList movies={movies} /\u0026gt;; } if (error) { content = \u0026lt;p\u0026gt;{error}\u0026lt;/p\u0026gt;; } if (isLoading) { content = \u0026lt;p\u0026gt;Loading...\u0026lt;/p\u0026gt;; } return ( \u0026lt;React.Fragment\u0026gt; \u0026lt;section\u0026gt; \u0026lt;button onClick={fetchMoviesHandler}\u0026gt;Fetch Movies\u0026lt;/button\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section\u0026gt;{content}\u0026lt;/section\u0026gt; \u0026lt;/React.Fragment\u0026gt; ); }   使用 useEffect 管理 fetch 方法  如果 fetch 方法只需要在渲染元件時執行一次，放在 useEffect 中不讓 re-render 重跑 fetch 即可 但若 fetch 方法會跟其他元件一起使用(e.g. 點按鈕也會重拉資料)，則需放到 useEffect 外，用 useCallback 包裹存成變數(記住記憶體位置)，把再變數放到 useEffect 的 dependencies 中 不然點下去按鈕，重新渲染 APP 元件時，函式記憶體位置也會改變，等於 useEffect 的相依參數有更新[fetchMoviesHandler]，再次執行 useEffect，陷入無限無圈  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  function App() { const [movies, setMovies] = useState([]); const [isLoading, setIsLoading] = useState(false); const [error, setError] = useState(null); // 使用useCallback 記住物件記憶體位置  const fetchMoviesHandler = useCallback(async () =\u0026gt; { setIsLoading(true); setError(null); try { const response = await fetch(\u0026#34;https://swapi.dev/api/films/\u0026#34;); // 也可以只寫一個，但這樣寫比較安全  if (!response.ok \u0026amp;\u0026amp; response.status !== 200) { throw new Error(\u0026#34;Something went wrong!\u0026#34;); } const data = await response.json(); const transformedMovies = data.results.map((movieData) =\u0026gt; { return { id: movieData.episode_id, title: movieData.title, openingText: movieData.opening_crawl, releaseDate: movieData.release_date, }; }); setMovies(transformedMovies); } catch (error) { setError(error.message); } setIsLoading(false); }, []); // 只希望在一開始執行一次，後續fetchMoviesHandler被呼叫會再執行，若fetchMoviesHandler有變(點按鈕)才會執行  useEffect(() =\u0026gt; { fetchMoviesHandler(); }, [fetchMoviesHandler]); let content = \u0026lt;p\u0026gt;Found no movies.\u0026lt;/p\u0026gt;; if (movies.length \u0026gt; 0) { content = \u0026lt;MoviesList movies={movies} /\u0026gt;; } if (error) { content = \u0026lt;p\u0026gt;{error}\u0026lt;/p\u0026gt;; } if (isLoading) { content = \u0026lt;p\u0026gt;Loading...\u0026lt;/p\u0026gt;; } return ( \u0026lt;React.Fragment\u0026gt; \u0026lt;section\u0026gt; \u0026lt;button onClick={fetchMoviesHandler}\u0026gt;Fetch Movies\u0026lt;/button\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section\u0026gt;{content}\u0026lt;/section\u0026gt; \u0026lt;/React.Fragment\u0026gt; ); } export default App;   使用 firebase 作為 backend APP  才能夠看到實際來回傳遞資料互動 發送請求使用 addMovieHandler(movie) 接收請求使用 fetchMoviesHandler  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91  function App() { const [movies, setMovies] = useState([]); const [isLoading, setIsLoading] = useState(false); const [error, setError] = useState(null); const fetchMoviesHandler = useCallback(async () =\u0026gt; { setIsLoading(true); setError(null); try { // fetch接收資料的網址也改為firebase，但收到的資料結構會有變  const response = await fetch( \u0026#34;https://react-http-6b4a6.firebaseio.com/movies.json\u0026#34; ); if (!response.ok) { throw new Error(\u0026#34;Something went wrong!\u0026#34;); } const data = await response.json(); // 新的資料結構uid{屬性1:值, 屬性2:值...}  console.log(data); const loadedMovies = []; // loop所有uid(key)  for (const key in data) { loadedMovies.push({ id: key, title: data[key].title, openingText: data[key].openingText, releaseDate: data[key].releaseDate, }); } setMovies(loadedMovies); } catch (error) { setError(error.message); } setIsLoading(false); }, []); useEffect(() =\u0026gt; { fetchMoviesHandler(); }, [fetchMoviesHandler]); async function addMovieHandler(movie) { // firebase 發送請求網址最後需要加上.json 不然會失敗  // movies為儲存的資料表  const response = await fetch( \u0026#34;https://react-http-6b4a6.firebaseio.com/movies.json\u0026#34;, { method: \u0026#34;POST\u0026#34;, // 表單物件轉JSON資料格式  body: JSON.stringify(movie), // 非必要，但對某些restAPI可能需要這個欄位  headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, }, } ); const data = await response.json(); console.log(data); // 這邊先不處理錯誤 專注於post程式碼  } let content = \u0026lt;p\u0026gt;Found no movies.\u0026lt;/p\u0026gt;; if (movies.length \u0026gt; 0) { content = \u0026lt;MoviesList movies={movies} /\u0026gt;; } if (error) { content = \u0026lt;p\u0026gt;{error}\u0026lt;/p\u0026gt;; } if (isLoading) { content = \u0026lt;p\u0026gt;Loading...\u0026lt;/p\u0026gt;; } return ( \u0026lt;React.Fragment\u0026gt; \u0026lt;section\u0026gt; \u0026lt;AddMovie onAddMovie={addMovieHandler} /\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section\u0026gt; \u0026lt;button onClick={fetchMoviesHandler}\u0026gt;Fetch Movies\u0026lt;/button\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section\u0026gt;{content}\u0026lt;/section\u0026gt; \u0026lt;/React.Fragment\u0026gt; ); } export default App;   伺服器回傳狀態代碼 ​​- 瀏覽器會根據 HTTP Status code 判斷目前跟伺服器溝通狀態為何\n 2xx 成功 3xx 重新導向 4xx 客戶端錯誤 5xx 伺服器錯誤 詳細可以看 POY 大整理的HTTP 狀態碼一覽表  補充：REST APIs vs GraphQL APIs 相同處  傳輸 json 格式資料或其他格式資料 沒有限制前後端的語言或框架 都是無狀態  差異  多個 Endpoint v.s. 單個 Endpoint 多個方法 Get/Post/Patch/Put/Delete v.s. 單個方法 Post Post/user{name: \u0026lsquo;Max\u0026rsquo;} v.s. Post/graphql{query: \u0026lsquo;query\u0026rsquo;} (Http Verb/Path{Body}) (Http Verb/Path{Body}) 資料範圍限制較少 v.s. 容易限制資料範圍  ","date":"2022-02-07T00:00:00+08:00","image":"https://bacnotes.github.io/p/react-with-database/pexels-panumas-nikhomkhai-1148820_hu3d03a01dcc18bc5be0e67db3d8d209a6_2340096_120x120_fill_q75_box_smart1.jpg","permalink":"https://bacnotes.github.io/p/react-with-database/","title":"React 如何與遠端資料庫互動｜bacnotes備份筆記"},{"content":"Class Component 是什麼  16.8 版本以前處理 State 跟 Side Effect 會需要使用 Class Component，後來有 Hook 就可以只寫 Function Component（寫起來相對單純) 使用 JavaScript 的 Class，定義要 render 的 JSX，React 會在適當時機點渲染 可以跟 Function Component 一起使用 render 方法不會讀取 props，而是透過引入 react 的 Component 拿到 Props  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // class component import { Component } from \u0026#34;react\u0026#34;; // 繼承Component的方法，拿到本身元件props屬性的資料 class User extends Component { // 使用this.props拿到所有props的資料  render() { return \u0026lt;li className={classes.user}\u0026gt;{this.props.name}\u0026lt;/li\u0026gt;; } } // function component // props做為參數傳入 const User = (props) =\u0026gt; { return \u0026lt;li className={classes.user}\u0026gt;{props.name}\u0026lt;/li\u0026gt;; };   使用 class Component 管理狀態  一樣需要定義狀態跟初始化 state 使用 constructor 定義 this.state，= 後面要是一個物件 functional component 的 state 定義則是任意資料，useState(null) 一樣不能用 this.state. 變數 = 值直接修改資料，必須用 setState(物件) 改寫一段 Function Component Code  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  import { Component } from \u0026#34;react\u0026#34;; import User from \u0026#34;./User\u0026#34;; const DUMMY_USERS = [ { id: \u0026#34;u1\u0026#34;, name: \u0026#34;Max\u0026#34; }, { id: \u0026#34;u2\u0026#34;, name: \u0026#34;Manuel\u0026#34; }, { id: \u0026#34;u3\u0026#34;, name: \u0026#34;Julie\u0026#34; }, ]; class Users extends Component { // super 是父層的建構函式，用來調用父層  // 必須出現在this 關鍵字之前使用  constructor() { super(); this.state = { showUsers: true, more: \u0026#34;Test\u0026#34;, }; } // 使用this.setState更新狀態，沒有寫到state其他的屬性沒關係，同樣狀況在useState就會有問題  toggleUsersHandler() { // this.state.showUsers = false;  this.setState((curState) =\u0026gt; { // class Component只會更新下方提到的的屬性，useState則會全部屬性都覆寫  return { showUsers: !curState.showUsers }; }); } render() { const usersList = ( \u0026lt;ul\u0026gt; {DUMMY_USERS.map((user) =\u0026gt; ( \u0026lt;User key={user.id} name={user.name} /\u0026gt; ))} \u0026lt;/ul\u0026gt; ); return ( \u0026lt;div className={classes.users}\u0026gt; \u0026lt;button onClick={this.toggleUsersHandler}\u0026gt; {this.state.showUsers ? \u0026#34;Hide\u0026#34; : \u0026#34;Show\u0026#34;} Users \u0026lt;/button\u0026gt; {this.state.showUsers \u0026amp;\u0026amp; usersList} \u0026lt;/div\u0026gt; ); } } // Function Component Code // const Users = () =\u0026gt; { // const [showUsers, setShowUsers] = useState(true);  // const toggleUsersHandler = () =\u0026gt; { // setShowUsers((curState) =\u0026gt; !curState); // };  // const usersList = ( // \u0026lt;ul\u0026gt; // {DUMMY_USERS.map((user) =\u0026gt; ( // \u0026lt;User key={user.id} name={user.name} /\u0026gt; // ))} // \u0026lt;/ul\u0026gt; // );  // return ( // \u0026lt;div className={classes.users}\u0026gt; // \u0026lt;button onClick={toggleUsersHandler}\u0026gt; // {showUsers ? \u0026#39;Hide\u0026#39; : \u0026#39;Show\u0026#39;} Users // \u0026lt;/button\u0026gt; // {showUsers \u0026amp;\u0026amp; usersList} // \u0026lt;/div\u0026gt; // ); // };  export default Users;   使用 class Component 處理 side Effect 先了解 React 重要的生命週期 componentDidMount()\n 在 evaluate 且渲染完後，只會在 mount 元件時呼叫一次，更新資料 re-render 不會，類似 useEffect(()=\u0026gt;{}, [])  componentDidUpdate()\n 當元件更新狀態或 Props 會呼叫，類似 useEffect(()=\u0026gt;{}, [參數])  componentWillUnmount()\n 當元件被銷毀，從真實 DOM 拿掉，類似 cleanup useEffect(()=\u0026gt;{}, [])  以一個搜尋元件來當範例，會依照不同字詞出現不同使用者清單  一樣需要 import Component，初始化 state 有兩個狀態需要管理，搜尋字詞跟使用者清單  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  import { Fragment, useState, useEffect, Component } from \u0026#34;react\u0026#34;; import Users from \u0026#34;./Users\u0026#34;; const DUMMY_USERS = [ { id: \u0026#34;u1\u0026#34;, name: \u0026#34;Max\u0026#34; }, { id: \u0026#34;u2\u0026#34;, name: \u0026#34;Manuel\u0026#34; }, { id: \u0026#34;u3\u0026#34;, name: \u0026#34;Julie\u0026#34; }, ]; class UserFinder extends Component { constructor() { super(); this.state = { filteredUsers: [], searchTerm: \u0026#34;\u0026#34;, }; } // 只會執行一次  componentDidMount() { // Send http request...假想是從資料庫獲取DUMMY_USERS  this.setState({ filteredUsers: DUMMY_USERS }); } // 更新狀態  componentDidUpdate(prevProps, prevState) { // 需要加上判斷是否有變類似之前的callback  // 不然一樣因為資料更新，重新渲染，再次觸發資料更新會重複循環  if (prevState.searchTerm !== this.state.searchTerm) { this.setState({ filteredUsers: DUMMY_USERS.filter((user) =\u0026gt; user.name.includes(this.state.searchTerm) ), }); } } // 搜尋字詞  searchChangeHandler(event) { this.setState({ searchTerm: event.target.value }); } render() { return ( \u0026lt;Fragment\u0026gt; \u0026lt;div className={classes.finder}\u0026gt; // 元件綁定上面方法  \u0026lt;input type=\u0026#39;search\u0026#39; onChange={this.searchChangeHandler.bind(this)} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;Users users={this.state.filteredUsers} /\u0026gt; \u0026lt;/Fragment\u0026gt; ); } } // const UserFinder = () =\u0026gt; { // const [filteredUsers, setFilteredUsers] = useState(DUMMY_USERS); // const [searchTerm, setSearchTerm] = useState(\u0026#39;\u0026#39;);  // useEffect(() =\u0026gt; { // setFilteredUsers( // DUMMY_USERS.filter((user) =\u0026gt; user.name.includes(searchTerm)) // ); // }, [searchTerm]);  // const searchChangeHandler = (event) =\u0026gt; { // setSearchTerm(event.target.value); // };  // return ( // \u0026lt;Fragment\u0026gt; // \u0026lt;div className={classes.finder}\u0026gt; // \u0026lt;input type=\u0026#39;search\u0026#39; onChange={searchChangeHandler} /\u0026gt; // \u0026lt;/div\u0026gt; // \u0026lt;Users users={filteredUsers} /\u0026gt; // \u0026lt;/Fragment\u0026gt; // ); // };  export default UserFinder;    點按鈕隱藏 User，呈現銷毀元件的生命週期 console.log  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  import { Component } from \u0026#34;react\u0026#34;; class User extends Component { componentWillUnmount() { console.log(\u0026#34;User will unmount!\u0026#34;); } render() { return \u0026lt;li className={classes.user}\u0026gt;{this.props.name}\u0026lt;/li\u0026gt;; } } // const User = (props) =\u0026gt; { // return \u0026lt;li className={classes.user}\u0026gt;{props.name}\u0026lt;/li\u0026gt;; // };  export default User;   使用 class Component 處理 context  一樣在 store 先建立初始值，用 Provider 包起來監聽  1 2 3 4 5 6 7 8  // src/store import React from \u0026#34;react\u0026#34;; const UsersContext = React.createContext({ users: [], }); export default UsersContext;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // App.js import UserFinder from \u0026#34;./components/UserFinder\u0026#34;; import UsersContext from \u0026#34;./store/users-context\u0026#34;; const DUMMY_USERS = [ { id: \u0026#34;u1\u0026#34;, name: \u0026#34;Max\u0026#34; }, { id: \u0026#34;u2\u0026#34;, name: \u0026#34;Manuel\u0026#34; }, { id: \u0026#34;u3\u0026#34;, name: \u0026#34;Julie\u0026#34; }, ]; function App() { const usersContext = { users: DUMMY_USERS, }; return ( \u0026lt;UsersContext.Provider value={usersContext}\u0026gt; \u0026lt;UserFinder /\u0026gt; \u0026lt;/UsersContext.Provider\u0026gt; ); } export default App;    DUMMY_USER 改從 store 取得  useContext 改成使用 context consumer  這個方法在 Class Component 跟 Function Component 都可以使用  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  import { Fragment, useState, useEffect, Component } from \u0026#39;react\u0026#39;; import Users from \u0026#39;./Users\u0026#39;; import classes from \u0026#39;./UserFinder.module.css\u0026#39;; import UsersContext from \u0026#39;../store/users-context\u0026#39;; class UserFinder extends Component { static contextType = UsersContext; ... render() { return ( \u0026lt;Fragment\u0026gt; \u0026lt;UsersContext.Consuer\u0026gt; \u0026lt;div className={classes.finder}\u0026gt; \u0026lt;input type=\u0026#39;search\u0026#39; onChange={this.searchChangeHandler.bind(this)} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;Users users={this.context.filteredUsers} /\u0026gt; \u0026lt;/UsersContext.Consuer\u0026gt; \u0026lt;/Fragment\u0026gt; ); } } export default UserFinder;    在 class Component 一個元件只能對應一個 context，不同於 useContext 可以一個元件對應多個不同 context 使用 static 定義一個靜態的方法 原本 this.state 的資料改成 this.context  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  import { Fragment, useState, useEffect, Component } from \u0026#34;react\u0026#34;; import Users from \u0026#34;./Users\u0026#34;; import classes from \u0026#34;./UserFinder.module.css\u0026#34;; import UsersContext from \u0026#34;../store/users-context\u0026#34;; class UserFinder extends Component { // 定義這個元件可以獲取UsersContext  static contextType = UsersContext; constructor() { super(); this.state = { filteredUsers: [], searchTerm: \u0026#34;\u0026#34;, }; } componentDidMount() { // Send http request...  this.setState({ filteredUsers: this.context.users }); } componentDidUpdate(prevProps, prevState) { if (prevState.searchTerm !== this.state.searchTerm) { this.setState({ filteredUsers: this.context.users.filter((user) =\u0026gt; user.name.includes(this.state.searchTerm) ), }); } } searchChangeHandler(event) { this.setState({ searchTerm: event.target.value }); } render() { return ( \u0026lt;Fragment\u0026gt; \u0026lt;div className={classes.finder}\u0026gt; \u0026lt;input type=\u0026#39;search\u0026#39; onChange={this.searchChangeHandler.bind(this)} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;Users users={this.state.filteredUsers} /\u0026gt; \u0026lt;/Fragment\u0026gt; ); } } // const UserFinder = () =\u0026gt; { // const [filteredUsers, setFilteredUsers] = useState(DUMMY_USERS); // const [searchTerm, setSearchTerm] = useState(\u0026#39;\u0026#39;);  // useEffect(() =\u0026gt; { // setFilteredUsers( // DUMMY_USERS.filter((user) =\u0026gt; user.name.includes(searchTerm)) // ); // }, [searchTerm]);  // const searchChangeHandler = (event) =\u0026gt; { // setSearchTerm(event.target.value); // };  // return ( // \u0026lt;Fragment\u0026gt; // \u0026lt;div className={classes.finder}\u0026gt; // \u0026lt;input type=\u0026#39;search\u0026#39; onChange={searchChangeHandler} /\u0026gt; // \u0026lt;/div\u0026gt; // \u0026lt;Users users={filteredUsers} /\u0026gt; // \u0026lt;/Fragment\u0026gt; // ); // };  export default UserFinder;   什麼是錯誤邊界 Error Boundaries  錯誤邊界是一個 React component，捕捉了任何在它的 child component tree 裡發生的 JavaScript 的錯誤，記錄那些錯誤，然後顯示在一個 fallback 的使用介面，而非讓整個 component tree 崩壞 錯誤邊界會在 render 的時候、在生命週期函式內、以及底下一整個 component tree 裡的 constructor 內捕捉錯誤 當子層 Component 出現錯誤，e.g. server 抓不到資料，無法跟 JavaScript 一樣直接 try catch 捕捉 這個元件無法被使用在 Function Component  建立一個 Error Boundary  放在 src/components 下 透過 componentDidCatch 方法，讓這個 Component 成為一個 Error Boundary 當子層 Component 出現錯誤就會觸發 componentDidCatch，避免整個 APP crash  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  import { Component } from \u0026#34;react\u0026#34;; class ErrorBoundary extends Component { // 可以用state管理error (option)  constructor() { super(); this.state = { hasError: false }; } // error  componentDidCatch(error) { console.log(error); // 設定錯誤狀態  this.setState({ hasError: true }); } render() { // 當狀態出錯就回傳一段JSX，提示使用者  if (this.state.hasError) { return \u0026lt;p\u0026gt;Something went wrong!\u0026lt;/p\u0026gt;; } // render 被包裹的元件  return this.props.children; } } export default ErrorBoundary;   把邊界建立在可能出錯的元件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  import { Fragment, useState, useEffect, Component } from \u0026#39;react\u0026#39;; import Users from \u0026#39;./Users\u0026#39;; import classes from \u0026#39;./UserFinder.module.css\u0026#39;; import UsersContext from \u0026#39;../store/users-context\u0026#39;; import ErrorBoundary from \u0026#39;./ErrorBoundary\u0026#39;; class UserFinder extends Component { static contextType = UsersContext; constructor() { super(); this.state = { filteredUsers: [], searchTerm: \u0026#39;\u0026#39;, }; } componentDidMount() { // Send http request...  this.setState({ filteredUsers: this.context.users }); } componentDidUpdate(prevProps, prevState) { if (prevState.searchTerm !== this.state.searchTerm) { this.setState({ filteredUsers: this.context.users.filter((user) =\u0026gt; user.name.includes(this.state.searchTerm) ), }); } } searchChangeHandler(event) { this.setState({ searchTerm: event.target.value }); } render() { return ( \u0026lt;Fragment\u0026gt; \u0026lt;div className={classes.finder}\u0026gt; \u0026lt;input type=\u0026#39;search\u0026#39; onChange={this.searchChangeHandler.bind(this)} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;ErrorBoundary\u0026gt; \u0026lt;Users users={this.state.filteredUsers} /\u0026gt; \u0026lt;/ErrorBoundary\u0026gt; \u0026lt;/Fragment\u0026gt; ); }   ","date":"2022-02-06T00:00:00+08:00","image":"https://bacnotes.github.io/p/react-class-component/pexels-max-fischer-5212336_hu3d03a01dcc18bc5be0e67db3d8d209a6_3974315_120x120_fill_q75_box_smart1.jpg","permalink":"https://bacnotes.github.io/p/react-class-component/","title":"關於React Class Component｜bacnotes備份筆記"},{"content":"React 是怎麼運作的  React 是一個打造使用者介面的 JavaScript 函式庫 React 負責管理元件資料狀態(props, state, context)透過 Virtual DOM 評估哪些元件需要被更新 React Dom 是操作 Web 的介面，跟瀏覽器的 真實 DOM 互動 React Dom 收到 React 的更新資訊(比較差異)，操作瀏覽器 DOM 來改變畫面 比起直接操作真實 DOM，先從 Virtual DOM 評估差異再操作真實 DOM 裡必要修改的部分，較不耗資源  當 props, context, state 更新時會發生什麼事  props, context 更新其實背後都是代表 state 更新，而 props 跟 context 只是傳輸資料管道不同 React 會重新評估(re-evaluate)，即執行元件裡的函式（包含子層元件)，並更新資訊給 React DOM 下方範例，每次 props 變化（true false)，父子元件都會重新 re-evaluate，true 時渲染 This is new，false 則沒有內容  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  // 父層元件 import React, { useState } from \u0026#39;react\u0026#39;; import Button from \u0026#39;./components/UI/Button/Button\u0026#39;; import DemoOutput from \u0026#39;./components/Demo/DemoOutput\u0026#39;; function App() { const [showParagraph, setShowParagraph] = useState(false); console.log(\u0026#39;APP RUNNING\u0026#39;); const toggleParagraphHandler = () =\u0026gt; { setShowParagraph((prevShowParagraph) =\u0026gt; !prevShowParagraph); }; return ( \u0026lt;div className=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Hi there!\u0026lt;/h1\u0026gt; // props傳入showParagraph的狀態  \u0026lt;DemoOutput show={showParagraph} /\u0026gt; \u0026lt;Button onClick={toggleParagraphHandler}\u0026gt;Toggle Paragraph!\u0026lt;/Button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; // 子層元件 const DemoOutput = (props) =\u0026gt; { console.log(\u0026#39;DemoOutput RUNNING\u0026#39;); return \u0026lt;p\u0026gt;{props.show ? \u0026#39;This is new!\u0026#39; : \u0026#39;\u0026#39;}\u0026lt;/p\u0026gt;; }; export default DemoOutput;   父層重新渲染時，子層也會重新評估是否渲染  父層狀態有變但沒有傳入子層，父層渲染時子層也會重新評估，因為子層元件也是父層的程式碼一部分，但受影響的子層不一定會重新渲染 下方範例在真實 DOM 沒有變化（也沒有任何 flash)，表示沒有重新渲染，但會看到 console.log 有跳出，表示有重新評估  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  // 父層元件 import React, { useState } from \u0026#39;react\u0026#39;; import Button from \u0026#39;./components/UI/Button/Button\u0026#39;; import DemoOutput from \u0026#39;./components/Demo/DemoOutput\u0026#39;; function App() { const [showParagraph, setShowParagraph] = useState(false); console.log(\u0026#39;APP RUNNING\u0026#39;); const toggleParagraphHandler = () =\u0026gt; { setShowParagraph((prevShowParagraph) =\u0026gt; !prevShowParagraph); }; return ( \u0026lt;div className=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Hi there!\u0026lt;/h1\u0026gt; // 固定寫false，沒有傳入任何更新  \u0026lt;DemoOutput show={false}} /\u0026gt; \u0026lt;Button onClick={toggleParagraphHandler}\u0026gt;Toggle Paragraph!\u0026lt;/Button\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; // 子層元件 const DemoOutput = (props) =\u0026gt; { console.log(\u0026#39;DemoOutput RUNNING\u0026#39;); return \u0026lt;p\u0026gt;{props.show ? \u0026#39;This is new!\u0026#39; : \u0026#39;\u0026#39;}\u0026lt;/p\u0026gt;; }; export default DemoOutput;   React.memo 優化 Functional Component 效能  只有父層傳下來的 props 值有改變，才會重新渲染子層跟子層下的元件 下方範例若 props 沒改變，不會重新渲染 DemoOutput 跟 MyParagraph 使用 React.memo 也會耗費效能，適合不常更新的較高層級父層元件使用  1 2 3 4 5 6 7 8 9 10  import React from \u0026#34;react\u0026#34;; import MyParagraph from \u0026#34;./MyParagraph\u0026#34;; const DemoOutput = (props) =\u0026gt; { console.log(\u0026#34;DemoOutput RUNNING\u0026#34;); return \u0026lt;MyParagraph\u0026gt;{props.show ? \u0026#34;This is new!\u0026#34; : \u0026#34;\u0026#34;}\u0026lt;/MyParagraph\u0026gt;; }; export default React.memo(DemoOutput);    Button 不適合使用 React.memo，除了是比較低階元件之外 onClick 指向同一個 function，雖然內容沒有變更，但函式是物件，所以每次 render 都會是新的地址，每次都會當作 props 有更新值 可以用 useCallback 來解決這個問題  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  import React, { useState } from \u0026#34;react\u0026#34;; import Button from \u0026#34;./components/UI/Button/Button\u0026#34;; import DemoOutput from \u0026#34;./components/Demo/DemoOutput\u0026#34;; function App() { const [showParagraph, setShowParagraph] = useState(false); console.log(\u0026#34;APP RUNNING\u0026#34;); const toggleParagraphHandler = () =\u0026gt; { setShowParagraph((prevShowParagraph) =\u0026gt; !prevShowParagraph); }; return ( \u0026lt;div className=\u0026#39;app\u0026#39;\u0026gt; \u0026lt;h1\u0026gt;Hi there!\u0026lt;/h1\u0026gt; \u0026lt;DemoOutput show={false} /\u0026gt; \u0026lt;Button onClick={toggleParagraphHandler}\u0026gt;Toggle Paragraph!\u0026lt;/Button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App;   useCallback 優化 Functional Component 效能  用 useCallback 包裹函式，第二個參數也是一個陣列 相依[]空陣列表示永遠不會改變，只會跑一次，若裡面有變數做條件判斷觸發，會因為 closure，變數不會更新  1 2 3  const memoizedCallback = useCallback(() =\u0026gt; { doSomething(a, b); }, [a, b]);    回到剛剛 button 的範例，記住按鈕裡面的onClick參數避免因為函式地址改變重新渲染按鈕  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  import React, { useState, useCallback } from \u0026#34;react\u0026#34;; import Button from \u0026#34;./components/UI/Button/Button\u0026#34;; import DemoOutput from \u0026#34;./components/Demo/DemoOutput\u0026#34;; function App() { const [showParagraph, setShowParagraph] = useState(false); console.log(\u0026#34;APP RUNNING\u0026#34;); const toggleParagraphHandler = useCallback(() =\u0026gt; { setShowParagraph((prevShowParagraph) =\u0026gt; !prevShowParagraph); }, []); return ( \u0026lt;div className=\u0026#39;app\u0026#39;\u0026gt; \u0026lt;h1\u0026gt;Hi there!\u0026lt;/h1\u0026gt; \u0026lt;DemoOutput show={false} /\u0026gt; \u0026lt;Button onClick={toggleParagraphHandler}\u0026gt;Toggle Paragraph!\u0026lt;/Button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App;    若 toggle 外面有一層判斷，相依參數需要加上 allowToggle 若為空陣列則函式本身永遠不會改變而無法觸發  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  import React, { useState, useCallback } from \u0026#39;react\u0026#39;; import Button from \u0026#39;./components/UI/Button/Button\u0026#39;; import DemoOutput from \u0026#39;./components/Demo/DemoOutput\u0026#39;; function App() { const [showParagraph, setShowParagraph] = useState(false); console.log(\u0026#39;APP RUNNING\u0026#39;); const toggleParagraphHandler = useCallback(() =\u0026gt; { if(allowToggle){ setShowParagraph((prevShowParagraph) =\u0026gt; !prevShowParagraph); } }, [allowToggle]); const allowToggleHandler = () = { setAllowToggle(true) } return ( \u0026lt;div className=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Hi there!\u0026lt;/h1\u0026gt; \u0026lt;DemoOutput show={false} /\u0026gt; \u0026lt;Button onClick={allowToggleHandler}\u0026gt;Allow Toggle\u0026lt;/Button\u0026gt; \u0026lt;Button onClick={toggleParagraphHandler}\u0026gt;Toggle Paragraph!\u0026lt;/Button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App;   每次的 state update 其實是非同步的排程  保證順序但不保證立即執行 會有 state batching 來優化渲染流程，同一個函式內程式執行完後再統一更新 state ，並判斷哪些元件需要重新渲染  1 2 3 4 5 6 7 8  const someComponent = () =\u0026gt; { ... const navHandler = (navPath) =\u0026gt; { // 會把同一個函式的統合一起更新，one schedule  setCurrentPath(navPath) setDrawerIsOpen(false) } }   1 2 3 4 5 6 7 8 9  const someComponent = () =\u0026gt; { const [value, setValue] = useState(0); // 統一更新，因為batching所以更新後會是1  const eventHandler = () =\u0026gt; { setValue(value + 1); setValue(value + 1); setValue(value + 1); }; };   useMemo 優化 Functional Component 效能  使用時機：遇到吃效能的運算例如 sort，會希望避免不必要的重新運算 useMemo 包裹耗能的運算函式，把運算結果放在return後 相依參數放陣列裡面，可以用解構賦值把要相依的結果放入[]  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  import React, { useMemo } from \u0026#39;react\u0026#39;; const DemoList = (props) =\u0026gt; { // 只取出props裡面的items，但因為傳入是物件所以地址會變  const { items } = props; const sortedList = useMemo(() =\u0026gt; { console.log(\u0026#39;Items sorted\u0026#39;); return items.sort((a, b) =\u0026gt; a - b); }, [items]); console.log(\u0026#39;DemoList RUNNING\u0026#39;); return ( \u0026lt;div className={classes.list}\u0026gt; \u0026lt;h2\u0026gt;{props.title}\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; {sortedList.map((item) =\u0026gt; ( \u0026lt;li key={item}\u0026gt;{item}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); }; export default React.memo(DemoList);    需要在App.js傳入時就做useMemo固定住記憶體地址才有意義  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function App() { const [listTitle, setListTitle] = useState(\u0026#39;My List\u0026#39;); const changeTitleHandler = useCallback(() =\u0026gt; { setListTitle(\u0026#39;New Title\u0026#39;); }, []); // useMemo記住地址，傳下去的listItems才會是同一個物件  const listItems = useMemo(() =\u0026gt; [5, 3, 1, 10, 9], []); return ( \u0026lt;div className=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;DemoList title={listTitle} items={listItems} /\u0026gt; \u0026lt;Button onClick={changeTitleHandler}\u0026gt;Change List Title\u0026lt;/Button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App;    不是每個都需要做useMemo，因為也會佔據記憶體，根據經驗跟狀況判斷是否需要使用  ","date":"2022-02-04T00:00:00+08:00","image":"https://bacnotes.github.io/p/react-behind-the-scene/pexels-eren-li-7188802_hu7e143e4af08149adffe8eb27c78594aa_1745854_120x120_fill_q75_box_smart1.jpg","permalink":"https://bacnotes.github.io/p/react-behind-the-scene/","title":"React 背後運作原理｜bacnotes備份筆記"},{"content":"什麼是 Hook?  Hook 是 JavaScript 函式，react 提供的內建 Hook 為 use 開頭的函式(e.g. useEffect、useReducer、useContext) 只能用在 React 的 Function Component 跟 custom Hook，class Component 無法，當然自己寫的 function 也無法 使用時需要寫在元件內第一層，不能巢狀到，也不要在迴圈、條件判斷下使用  什麼是 Effect(Side Effect)? React 主要工作是\n 評估是否渲染元件在畫面上 管理狀態跟 props 表單與事件處理(使用者互動) 根據狀態和 props 的更新評估是否重新渲染部分畫面  Side Effect: 非 React 的工作，跟渲染畫面無直接相關，包含儲存資料發送 http 請求跟設定 timer，驗證邏輯，手動操作 DOM 都是 Side Effect\nSide Effect 可能造成的結果\n 非同步操作可能會阻塞渲染工作 跟伺服器請求資料可能會造成無限循環：發送請求-\u0026gt;請求結果返回-\u0026gt;set 新狀態-\u0026gt;狀態改變-\u0026gt;重新渲染元件-\u0026gt;觸發發送請求\u0026hellip;  使用 useEffect 來管理 Effect(Side Effect)  useEffect(()=\u0026gt; {\u0026hellip;}, [dependencies]) 用來限制元件 re-render 執行的程式碼 若沒有相依某個參數，掛載元件跟更新資料都會執行，寫跟沒寫一樣 若有相依某個參數，re-render 時參數有改變的話可以重新觸發 useEffect 裡面的函式 []相依空陣列，第一次渲染完會觸發，因空陣列資料不變，所以後續都不會觸發 [state]相依狀態，第一次渲染完會觸發，且每次狀態改變都會跑一次 [props]相依 props，第一次渲染完會觸發，props 更新都會跑一次 發生時間點為畫面渲染完，控制好觸發時機點，避免不必要的觸發 相依空陣列範例  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  // 渲染登入頁面時，確認localStorage登入驗證資訊，只執行一次 function App() { const [isLoggedIn, setIsLoggedIn] = useState(false); // 第一次渲染完會觸發，後續狀態/props更新不會run  useEffect(() =\u0026gt; { const storedUserLoggedInInformation = localStorage.getItem(\u0026#34;isLoggedIn\u0026#34;); if (storedUserLoggedInInformation === \u0026#34;1\u0026#34;) { setIsLoggedIn(true); } }, []); const loginHandler = (email, password) =\u0026gt; { // We should of course check email and password  // But it\u0026#39;s just a dummy/ demo anyways  localStorage.setItem(\u0026#34;isLoggedIn\u0026#34;, \u0026#34;1\u0026#34;); setIsLoggedIn(true); }; const logoutHandler = () =\u0026gt; { // 登出時移除登入驗證  localStorage.removeItem(\u0026#34;isLoggedIn\u0026#34;); setIsLoggedIn(false); }; // 若有登入驗證資訊 渲染Home頁面 沒有則渲染Login頁面  return ( \u0026lt;React.Fragment\u0026gt; \u0026lt;MainHeader isAuthenticated={isLoggedIn} onLogout={logoutHandler} /\u0026gt; \u0026lt;main\u0026gt; {!isLoggedIn \u0026amp;\u0026amp; \u0026lt;Login onLogin={loginHandler} /\u0026gt;} {isLoggedIn \u0026amp;\u0026amp; \u0026lt;Home onLogout={logoutHandler} /\u0026gt;} \u0026lt;/main\u0026gt; \u0026lt;/React.Fragment\u0026gt; ); }    相依 enteredEmail、enteredPassword 表單狀態  1 2 3 4 5 6 7 8 9 10 11 12 13 14  const Login = (props) =\u0026gt; { const [enteredEmail, setEnteredEmail] = useState(\u0026#39;\u0026#39;); const [emailIsValid, setEmailIsValid] = useState(); const [enteredPassword, setEnteredPassword] = useState(\u0026#39;\u0026#39;); const [passwordIsValid, setPasswordIsValid] = useState(); const [formIsValid, setFormIsValid] = useState(false); // 第一次會執行，後續表單狀態更新也會執行（驗證程式碼）  useEffect(() =\u0026gt; { setFormIsValid( enteredEmail.includes(\u0026#39;@\u0026#39;) \u0026amp;\u0026amp; enteredPassword.trim().length \u0026gt; 6 ); }, [enteredEmail, enteredPassword]); ... }   不需加入相依的參數  更新狀態的函式 setXXX 元件外的變數或函式  應該加入的相依參數  \u0026ldquo;things\u0026rdquo; could change because your component (or some parent component) re-rendered  用 setTimeout 優化觸發時間點，搭配 cleanup 清除功能  若不要每個 key 下去的動作都觸發驗證功能，可以用 setTimeout 一段時間再觸發 effect(非最佳解，後面還有其他做法) useEffect 裡面的 return 函式，只會在 unmount，元件要被從 DOM 卸載時觸發  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  const Login = (props) =\u0026gt; { const [enteredEmail, setEnteredEmail] = useState(\u0026#39;\u0026#39;); const [emailIsValid, setEmailIsValid] = useState(); const [enteredPassword, setEnteredPassword] = useState(\u0026#39;\u0026#39;); const [passwordIsValid, setPasswordIsValid] = useState(); const [formIsValid, setFormIsValid] = useState(false); useEffect(() =\u0026gt; { const identifier = setTimeout(() =\u0026gt; { // 第一次觸發，後續per 0.5秒觸發  console.log(\u0026#39;Checking form validity!\u0026#39;); setFormIsValid( enteredEmail.includes(\u0026#39;@\u0026#39;) \u0026amp;\u0026amp; enteredPassword.trim().length \u0026gt; 6 ); }, 500); // return內容需要是一個function  // 下方程式碼不會在第一次渲染觸發，元件更新才會觸發(when unmounts from the DOM, the component is reused)  return () =\u0026gt; { console.log(\u0026#39;CLEANUP\u0026#39;); //在新的Timer設置前先把舊的Timer刪除  clearTimeout(identifier); }; }, [enteredEmail, enteredPassword]); const emailChangeHandler = (event) =\u0026gt; { setEnteredEmail(event.target.value); }; ... }   官方說明不需要搭配 cleanup 的 Effect  fetch data、手動操作 DOM、輸出 log 紀錄（不用追蹤後續） get 方法讓個別頁面獲取不同資料(把 dummyData 換成實際 server 資料)  需搭配 cleanup 的 Effect  訂閱監聽事件，監聽事件 避免 memory leak  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  import React, { useState, useEffect } from \u0026#34;react\u0026#34;; function FriendStatus(props) { const [isOnline, setIsOnline] = useState(null); useEffect(() =\u0026gt; { function handleStatusChange(status) { setIsOnline(status.isOnline); } ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); // Specify how to clean up after this effect:  return function cleanup() { ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); }; }); if (isOnline === null) { return \u0026#34;Loading...\u0026#34;; } return isOnline ? \u0026#34;Online\u0026#34; : \u0026#34;Offline\u0026#34;; }   useReducer 管理複雜狀態邏輯   當寫 useState 開始覺得不好管理狀態，或需要處理複雜邏輯的時候可以考慮使用 useReducer\n  const [state, dispatchFn] = useReducer(reducerFn, initState, initFn)\n  dispatchFn 觸發 action，action 觸發 reducerFn\n  reducer 會收到上一個狀態跟 action 參數，並且回傳新的 state\n  reducerFn (prevState, action) =\u0026gt; newState\n  initFn 可以用來設定 initState，如果比較複雜的話，需要外部資料等等\n  使用 useReducer 管理 email 跟 password input 狀態(effect 相依參數改成驗證狀態，減少不必要觸發)\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102  // reducerFn寫在元件外面，相關參數會透過dispatch傳入 const emailReducer = (state, action) =\u0026gt; { // 收到dispatch事件同時更新input值跟isValid狀態  if (action.type === \u0026#39;USER_INPUT\u0026#39;) { return { value: action.value, isValid: action.value.includes(\u0026#39;@\u0026#39;) }; } // 點其他Input會Blur  if (action.type === \u0026#39;INPUT_BLUR\u0026#39;) { // 這邊Blur事件不會傳遞值，但需要有一個值維持狀態  // state.value可以拿到最新的state  return { value: state.value, isValid: state.value.includes(\u0026#39;@\u0026#39;) }; // includes驗證會回傳true false  } return { value: \u0026#39;\u0026#39;, isValid: false }; }; const passwordReducer = (state, action) =\u0026gt; { if (action.type === \u0026#39;USER_INPUT\u0026#39;) { return { value: action.value, isValid: action.value.trim().length \u0026gt; 6 }; } // 點其他Input會Blur  if (action.type === \u0026#39;INPUT_BLUR\u0026#39;) { // 這邊Blur事件不會傳遞值，但需要有一個值維持狀態  // state.value可以拿到最新的state  return { value: state.value, isValid: state.value.trim().length \u0026gt; 6 }; // includes驗證會回傳true false  } return {value:\u0026#39;\u0026#39;, isValid: false} } const Login = (props) =\u0026gt; { // const [enteredEmail, setEnteredEmail] = useState(\u0026#39;\u0026#39;);  // const [emailIsValid, setEmailIsValid] = useState();  // const [enteredPassword, setEnteredPassword] = useState(\u0026#39;\u0026#39;);  // const [passwordIsValid, setPasswordIsValid] = useState();  const [formIsValid, setFormIsValid] = useState(false); const [emailState, dispatchEmail] = useReducer(emailReducer, { value: \u0026#39;\u0026#39;, isValid: null, }); // 上面是initState  const [passwordState, dispatchPassword] = useReducer(passwordReducer, { value:\u0026#39;\u0026#39;, isValid: null }) useEffect(() =\u0026gt; { console.log(\u0026#39;EFFECT RUNNING\u0026#39;); return () =\u0026gt; { console.log(\u0026#39;EFFECT CLEANUP\u0026#39;); }; }, []); // 解構賦值，改換另一個變數名  const { isValid: emailIsValid } = emailState; const { isValid: passwordIsValid } = passwordState; useEffect(() =\u0026gt; { const identifier = setTimeout(() =\u0026gt; { console.log(\u0026#39;Checking form validity!\u0026#39;); setFormIsValid(emailIsValid \u0026amp;\u0026amp; passwordIsValid); }, 500); return () =\u0026gt; { console.log(\u0026#39;CLEANUP\u0026#39;); clearTimeout(identifier); }; // 改由驗證有更新再re-run effect來優化效能  }, [emailIsValid, passwordIsValid]); const emailChangeHandler = (event) =\u0026gt; { // 通常是一個物件 {type:\u0026#39;\u0026#39;, 也可以寫payload要跟上面reducer action內key值一樣: 傳遞下去的值}  dispatchEmail({type: \u0026#39;USER_INPUT\u0026#39;, value: event.target.value}); setFormIsValid( event.target.value.includes(\u0026#39;@\u0026#39;) \u0026amp;\u0026amp; enteredPassword.trim().length \u0026gt; 6 ); }; const passwordChangeHandler = (event) =\u0026gt; { dispatchPassWord({type:\u0026#39;USER_INPUT\u0026#39;, value:event.target.value}) setFormIsValid( emailState.isValid \u0026amp;\u0026amp; event.target.value.trim().length \u0026gt; 6 ); }; const validateEmailHandler = () =\u0026gt; { dispatchEmail({type: \u0026#39;INPUT_BLUR\u0026#39;}); }; const validatePasswordHandler = () =\u0026gt; { dispatchPassword({type: \u0026#39;INPUT_BLUR\u0026#39;}); }; const submitHandler = (event) =\u0026gt; { event.preventDefault(); // state取值用state.value  props.onLogin(emailState.value, passwordState.value); };    上述的解構賦值很常用在取相依參數，也可以用取屬性的方式  1 2 3 4 5 6 7 8  const { someProperty } = someObject; useEffect(() =\u0026gt; { // code that only uses someProperty ... }, [someProperty]); useEffect(() =\u0026gt; { // code that only uses someProperty ... }, [someObject.someProperty]);    記得避免直接寫整個物件，因為物件傳值，彼此就算長一樣地址也不會相同  useContext 管理全域 State  好處：不用透過長長的 prop chain 直接傳遞資料 流程：先透過 React.createContext 創造一個變數，透過 AuthContext 輸出，其他元件用 useContext 引用相對應的 context 檔案獲取物件值  1 2 3 4 5 6 7 8  // src/store import { createContext } from \u0026#34;react\u0026#34;; // 建立一個context物件 裡面放初始值 const AuthContext = createContext({ isLoggedIn: false, }); export default AuthContext;    \u0026lt;AuthContext.Provider\u0026gt;...\u0026lt;/AuthContext.Provider\u0026gt;透過 Provider 屬性可以獲取 AuthContext 而包裹在\u0026lt;AuthContext.Provider\u0026gt;之間的元件都可以獲取這個 AuthContext  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // App.js // import context變數 import AuthContext from \u0026#39;./store/auth-context\u0026#39;; function App() { const [isLoggedIn, setIsLoggedIn] = useState(false); ... return ( // 如果有預設值基本上不需要寫value，但若有會變動的值，要透過value傳入更新狀態，只能透過Provider來做  \u0026lt;AuthContext.Provider value={{ isLoggedIn: isLoggedIn, // context物件裡面的value 也可以放函式  onLoggedOut: () =\u0026gt; {}, }} \u0026gt; \u0026lt;MainHeader onLogout={logoutHandler} /\u0026gt; \u0026lt;main\u0026gt; {!isLoggedIn \u0026amp;\u0026amp; \u0026lt;Login onLogin={loginHandler} /\u0026gt;} {isLoggedIn \u0026amp;\u0026amp; \u0026lt;Home onLogout={logoutHandler} /\u0026gt;} \u0026lt;/main\u0026gt; \u0026lt;/AuthContext.Provider\u0026gt; ); export default App;    在 Navbar 來獲取變數  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  import React, { useContext } from \u0026#34;react\u0026#34;; import AuthContext from \u0026#34;../../store/auth-context\u0026#34;; const Navigation = () =\u0026gt; { // 使用useContext 指向特定context獲取value(物件)  const ctx = useContext(AuthContext); return ( \u0026lt;nav className={classes.nav}\u0026gt; \u0026lt;ul\u0026gt; {ctx.isLoggedIn \u0026amp;\u0026amp; ( \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#39;/\u0026#39;\u0026gt;Users\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; )} {ctx.isLoggedIn \u0026amp;\u0026amp; ( \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#39;/\u0026#39;\u0026gt;Admin\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; )} {ctx.isLoggedIn \u0026amp;\u0026amp; ( \u0026lt;li\u0026gt; \u0026lt;button onClick={ctx.onLogout}\u0026gt;Logout\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; )} \u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt; ); }; export default Navigation;    重構：把登入登出 Auth 相關的函式都放在 context 管理  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  import React, { useState, useEffect } from \u0026#34;react\u0026#34;; const AuthContext = React.createContext({ isLoggedIn: false, onLogout: () =\u0026gt; {}, onLogin: (email, password) =\u0026gt; {}, }); // 新增 export const AuthContextProvider = (props) =\u0026gt; { const [isLoggedIn, setIsLoggedIn] = useState(false); useEffect(() =\u0026gt; { const storedUserLoggedInInformation = localStorage.getItem(\u0026#34;isLoggedIn\u0026#34;); if (storedUserLoggedInInformation === \u0026#34;1\u0026#34;) { setIsLoggedIn(true); } }, []); const logoutHandler = () =\u0026gt; { localStorage.removeItem(\u0026#34;isLoggedIn\u0026#34;); setIsLoggedIn(false); }; const loginHandler = () =\u0026gt; { localStorage.setItem(\u0026#34;isLoggedIn\u0026#34;, \u0026#34;1\u0026#34;); setIsLoggedIn(true); }; return ( \u0026lt;AuthContext.Provider value={{ isLoggedIn: isLoggedIn, onLogout: logoutHandler, onLogin: loginHandler, }}\u0026gt; {props.children} \u0026lt;/AuthContext.Provider\u0026gt; ); }; export default AuthContext;    把\u0026lt;AuthContextProvider\u0026gt;包裹全域監聽放到 index.js  1 2 3 4 5 6 7 8 9 10 11 12 13  import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; import \u0026#34;./index.css\u0026#34;; import App from \u0026#34;./App\u0026#34;; import { AuthContextProvider } from \u0026#34;./store/auth-context\u0026#34;; ReactDOM.render( \u0026lt;AuthContextProvider\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/AuthContextProvider\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;) );    App.js 跟 Navbar 只要引用 Context 的資料  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  //App.js import AuthContext from \u0026#34;./store/auth-context\u0026#34;; function App() { const ctx = useContext(AuthContext); return ( \u0026lt;React.Fragment\u0026gt; \u0026lt;MainHeader /\u0026gt; \u0026lt;main\u0026gt; {!ctx.isLoggedIn \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt;} {ctx.isLoggedIn \u0026amp;\u0026amp; \u0026lt;Home /\u0026gt;} \u0026lt;/main\u0026gt; \u0026lt;/React.Fragment\u0026gt; ); } export default App;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  // Navbar import AuthContext from \u0026#34;../../store/auth-context\u0026#34;; const Navigation = () =\u0026gt; { const ctx = useContext(AuthContext); return ( \u0026lt;nav className={classes.nav}\u0026gt; \u0026lt;ul\u0026gt; {ctx.isLoggedIn \u0026amp;\u0026amp; ( \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#39;/\u0026#39;\u0026gt;Users\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; )} {ctx.isLoggedIn \u0026amp;\u0026amp; ( \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#39;/\u0026#39;\u0026gt;Admin\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; )} {ctx.isLoggedIn \u0026amp;\u0026amp; ( \u0026lt;li\u0026gt; \u0026lt;button onClick={ctx.onLogout}\u0026gt;Logout\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; )} \u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt; ); }; export default Navigation;   useContext 的限制  不適合頻繁更動的資料（每秒好幾次)，使用 redux 鄰近父子元件還是建議透過 props 傳遞資料，而非用 useContext 取代  延伸閱讀：自學 React 的你需要知道的一些知識｜ React - The Complete Guide\n","date":"2022-02-03T00:00:00+08:00","image":"https://bacnotes.github.io/p/react-effect-reducer-context/pexels-rodolpho-zanardo-1309095_hu3d03a01dcc18bc5be0e67db3d8d209a6_4924053_120x120_fill_q75_box_smart1.jpg","permalink":"https://bacnotes.github.io/p/react-effect-reducer-context/","title":"React 必須了解的3大Hooks：useEffect、useReducer、useContext｜bacnotes備份筆記"},{"content":"元件該怎麼添加 CSS 樣式? 主要方法有四種：\n Inline style 直接給他寫上去(最難維護) CSS(全域套用容易撞名) Styled Component(CSS in JS) CSS modules(CSS JS 分離)  inline style 撰寫動態樣式  useState 來更新有效無效狀態 沒效套用紅色，有效套用黑色  1 2 3 4 5 6 7 8 9 10 11 12 13 14  const Input = props =\u0026gt; { const [ enteredValue, setEnteredValue ] = useState(\u0026#39;\u0026#39;) const [ isValid, setIsValid ] = useState(true) const goalInputChangeHandler = event =\u0026gt; { setEnteredValue(event.target.value); }; if(enteredValue.trim().length === 0){ setIsValid(false) return } return( \u0026lt;input style ={{ borderColor: !isValid ? \u0026#39;red\u0026#39; : \u0026#39;Black\u0026#39;, background: !isValid ? \u0026#39;red\u0026#39; : \u0026#39;Black\u0026#39;}} onChange={goalInputChangeHandler}\u0026gt; ) }   為什麼不用 inline style 撰寫動態樣式?  分散在 html 程式的樣式不好管理 inline style 會覆蓋掉其他 CSS 樣式(權重僅次!important)，找改動點更費時  CSS 撰寫動態樣式  把剛剛的樣式貼到 CSS file  1 2 3 4 5 6 7 8 9 10 11  .form-control { outline: none; background: pink; border-corlor: red; ...等等其他固定的樣式; } .invalid { border-color: red; background: red; }    拿掉 inline style ，動態添加 className 上一篇\u0026quot;有提到 class 是 JavaScript 的保留字，所以不使用 class  1 2  // 固定樣式form-control搭配動態樣式isValid  \u0026lt;input className={`form-control ${!isValid ? \u0026#39;invalid\u0026#39; : \u0026#39;\u0026#39; }`} onChange={goalInputChangeHandler}\u0026gt;   為什麼不用 CSS 撰寫動態樣式  因為樣式會套用在全域環境，即生效在所有元件上，而大型專案上在 className 命名的時候很難避免撞名，樣式容易發生衝突 使用 Styled Component 套件來創造 scoped CSS  Styled Component 撰寫動態樣式 安裝套件跟撰寫方式  cd 到專案資料夾 npm install --save styled-components const Input = styled.html 元素CSS樣式 (attacked template literal) styled package 有所有 html 元素的方法，透過反引號``可以撰寫多行 CSS 樣式，指定到對應 html 元素當中 動態產生獨特 hash  1 2 3 4 5 6 7 8 9 10 11 12 13 14  import styled from \u0026#34;styled-components\u0026#34;; const Input = styled.input` font: inherit; padding: 0.5rem 1.5rem; // 偽元素選擇器 \u0026amp;:focus { outline: none; } \u0026amp;:hover, \u0026amp;:active { background: #ac2342; } `;   使用 props 動態管理樣式  可以拿掉一些不必要的 CSS 樣式(form-control.invalid input 聯集的選擇器)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  import styled from \u0026#39;styled-components\u0026#39;; const FormControl = styled.div` margin: 0.5rem 0; \u0026amp;:label { font-weight: bold; display: block; margin-bottom: 0.5rem; color: ${props =\u0026gt; (props.invalid ? \u0026#39;red\u0026#39; : \u0026#39;black\u0026#39;)}; } \u0026amp;:input { display: block; width: 100%; border: 1px solid ${props =\u0026gt; (props.invalid ? \u0026#39;red\u0026#39; : \u0026#39;#ccc\u0026#39;)}; background: ${props =\u0026gt; (props.invalid ? \u0026#39;#ffd7d7\u0026#39; : \u0026#39;transparent\u0026#39;)}; font: inherit; line-height: 1.5rem; padding: 0 0.25rem; } \u0026amp;:input:focus { outline: none; background: #fad0ec; border-color: #8b005d; } `; ... return ( \u0026lt;form onSubmit={formSubmitHandler}\u0026gt; // 原本CSS\u0026lt;div className={`form-control ${!isValid ? \u0026#39;invalid\u0026#39;:\u0026#39;\u0026#39;}`}\u0026gt;  // 改成FormControl是一個帶有樣式的 div  // 動態className改成invalid或valid透過props 布林值決定  \u0026lt;FormControl invalid={!isValid}\u0026gt; \u0026lt;label\u0026gt;Course Goal\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; onChange={goalInputChangeHandler} /\u0026gt; \u0026lt;/FormControl\u0026gt; \u0026lt;Button type=\u0026#34;submit\u0026#34;\u0026gt;Add Goal\u0026lt;/Button\u0026gt; \u0026lt;/form\u0026gt; );   style component 使用 media queries 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  const Button = styled.button` // 手機版展開 width: 100%; font: inherit; padding: 0.5rem 1.5rem; border: 1px solid #8b005d; color: white; background: #8b005d; box-shadow: 0 0 4px rgba(0, 0, 0, 0.26); cursor: pointer; // 平板變小 @media (min-width: 768px) { width: auto; } \u0026amp;:focus { outline: none; } \u0026amp;:hover, \u0026amp;:active { background: #ac0e77; border-color: #ac0e77; box-shadow: 0 0 8px rgba(0, 0, 0, 0.26); } `;   style component 的優缺點  優點：不用想 className 名字了 缺點：隨機的 hash 不容易 debug，但透過安裝 babel-plugin-styled-components 可以在瀏覽器看到元件名稱 適合喜歡 CSS 跟 JS 邏輯寫在一起的人  CSS modules  不用安裝套件，CRA 本身支援 CSS modules 把副檔名.css 檔案改成.module.css，引用路徑也要改 className = {styles. 樣式選擇器名} 瀏覽器看到 class 名為：元件名_class 名__hash，因此不會撞名 class 名若有橫線-連接，寫法需要改成${style['form-control']}  1 2 3 4 5 6 7 8 9 10 11 12  // import後面的變數名自由命名，會當作物件(整包樣式屬性)傳入，這邊以styles為範例 import styles from \u0026#34;./Button.module.css\u0026#34;; const Button = (props) =\u0026gt; { return ( // 這邊  \u0026lt;button type={props.type} className={styles.button} onClick={props.onClick}\u0026gt; {props.children} \u0026lt;/button\u0026gt; ); }; export default Button;   CSS modules 使用 media queries  一樣寫在 CSS 檔案就好  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  .button { width: 100%; font: inherit; padding: 0.5rem 1.5rem; border: 1px solid #8b005d; color: white; background: #8b005d; box-shadow: 0 0 4px rgba(0, 0, 0, 0.26); cursor: pointer; } .button:focus { outline: none; } .button:hover, .button:active { background: #ac0e77; border-color: #ac0e77; box-shadow: 0 0 8px rgba(0, 0, 0, 0.26); } @media (min-width: 768px) { .button { width: auto; } }   CSS modules 的優缺點  優點：命名時不用擔心撞名，hash 維持獨特性 缺點：需要改副檔名，一開始沒導入後面手動要改比較累一點 適合喜歡 CSS 跟 JS 分離的人  ","date":"2022-02-02T00:00:00+08:00","image":"https://bacnotes.github.io/p/react-styling/pexels-vlada-karpovich-7025515_hu3d03a01dcc18bc5be0e67db3d8d209a6_3812665_120x120_fill_q75_box_smart1.jpg","permalink":"https://bacnotes.github.io/p/react-styling/","title":"React的CSS樣式管理方法｜bacnotes備份筆記"},{"content":"這是一個懶人包整理～！祝大家新年快樂！\n字串可以使用部分陣列的方法 根據索引取值 1 2 3 4 5  const airline = \u0026#34;TAP Air Portugal\u0026#34;; const plane = \u0026#34;A320\u0026#34;; console.log(plane[0]); // A console.log(\u0026#34;B35\u0026#34; [0]); // B console.log(plane.length); // 4   indexOf()、lastIndexOf() 找索引位置  indexOf(searchElement, fromIndex) 由前往後找值的索引，第 2 個參數是 option lastIndexOf(searchElement, fromIndex) 由後往前找值的索引，第 2 個參數是 option 若不存在則回傳 -1  1 2 3 4  const airline = \u0026#34;TAP Air Portugal\u0026#34;; const plane = \u0026#34;A320\u0026#34;; console.log(airline.indexOf(\u0026#34;r\u0026#34;)); // 6 console.log(airline.lastIndexOf(\u0026#34;r\u0026#34;)); // 10 後往前找    會判別字母大小寫(case-sensitive)  1 2  console.log(airline.indexOf(\u0026#34;portugal\u0026#34;)); // -1 console.log(airline.indexOf(\u0026#34;Portugal\u0026#34;)); // 8    淺拷貝 slice(start, end)，預設 slice(0, arr.length)，回傳選取範圍之陣列 若有指定 end，所在的元素不會被納入 無法使用 splice 因為字串是 immutable  1  console.log(airline.slice(4)); // Air Portugal    切出第一個字(不包含空白)  1  console.log(airline.slice(0, airline.indexOf(\u0026#34; \u0026#34;))); // TAP    寫一個判斷字串尾端有無 B 或 E 的 function，來判段機位位置 e.g. 11B 23C  1 2 3 4 5 6 7  const checkMiddleSeat = function(seat) { const position = seat.slice(-1); if (position === \u0026#34;B\u0026#34; || position === \u0026#34;E\u0026#34;) console.log(\u0026#34;middle seat\u0026#34;); else console.log(\u0026#34;not middle seat\u0026#34;); }; checkMiddleSeat(\u0026#34;11B\u0026#34;); // middle seat checkMiddleSeat(\u0026#34;11C\u0026#34;); // not middle seat   toUpperCase()、toLowerCase()轉大小寫 1 2 3 4 5 6 7 8 9 10  const airline = \u0026#34;TAP Air Portugal\u0026#34;; console.log(airline.toLowerCase()); // tap air portugal console.log(airline.toUpperCase()); // TAP AIR PORTUGAL  // 把大小寫混亂的字轉開頭大寫，後面小寫 const name = \u0026#34;jOnAs\u0026#34;; const nameLower = name.toLowerCase(); const nameCorrect = nameLower[0].toUpperCase() + nameLower.slice(1); console.log(nameCorrect); // Jonas   trim()、trimStart()、trimEnd() 移除泛空白字元(後兩個 IE 沒有支援)  trim() 刪除兩端所有空白 trimStart() 將刪除字串開頭的所有空白 trimEnd() 將刪除字串末尾的所有空白  1 2 3 4 5 6  // email輸入剪掉空白跟轉換成小寫 const email = \u0026#34;hello@jonas.io\u0026#34;; // 正確email資料 const loginEmail = \u0026#34; Hello@jonas.Io\\n\u0026#34;; // 輸入時大小寫混用+空白+enter  const normalizedEmail = loginEmail.toLowerCase().trim(); console.log(normalizedEmail); // hello@jonas.io   replace()、replaceAll() 字串取代，會回傳一個新字串(後者 IE 沒有支援)  replace(regexp|substr, newSubstr|function)第二個參數會取代第一個參數  1 2 3  const priceGB = \u0026#34;288,97£\u0026#34;; const priceUS = priceGB.replace(\u0026#34;£\u0026#34;, \u0026#34;$\u0026#34;).replace(\u0026#34;,\u0026#34;, \u0026#34;.\u0026#34;); console.log(priceUS); // 288.97$    當輸入對象是字串，replace 只會取代第一個匹配的，replaceAll 會取代所有匹配的  1 2 3  const p = \u0026#34;abab\u0026#34;; console.log(p.replace(\u0026#34;a\u0026#34;, \u0026#34;A\u0026#34;)); // \u0026#34;Abab\u0026#34; console.log(p.replaceAll(\u0026#34;a\u0026#34;, \u0026#34;A\u0026#34;)); // \u0026#34;AbAb\u0026#34;    當第一個參數為是正則表達式，兩者都會取代所有匹配的  1 2 3  const p = \u0026#34;abab\u0026#34;; console.log(p.replace(/a/g, \u0026#34;A\u0026#34;)); // \u0026#34;AbAb\u0026#34; console.log(p.replaceAll(/a/g, \u0026#34;A\u0026#34;)); // \u0026#34;AbAb\u0026#34;   includes() 檢查是否包含特定字串，回傳 true false  arr.includes(valueToFind, fromIndex)，第 2 個參數 option 區分大小寫，使用零值相等確認元素是否一樣 若 fromIndex 大於陣列長度，直接回傳 false 若 fromIndex 小於 0，會搜尋整個陣列  1 2 3 4  const plane = \u0026#34;Airbus A320neo\u0026#34;; console.log(plane.includes(\u0026#34;A320\u0026#34;)); // true console.log(plane.includes(\u0026#34;Boeing\u0026#34;)); //false console.log(plane.startsWith(\u0026#34;Airb\u0026#34;)); // true    寫一個檢查字串是否有刀槍字串的 function  1 2 3 4 5 6 7 8 9 10 11 12  const checkBaggage = function(items) { const baggage = items.toLowerCase(); // 輸入統一轉小寫，比較好處理檢查  if (baggage.includes(\u0026#34;knife\u0026#34;) || baggage.includes(\u0026#34;gun\u0026#34;)) { console.log(\u0026#34;You are NOT allowed on board\u0026#34;); } else { console.log(\u0026#34;Welcome aboard!\u0026#34;); } }; checkBaggage(\u0026#34;I have a laptop, some Food and a pocket Knife\u0026#34;); // You are NOT allowed on board checkBaggage(\u0026#34;Socks and camera\u0026#34;); // Welcome aboard!   split() 使用指定字串切割字串，切割的結果回傳成一個陣列  split(separator, limit)，第 2 個參數是 option  1 2 3 4 5 6 7 8  console.log(\u0026#34;string\u0026#34;.split(\u0026#34;\u0026#34;)); // [ \u0026#39;s\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;g\u0026#39; ] 沒有寫條件，會以字元為單位切 console.log(\u0026#34;a+very+nice+string\u0026#34;.split(\u0026#34;+\u0026#34;)); // 以+切割 // [ \u0026#39;a\u0026#39;, \u0026#39;very\u0026#39;, \u0026#39;nice\u0026#39;, \u0026#39;string\u0026#39; ] console.log(\u0026#34;Jonas Schmedtmann\u0026#34;.split(\u0026#34; \u0026#34;)); // 以空白切割 // [ \u0026#39;Jonas\u0026#39;, \u0026#39;Schmedtmann\u0026#39; ] const [firstName, lastName] = \u0026#34;Jonas Schmedtmann\u0026#34;.split(\u0026#34; \u0026#34;); // 切割後解構賦值   join() 使用指定字串將陣列元素合併為一個字串  join([separator]) join() // a, b, c join(\u0026rsquo;\u0026rsquo;) // abc join(\u0026rsquo;-\u0026rsquo;) // a-b-c 若陣列只有一個就不使用 join 中的字串 在陣列長度為零、元素為 undefined 或 null 狀況下，回傳空字串  1 2  const newName = [\u0026#34;Mr.\u0026#34;, firstName, lastName.toUpperCase()].join(\u0026#34; \u0026#34;); console.log(newName);    使用 split()跟 join()把名字整理成只有第一個大寫開頭  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // 方法一 const capitalizeName = function(name) { const names = name.split(\u0026#34; \u0026#34;); const nameUpper = []; for (const char of names) { nameUpper.push(char[0].toUpperCase() + char.slice(1)); } console.log(nameUpper.join(\u0026#34; \u0026#34;)); }; capitalizeName(\u0026#34;jessica ann smith davis\u0026#34;); // Jessica Ann Smith Davis  // 方法二 改用replace const capitalizeName = function(name) { const names = name.split(\u0026#34; \u0026#34;); const nameUpper = []; for (const char of names) { nameUpper.push(char.replace(char[0], char[0].toUpperCase())); } console.log(nameUpper.join(\u0026#34; \u0026#34;)); // Jessica Ann Smith Davis };   ＊字串拼接還有一種 concat 方法，但 MDN 強烈建議直接使用運算子 assignment operators (en-US) 來達成， 像是 + 及 += 若想了解 concat 方法，可以參考陣列的處理方法\npadStart()、padEnd()填充字串 (IE 沒有支援)  padStart(targetLength, padString)，從開頭填充字串到指定長度 padEnd(targetLength, padString)，從結尾填充字串到指定長度 第 2 個參數沒寫會填充空白  1 2 3  const message = \u0026#34;Go to gate 23!\u0026#34;; console.log(message.padStart(20, \u0026#34;+\u0026#34;).padEnd(26, \u0026#34;+\u0026#34;)); //++++++Go to gate 23!++++++    信用卡加密  1 2 3 4 5 6 7  const maskCreditCard = function(number) { const str = number + \u0026#34;\u0026#34;; const last = str.slice(-4); return last.padStart(str.length, \u0026#34;*\u0026#34;); }; console.log(maskCreditCard(\u0026#34;334859493847755774747\u0026#34;)); // *****************4747   repeat() 回傳指定數量 copy 字串  repeat(count)  1 2 3 4 5  const planesInLine = function(num) { console.log(`There are ${num}planes in line ${\u0026#34;🛩\u0026#34;.repeat(num)}`); }; planesInLine(5); // There are 5 planes in line 🛩🛩🛩🛩🛩   search()  回傳正規表達式的第一個匹配的 index，若找不到，回傳 -1。  1 2 3 4 5 6 7 8 9 10 11  const paragraph = \u0026#34;The quick brown fox jumps over the lazy dog. If the dog barked, was it really lazy?\u0026#34;; // any character that is not a word character or whitespace const regex = /[^\\w\\s]/g; console.log(paragraph.search(regex)); // expected output: 43  console.log(paragraph[paragraph.search(regex)]); // expected output: \u0026#34;.\u0026#34;   match()  回傳一個字串匹配正規表達式的结果 使用 g 全局比對，回傳所有結果在一個陣列 沒有使用 g，回傳第一個匹配的結果，匹配的起始點，輸入字串本身，捕獲陣列或 undefined  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  const paragraph = \u0026#34;The quick brown fox jumps over the lazy dog. It barked.\u0026#34;; const regex = /[A-Z]/g; const regexNotGlobal = /[A-Z]/; const found = paragraph.match(regex); const foundNotGlobal = paragraph.match(regexNotGlobal); console.log(found); // expected output: Array [\u0026#34;T\u0026#34;, \u0026#34;I\u0026#34;]  console.log(foundNotGlobal); // [ // \u0026#39;T\u0026#39;, // index: 0, // input: \u0026#39;The quick brown fox jumps over the lazy dog. It barked.\u0026#39;, // groups: undefined // ]   綜合練習 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  // Q1 //TEST DATA (pasted to textarea) //underscore_case // first_name //Some_Variable // calculate_AGE //delayed_departure  //SHOULD PRODUCE THIS OUTPUT (5 separate console.log outputs) //underscoreCase ✅ //firstName ✅✅ //someVariable ✅✅✅ //calculateAge ✅✅✅✅ //delayedDeparture ✅✅✅✅✅  document.body.append(document.createElement(\u0026#34;textarea\u0026#34;)); document.body.append(document.createElement(\u0026#34;button\u0026#34;)); const text = document.querySelector(\u0026#34;textarea\u0026#34;).value; document.querySelector(\u0026#34;button\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, function() { const text = document.querySelector(\u0026#34;textarea\u0026#34;).value; const rows = text.split(\u0026#34;\\n\u0026#34;); for (const [i, row] of rows.entries()) { const [first, second] = row.toLowerCase().trim().split(\u0026#34;_\u0026#34;); const output = `${first}${second.replace( second[0], second[0].toUpperCase() )}`.padEnd(20); const check = \u0026#34;✅\u0026#34;.repeat(i + 1); console.log(output + check); } }); // Q2 // const flights = \u0026#39;_Delayed_Departure;fao93766109;txl2133758440;11:25+_Arrival;bru0943384722;fao93766109;11:45+_Delayed_Arrival;hel7439299980;fao93766109;12:05+_Departure;fao93766109;lis2323639855;12:30\u0026#39;;  // 🔴 Delayed Departure from FAO to TXL (11h25) // Arrival from BRU to FAO (11h45) // 🔴 Delayed Arrival from HEL to FAO (12h05) // Departure from FAO to LIS (12h30)  // 抽出共用方法：切出前三個字轉大寫 const getCode = (str) =\u0026gt; str.slice(0, 3).toUpperCase(); for (const item of flights.split(\u0026#34;+\u0026#34;)) { const [status, from, to, time] = item.split(\u0026#34;;\u0026#34;); const signal = status.slice(1).includes(\u0026#34;_\u0026#34;) ? \u0026#34;🔴\u0026#34; : \u0026#34;\u0026#34;; console.log( `${signal}${status.replaceAll(\u0026#34;_\u0026#34;, \u0026#34; \u0026#34;)}${getCode(from)}${getCode( to )}${time.replace(\u0026#34;:\u0026#34;, \u0026#34;h\u0026#34;)}`.padStart(35) ); }   補充：為什麼字串是 Primitives (不是物件)，卻可以呼叫方法  JavaScript 在字串呼叫方法時會把字串轉成物件，這個過程叫 boxing  1 2  console.log(new String(\u0026#34;jonas\u0026#34;)); // String{\u0026#39;jonas\u0026#39;} console.log(typeof new String(\u0026#34;jonas\u0026#34;)); //object    當轉換結束後會再把物件轉回字串  1  console.log(typeof new String(\u0026#34;jonas\u0026#34;).slice(1)); // string   ","date":"2022-01-30T00:00:00+08:00","image":"https://bacnotes.github.io/p/string-methods/pexels-pixabay-278887_hu3d03a01dcc18bc5be0e67db3d8d209a6_1794718_120x120_fill_q75_box_smart1.jpg","permalink":"https://bacnotes.github.io/p/string-methods/","title":"字串的處理方法｜bacnotes備份筆記"},{"content":"產出好維護好管理的程式碼是重要的，想像今天你的任務是要從這個房間裡找出某一本書，你覺得你需要多少時間？\n如果專案程式碼長這樣的話，還沒開始 debug 腦袋就已經先當機了\u0026hellip; 而物件導向程式設計就是為了解決這個問題而誕生的一種方便管理程式碼的方式\n什麼是物件導向程式設計(Object-Oriented Programming)  基於物件概念的程式設計方法 使用物件形容(model)具體或抽象的 feature(e.g. user, todo-item, 元件或資料結構) 我們把相關屬性跟方法都包在一個物件，可以很方便取得內部資料 物件是獨立的(self-contained)的程式碼片段，透過彼此互動構築成一個應用程式 公開的 API 即是透過物件內方法跟應用程式互動  物件導向程式語言四大原則 抽象化  隱藏實作細節的機制  封裝  把屬性跟方法封裝在 class 不讓外部讀取修改，但 class 內部可以讀取 封裝好(讓屬性跟方法保持 private)可避免產生非預期 bug 當外在程式碼能夠更動到 class 內部資料，會連動影響到調用這個 class 的相關程式碼 需要公開存取 API 可設計成開放存取  繼承  當有兩個相似的 class，我們可以使用繼承特性避免撰寫重複程式碼(parent class → child class)  多型  child class 可以覆寫 parent class 的方法  class 跟 instance 實例是什麼？  class 是一個藍圖(非物件)，透過 class 建構出來的東西是 instance 實例 但 JavaScript 其實沒有真正的 class 這個類別實例(而 Java，C++有) JavaScript 的 class 比較像是語法糖，透過建構函式來模擬 class，可以調用原型(prototype-based)方法  prototype 原型是什麼？  在 JavaScript 物件都會連結到原型，原型繼承(prototypal inheritance)表示所有被連結到的實例都可以使用原型的方法 舉例來說，我們在使用陣列的 map 方法，也是從陣列的 prototype 取用這個方法，而不是 num 本身有的方法()  建立原型的 3 種方法  建立原型是為了可以使用原型繼承   使用建構函式(Constructor functions)跟 new 運算子產生新的實例 ES6 的 class 語法糖 Object.create（最簡單創造出一個物件連結 prototype 的方法)  1 2  const num = [1, 2, 3]; console.log(num.map((el) =\u0026gt; el + 2)); //[ 3, 4, 5 ]   使用建構函式跟 new 運算子建立原型連結  寫一個建構函式，使用 new 運算子產生新的物件實例{} 當函式被呼叫，物件實例的 this 會指向這個實例本身{} (因為使用 new 運算子才有這個特性，跟一般函式 this 不同) 實例會連結到建構函式，讓實例可以使用建構函式的方法，因此每個物件下會有.__proto__屬性 建構函式本身會 return{}  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  // 使用同原型創造不同實例 const Person = function(firstName, birthYear) { // this 指向實例本身  console.log(this); // Person {}  // 設定實例屬性為外部傳進來的參數  this.firstName = firstName; this.birthYear = birthYear; // 方法不會寫在原型裡面，會造成多餘的程式碼，若有一千個物件就有一千個方法程式碼 }; // 創造一個firstName為Jonas birthYear為1991的Person實例 const jonas = new Person(\u0026#34;Jonas\u0026#34;, 1991); console.log(jonas); // Person { firstName: \u0026#39;Jonas\u0026#39;, birthYear: 1991 }  // 創造一個firstName為mirenda birthYear為2003的Person實例 const mirenda = new Person(\u0026#34;mirenda\u0026#34;, 2003); console.log(mirenda); // Person { firstName: \u0026#39;mirenda\u0026#39;, birthYear: 2003 }  // 使用.prototype.方法名 新增原型共用方法 // 一樣所有物件可以透過prototype inheritance共用，但只需要管理這段程式碼，不會有多餘的copy Person.prototype.calcAge = function() { console.log(2037 - this.birthYear); }; // 可以共用原型方法 jonas.calcAge(); // 46 mirenda.calcAge(); // 34  // 使用.prototype 新增原型屬性 Person.prototype.species = \u0026#34;Homo Sapiens\u0026#34;; console.log(jonas.species); // 可以取得共用屬性 Homo Sapiens console.log(jonas); // Person { firstName: \u0026#39;Jonas\u0026#39;, birthYear: 1991 } 但不會出現在jonas實例裡面，除非有寫入   檢查實例所屬原型方法 1 2 3  console.log(jonas instanceof Person); // true console.log(jonas.__proto__ === Person.prototype); // 若是原型連結的實例為 true console.log(Person.prototype.isPrototypeOf(jonas)); // 若是原型連結的實例為 true   檢查實例是否含有某屬性 hasOwnProperty 1 2 3  console.log(jonas.hasOwnProperty(\u0026#34;firstName\u0026#34;)); // true console.log(jonas.species); // Homo Sapiens console.log(jonas.hasOwnProperty(\u0026#34;species\u0026#34;)); // false 因為不是jonas擁有屬性 而是原型   prototype chain 原型鏈 建構函式 v.s. 原型 v.s. 實例 關係圖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  // 建構函式.prototype = 原型 // 原型.constructor = 建構函式  // 建構函式 const Person = function(firstName, birthYear) { // Instance properties  this.firstName = firstName; this.birthYear = birthYear; }; // new 建構函式 = 實例 const jonas = new Person(\u0026#34;Jonas\u0026#34;, 1991); console.log(jonas); // Person { firstName: \u0026#39;Jonas\u0026#39;, birthYear: 1991 }  // 實例.__proto__ = 物件原型 // jonas的原型是Person，故可以獲取Person的方法或屬性 console.log(jonas.__proto__); //{species: \u0026#39;Homo Sapiens\u0026#39;, calcAge: ƒ (), constructor: ƒ(firstName, birthYear), [[Prototype]]: Object}  // Person的原型是物件原型 (Object.prototype) console.log(jonas.__proto__.__proto__); // {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …} 列出物件方法  // 物件原型的prototype是null(原型鏈chain最上層) console.log(jonas.__proto__.__proto__.__proto__); // null  // 以陣列實例來看原型鏈 const arr = [1, 2, 3]; // 實例的原型是陣列原型Array.prototype，可獲取陣列的方法 console.log(arr.__proto__); // [constructor: ƒ, concat: ƒ, copyWithin: ƒ, fill: ƒ, find: ƒ, …]  // 陣列原型的原型是物件，可獲取物件的方法 console.log(arr.__proto__.__proto__); // {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}  // 物件原型(Object.prototype)的prototype是null(原型鏈chain最上層) console.log(arr.__proto__.__proto__.__proto__); // null   ES6 的 class 建立原型連結 跟 function 一樣有 expression 和 declaration 兩種寫法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // class expression const Person = class { constructor(firstName, birthYear) { this.firstName = firstName; this.birthYear = birthYear; } }; // class declaration（寫起來比上方程式碼工整，都寫在一個物件中，方法不用寫在外面管理) class Person { constructor(firstName, birthYear) { this.firstName = firstName; this.birthYear = birthYear; } // 寫在這邊的方法都會進到prototype  calcAge() { console.log(2037 - this.birthYear); } greet() { console.log(`Hey ${this.fullName}`); } } const jessica = new Person(\u0026#34;Jessica Davis\u0026#34;, 1996); console.log(jessica); // Person {firstName: \u0026#39;Jessica Davis\u0026#39;, birthYear: 1996} jessica.calcAge(); // 41 console.log(jessica.__proto__ === PersonCl.prototype); // true   關於 class 的幾個重點  class 不會被提升 hoisting(即便寫 class declaration) class 具備一級函式特性(可作為參數傳入，也可被回傳) class 須在嚴格模式下執行 class 寫法比第一種(建構函式/const 實例 = new 函式/Person.prototype.方法)更好閱讀與維護，constructor/屬性/方法都寫在 class 裡，方法不需要寫在外面也可以使用 prototype inheritance  getters \u0026amp; setter  所有物件都有的屬性(assessor properties)，相對於一般屬性稱為 data properties 是獲取值或設定值的 function 適合用在 validation  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  const account = { owner: \u0026#34;Jonas\u0026#34;, movements: [200, 530, 120, 300], get latest() { // this.movements.slice(-1)是一個陣列，為了取值用pop  return this.movements.slice(-1).pop(); }, // 需要至少一個參數  set latest(mov) { this.movements.push(mov); }, }; // 像是獲取屬性一樣來使用這個方法 console.log(account.latest); // 300 // 像是更改屬性一樣來使用這個方法 而非account.latest(50) account.latest = 50; console.log(account.movements); // [200, 530, 120, 300, 50]    可以使用剛剛的 Person 來寫個 get 跟 set function  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  class Person { constructor(fullName, birthYear) { // 建構時會使用參數fullName 呼叫set fullName方法  this.fullName = fullName; this.birthYear = birthYear; } calcAge() { console.log(2037 - this.birthYear); } greet() { console.log(`Hey ${this.fullName}`); } get age() { return 2037 - this.birthYear; } // set a property that already exists  // 當使用.fullName就會呼叫這個方法，包含一開始建構實例時  set fullName(name) { console.log(name); if (name.includes(\u0026#34; \u0026#34;)) // set跟 constructor都使用firstName會有衝突 使用另一個變數存  this._fullName = name; else alert(`${name}is not a full name`); } // jessica.fullName才不會undefined  get fullName() { return this._fullName; } } const jessica = new Person(\u0026#34;Jessica Davis\u0026#34;, 1996); console.log(jessica.age); // 41  const walter = new Person(\u0026#34;Walter\u0026#34;, 1996); // Walter is not a full name   static methods  使用關鍵字 static 來定義一個靜態的方法（method）給類別（class），靜態方法在由類別所建立的物件實體（instance）上不能被呼叫，靜態方法只能由類別本身呼叫 例如 Array.from() 可以把類陣列轉成陣列，但陣列本身不能呼叫這個方法 因為這個方法是放在 Array constructor 身上，而非陣列的原型，所以陣列無法獲取  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69  class Person { constructor(fullName, birthYear) { this.fullName = fullName; this.birthYear = birthYear; } calcAge() { console.log(2037 - this.birthYear); } greet() { console.log(`Hey ${this.fullName}`); } get age() { return 2037 - this.birthYear; } set fullName(name) { console.log(name); if (name.includes(\u0026#34; \u0026#34;)) this._fullName = name; else alert(`${name}is not a full name`); } get fullName() { return this._fullName; } } // 這種寫法方法不會更新在原型，jonas無法繼承 Person.hey = function() { console.log(\u0026#34;hey\u0026#34;, this); }; Person.hey(); // hey class Person {...省略} (this會是建構函式本身) jonas.hey(); // Uncaught TypeError: jonas.hey is not a function  // 使用static關鍵字，可出現跟上方一樣的結果 class Person { constructor(fullName, birthYear) { this.fullName = fullName; this.birthYear = birthYear; } // 實例可以獲取的方法 會被加入原型.prototype property  calcAge() { console.log(2037 - this.birthYear); } greet() { console.log(`Hey ${this.fullName}`); } get age() { return 2037 - this.birthYear; } set fullName(name) { console.log(name); if (name.includes(\u0026#34; \u0026#34;)) this._fullName = name; else alert(`${name}is not a full name`); } get fullName() { return this._fullName; } // 建構時才能獲取的方法，實例無法獲取  static hey() { console.log(\u0026#34;hey\u0026#34;, this); } }    另一個小練習，get set 時使用另一個變數名(speedUS 而非 speed)就不用擔心撞變數名的問題  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class Car { constructor(make, speed) { this.make = make; this.speed = speed; } accelerate() { this.speed += 10; console.log(`${this.make}is going at ${this.speed}km/h`); } brake() { this.speed -= 5; console.log(`${this.make}is going at ${this.speed}km/h`); } get speedUS() { return this.speed / 1.6; } set speedUS(speed) { this.speed = speed * 1.6; } } const ford = new CarCl(\u0026#34;Ford\u0026#34;, 120); console.log(ford.speedUS); // 75 ford.accelerate(); // Ford is going at 130km/h ford.accelerate(); // Ford is going at 140km/h ford.brake(); // // Ford is going at 135km/h ford.speedUS = 50; // 50 console.log(ford); //Car{make:\u0026#34;Ford\u0026#34;, speed: 80}   Object.create() 建立原型連結  不需要寫建構函式 constructor new，或是.prototype 下方範例一般不會這樣做，顯示機制用  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  const PersonProto = { // 可以不需要寫constructor  calcAge() { console.log(2037 - this.birthYear); }, }; // 建立原型連結到steven const steven = Object.create(PersonProto); console.log(steven); // 手動增加原型內容 steven.name = \u0026#34;Steven\u0026#34;; steven.birthYear = 2002; steven.calcAge(); //35 // {} \u0026gt; __proto__: calcAge: f calcAge()  console.log(steven.__proto__ === PersonProto); //true  // 建立原型連結到sarah const sarah = Object.create(PersonProto); const PersonProto = { // 不需要寫constructor  // 建立一個方法來新增屬性，相較上面一個個新增  init(firstName, birthYear) { this.firstName = firstName; this.birthYear = birthYear; }, calcAge() { console.log(2037 - this.birthYear); }, }; // 誰呼叫this就是誰 sarah.init(\u0026#34;Sarah\u0026#34;, 1979); sarah.calcAge(); // 58   class 間的繼承: 父類別 parent class \u0026amp; 子類別 child class  了解如何用 Object.create()在 class 間設置原型鏈，讓父類別原型方法跟屬性可以被子類別繼承 子類別繼承父類別的方法跟屬性，也可以有自己的方法跟屬性 當子層父層有一樣名稱的方法，會用子層的  使用建構函式跟 new 運算子建立父子類別繼承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // 人類原型 const Person = function(firstName, birthYear) { this.firstName = firstName; this.birthYear = birthYear; }; // 人類原型建立方法 Person.prototype.calcAge = function() { console.log(2037 - this.birthYear); }; // 學生原型 const Student = function(firstName, birthYear, course) { // 呼叫人類屬性  // 如果用一般函式呼叫(沒有用new) Person(firstName, birthYear) 會Uncaught Error: cannot set firstName of undefined  // a regular function call, the this keyword is set to undefined  // 如果需要呼叫函式並設置this在這個函式，使用call  Person.call(this, firstName, birthYear); this.course = course; }; // 使用Object.create建立原型連結 // 新增任何子類別原型的方法前，需要先建立連結，下方會回傳空物件，若順序錯誤空物件會覆蓋掉新增的方法 Student.prototype = Object.create(Person.prototype); // 學生原型建立方法 Student.prototype.introduce = function() { console.log(`My name is ${this.firstName}and I study ${this.course}`); }; // 建立一個學生 const mike = new Student(\u0026#34;Mike\u0026#34;, 2020, \u0026#34;Computer Science\u0026#34;); mike.introduce(); // 成功呼叫到父類別方法，跟scope chain一樣當子層找不到會往父層找 // 若子層有定義自己的calcAge()，會呼叫子層的方法 mike.calcAge(); // 17    子類別實例跟子類別跟父類別關係  1 2 3 4 5 6 7 8 9 10 11  // 學生原型 可以看到introduce方法 console.log(mike.__proto__); // Person { introduce: [Function (anonymous)] } // 人類原型 可以看到calcAge方法 console.log(mike.__proto__.__proto__); // { calcAge: [Function (anonymous)] }  console.log(mike instanceof Student); // true console.log(mike instanceof Person); // true 若沒有上面建立連結會是false console.log(mike instanceof Object); // true  Student.prototype.constructor = Student; // 加上這行fix mike的constructor指向ㄎ console.dir(Student.prototype.constructor); // 若沒有上面這行會指向Person   使用 ES6 class 建立父子類別繼承  使用 extend 父類別 搭配 super 父類別參數 super 是父層的建構函式 constructor  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  // 人類原型 class Person { constructor(firstName, birthYear) { this.firstName = firstName; this.birthYear = birthYear; } // 人類原型建立方法  calcAge = function() { console.log(2037 - this.birthYear); }; } // 學生原型 不用寫父層.call 用extends就會指向父層了 class Student extends Person { constructor(firstName, birthYear, course) { // super永遠寫在最上面 子層的this  super(firstName, birthYear); this.course = course; } introduce() { console.log(`My name is ${this.firstName}and I study ${this.course}`); } // 覆寫父層方法  // calcAge() {  // console.log(`i am ${2037- this.birthYear}`)  // } } // 使用Object.create建立原型連結，讓兩個class建立父子關係 // 在添加任何學生原型的方法前，需要先建立連結，因為下方會先回傳空物件，若順序錯誤空物件會覆蓋掉新增的方法 Student.prototype = Object.create(Person.prototype); // 建立一個學生 const mike = new Student(\u0026#34;Mike\u0026#34;, 2020, \u0026#34;Computer Science\u0026#34;); mike.introduce(); // My name is Mike and I study Computer Science  // 成功呼叫到父類別方法，若子層有同樣calcAge()則會呼叫子層方法 mike.calcAge(); // 17   使用 Object.create 建立父子類別繼承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  const PersonProto = { calcAge() { console.log(2037 - this.birthYear); }, init(firstName, birthYear) { this.firstName = firstName; this.birthYear = birthYear; }, }; // 使用Object.create建立原型連結 const StudentProto = Object.create(PersonProto); // 使用Object.create建立原型連結 const jay = Object.create(StudentProto); // 子層新增相同名稱方法 StudentProto.init = function(firstName, birthYear, course) { // 呼叫函式並設置this在這個函式，使用call 獲取父層init方法  PersonProto.init.call(this, firstName, birthYear); this.course = course; }; // 子層新增不同方法 StudentProto.introduce = function() { console.log(`My name is ${this.firstName}and I study ${this.course}`) }; jay.init(\u0026#34;Jay\u0026#34;, 2010, \u0026#34;computer science\u0026#34;); jay.introduce() // My name is Jay and I study computer science jay.calcAge() // 27   jay.init(\u0026ldquo;Jay\u0026rdquo;, 2010, \u0026ldquo;computer science\u0026rdquo;); jay.introduce() // My name is Jay and I study computer science jay.calcAge() // 27\n   ","date":"2022-01-14T00:00:00+08:00","image":"https://bacnotes.github.io/p/object-oriented-programming/pexels-j%C3%A9shoots-271458_hu3d03a01dcc18bc5be0e67db3d8d209a6_2056159_120x120_fill_q75_box_smart1.jpg","permalink":"https://bacnotes.github.io/p/object-oriented-programming/","title":"今晚，我們來聊點物件導向程式設計(Object-Oriented Programming) ｜bacnotes備份筆記"},{"content":"之前在JavaScript 底層運作原理 101，介紹過 primitives 跟 objects 使用記憶體的方式有所不同，也在JavaScript 基礎知識複習(2)，補充中提到 primitives 賦值時是 傳值 ，而陣列、物件賦值時是 傳址\n在這篇文章，我們會繼續介紹傳址跟傳值在函式傳遞參數(arguments)時，primitives 跟 objects 兩者表現會有什麼不同\n 參數為primitives，直接傳值(flightNum)，若為objects則會傳址(passenger) 下方checkIn函式會把passenger裡面的屬性name加上一個稱謂  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // 有一個字串資料跟一個物件資料 const flight = \u0026#39;LH234\u0026#39;; const jonas = { name: \u0026#39;Jonas Schmedtmann\u0026#39;, passport: 24739479284, }; const checkIn = function(flightNum, passenger) { // flightNum 只是一個flight字串值的copy 兩者使用不同記憶體  flightNum = \u0026#39;LH999\u0026#39;; // passenger.name 則是直接把記憶體傳過去 使用同一份記憶體  passenger.name = \u0026#39;Mr. \u0026#39; + passenger.name; if (passenger.passport === 24739479284) { console.log(\u0026#39;Checked in\u0026#39;); } else { console.log(\u0026#39;Wrong passport!\u0026#39;); } }; // flight是一個primitives 傳值進function // jonas是一個object 傳址進function checkIn(flight, jonas); // Checked in  console.log(flight); // flight變數(primitives): LH234 沒有變 console.log(jonas); // person.name(物件屬性)：Mr.Jonas Schmedtmann 改變到原資料    當兩個函式不做淺拷貝直接操作同一個物件，因為傳址，物件內容被修改  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  const flight = \u0026#39;LH234\u0026#39;; const jonas = { name: \u0026#39;Jonas Schmedtmann\u0026#39;, passport: 24739479284, }; const flightNum = flight; const passenger = jonas; const checkIn = function(flightNum, passenger) { flightNum = \u0026#39;LH999\u0026#39;; // 修改記憶體中的值  passenger.name = \u0026#39;Mr. \u0026#39; + passenger.name; if (passenger.passport === 24739479284) { console.log(\u0026#39;Checked in\u0026#39;); } else { console.log(\u0026#39;Wrong passport!\u0026#39;); } }; const newPassport = function(person) { person.passport = Math.trunc(Math.random() * 100000000000); }; newPassport(jonas); // a random number checkIn(flight, jonas); // Wrong passport! (因為改到passport號碼)    大型專案有時候因為不經意的修改到物件資料，會造成很大的影響，所以需要多注意傳址傳值的概念  First-Class Function 一級函式 之前介紹 JavaScript 語言特性時，有提到 JavaScript 有一級函式的特性 因此我們可以使用 higher-order function：\n 可以把 function 當參數傳入另一個 function(又被稱作回呼函式) 可以 function return function  callback function 回呼函式 回呼函式 callback function 是把函式當作另一個函式的參數，透過另一個函式來呼叫它 只是通常提到的場景是在處理非同步的時候\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  // 把所有英文字空白去掉，把字拼在一起的函式 const oneWord = function(str) { return str.replace(/ /g, \u0026#39;\u0026#39;).toLowerCase(); }; // 把第一個英文字都轉大寫字的函式 const upperFirstWord = function(str) { const [first, ...others] = str.split(\u0026#39; \u0026#39;); return [first.toUpperCase(), ...others].join(\u0026#39; \u0026#39;); }; // Higher-order function 字串跟函式為參數 const transformer = function(str, fn) { console.log(`Original string: ${str}`); console.log(`Transformed string: ${fn(str)}`); console.log(`Transformed by: ${fn.name}`); }; // 回呼函式範例1 transformer(\u0026#39;JavaScript is the best!\u0026#39;, upperFirstWord); // Original string: JavaScript is the best! // Transformed string: JAVASCRIPT is the best! // Transformed by: upperFirstWord  // 回呼函式範例2 transformer(\u0026#39;JavaScript is the best!\u0026#39;, oneWord); // Original string: JavaScript is the best! // Transformed string: javascriptisthebest! // Transformed by: oneWord   Function return function  可以把函式一層層封裝起來，讓外層只傳入一個參數，function programming 常用的程式設計技巧，有助於重複利用程式碼 ＊柯里化：把接受多個參數的函數變換成接受一個單一參數（最初函數的第一個參數）的函數，並且返回接受餘下的參數而且返回結果的新函數的技術 因為 Function return function 會創造閉包，閉包是函式本身及函式被建立時的執行文本(execution context)，因此下方 greeting 的參數 Hey 會被記住  1 2 3 4 5 6 7 8 9 10 11 12 13 14  const greet = function(greeting) { return function(name) { console.log(`${greeting}${name}`); }; }; const greeterHey = greet(\u0026#39;Hey\u0026#39;); greeterHey(\u0026#39;Jonas\u0026#39;); // Hey Jonas greeterHey(\u0026#39;Steven\u0026#39;); // Hey Stevens  greet(\u0026#39;Hello\u0026#39;)(\u0026#39;Jonas\u0026#39;); // Hello Jonas  // ＊補充上方的greet函式也可以寫成箭頭函式 const greet = (greeting) =\u0026gt; (name) =\u0026gt; console.log(`${greeting}${name}`);   Call \u0026amp; Apply 綁定 this 對象 當我們開發程式後可能會複用不同物件內的方法，但如果你只 copy 方法，使用一般函式呼叫，會發現 this undefined，符合我們之前提到的一般函式呼叫的狀況下，嚴格模式下 this 是 undefined（非嚴格模式下為全域物件） 這個時候你就需要使用 Call 或 Apply 來告訴程式 this 要綁定的對象\n使用 Call 方法  call(thisArg, arg1, \u0026hellip; , argN)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  const lufthansa = { airline: \u0026#39;Lufthansa\u0026#39;, iataCode: \u0026#39;LH\u0026#39;, bookings: [], // book: function() {}  book(flightNum, name) { console.log( `${name}booked a seat on ${this.airline}flight ${this.iataCode}${flightNum}` ); this.bookings.push({ flight: `${this.iataCode}${flightNum}`, name }); }, }; lufthansa.book(239, \u0026#39;Jonas Schmedtmann\u0026#39;); lufthansa.book(635, \u0026#39;John Smith\u0026#39;); // 也想在這邊使用上面book的方法 const eurowings = { airline: \u0026#39;Eurowings\u0026#39;, iataCode: \u0026#39;EW\u0026#39;, bookings: [], }; // copy方法，內容為push一段文字到bookings const book = lufthansa.book; // 若直接用一般函式呼叫 not work book(23, \u0026#39;Sarah Williams\u0026#39;); // Uncaught TypeError: Cannot read property \u0026#39;airline\u0026#39; of undefined  // 不是去呼叫 book函式而是return 新的函式綁定this對象為eurowings book.call(eurowings, 23, \u0026#39;Sarah Williams\u0026#39;); console.log(eurowings); // 的確有使用book方法把資料push進來了  // { // airline: \u0026#39;Eurowings\u0026#39;, // iataCode: \u0026#39;EW\u0026#39;, // bookings: [ { flight: \u0026#39;EW23\u0026#39;, name: \u0026#39;Sarah Williams\u0026#39; } ] // }   使用 Apply 方法  apply(thisArg, argsArray) Call 跟 Apply 差別在參數傳入的資料結構的不同，使用 Apply 綁定時，參數需要放在陣列當中，Call 則是直接寫在()中。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // 定義另一個物件 const swiss = { airline: \u0026#39;Swiss Air Lines\u0026#39;, iataCode: \u0026#39;LX\u0026#39;, bookings: [], }; // 參數放入陣列 const flightData = [583, \u0026#39;George Cooper\u0026#39;]; book.apply(swiss, flightData); // 可以看到的確有使用到這個方法推新資料進去 console.log(swiss); // { // airline: \u0026#39;Swiss Air Lines\u0026#39;, // iataCode: \u0026#39;LX\u0026#39;, // bookings: [ { flight: \u0026#39;LX583\u0026#39;, name: \u0026#39;George Cooper\u0026#39; } ] // }  // 若使用call需要展開陣列，直接傳參數本身 book.call(swiss, ...flightData);   不會馬上執行函式的綁定方法：Bind  bind(thisArg, arg1, \u0026hellip; , argN) bind 是創造一個函式物件的拷貝，不會執行函式 因此 bind 之後還要再另外寫執行函式的動作()，而 call 是直接執行函式  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  // 使用剛剛的物件跟原型方法 const lufthansa = { airline: \u0026#39;Lufthansa\u0026#39;, iataCode: \u0026#39;LH\u0026#39;, bookings: [], // book: function() {}  book(flightNum, name) { console.log( `${name}booked a seat on ${this.airline}flight ${this.iataCode}${flightNum}` ); this.bookings.push({ flight: `${this.iataCode}${flightNum}`, name }); }, }; const book = lufthansa.book; const eurowings = { airline: \u0026#39;Eurowings\u0026#39;, iataCode: \u0026#39;EW\u0026#39;, bookings: [], }; // 複習一下 下方是return新的函式綁定this對象為eurowings // book.call(eurowings, 23, \u0026#39;Sarah Williams\u0026#39;);  // 使用這個邏輯把指向不同對象的book函式存到不同變數 const bookEW = book.bind(eurowings); const bookLH = book.bind(lufthansa); const bookLX = book.bind(swiss); bookEW(23, \u0026#39;Steven Williams\u0026#39;); // 測試一下有work! Steven Williams booked a seat on Eurowings flight EW23  // 層層參數綁定 const bookEW23 = book.bind(eurowings, 23); // 只需要傳一個參數進去就可以呼叫裡面的方法，柯里化 bookEW23(\u0026#39;Jonas Schmedtmann\u0026#39;); bookEW23(\u0026#39;Martha Cooper\u0026#39;);    另一個常用的場景是監聽事件  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // With Event Listeners lufthansa.planes = 300; // 計數器 lufthansa.buyPlane = function() { console.log(this); // 使用監聽時 this指向觸發event元素  this.planes++; console.log(this.planes); }; lufthansa.buyPlane(); // 的確有+1 變成301  document .querySelector(\u0026#39;.buy\u0026#39;) // 我們不希望立即觸發所以使用bind綁定this指向對象，等click再執行  .addEventListener(\u0026#39;click\u0026#39;, lufthansa.buyPlane.bind(lufthansa));    當函式執行內容不包含 this，還是可以使用 Bind 綁定非 this 部分的參數，讓函式更有彈性的被執行 不需要 this 的狀況下寫 null 即可  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 不同稅率的計算應用 const addTax = (rate, value) =\u0026gt; value + value * rate; // 一般函式下操作 console.log(addTax(0.1, 200)); // 220  // 用bind綁定稅率23% const addVAT = addTax.bind(null, 0.23); // 等於 addVAT = value =\u0026gt; value + value * 0.23;  console.log(addVAT(100)); // 123  // 嘗試用function return function 改寫上面bind方法 const addTax = function(rate) { return function(value) { return value + value * rate; }; }; const addVAT = addTax(0.23);   Immediately Invoked Function Expressions (IIFE) 立即執行函式  只會執行一次的函式，執行完就馬上消失 函式會創造作用域，外部無法獲取內部的變數 不會污染外部變數，適合用在第三方函式庫  1 2 3 4 5 6 7 8  (function() { statements; })(); // 也可以寫箭頭函式 (() =\u0026gt; statements)() // 但不會存取在一個變數裡const abc = function () {statements}    在之前的文章有介紹過，const let 也會創造出 block 作用域，外部無法獲取內部參數 但 var 會被獲取到  1 2 3 4 5 6 7 8  // block區域 { const state = 123; var state2 = 123; } console.log(state); // Uncaught ReferenceError: state is not defined console.log(state2); // 123    因為有了 let const 限制住作用域，因此在 ES6 後就比較少使用到 IIFE  Closure 閉包  閉包（Closure）是函式以及該函式被宣告時所在的作用域環境（lexical environment）的組合 如果是第一次接觸閉包觀念應該會有下方反應   這部分會需要知道什麼是作用域跟執行文本，不熟的話可以看一下這篇 JavaScript 底層運作原理 101再回來 我們以下方函式來講解閉包的運作 step1. 創造全域執行文本  全域變數環境：secureBooking=fn, booker=fn   step2. 執行全域執行文本，創造出個別執行文本  secureBooking()作用域：可以獲取本地作用域跟父層的環境變數 變數環境：passengerCount=0, secureBooking=fn 程式跑到 return function 後，secureBooking()執行文本消失，回傳的 function 指派給 booker 變數環境：passengerCount=0, secureBooking=fn, booker=fn   step3. 執行個別文本 執行 booker()  變數環境：empty, secureBooking=fn, booker=fn) 由於所有函式都可以獲取被創造當下的執行文本(execution context)的變數環境(variable environment) 因為 booker 是全域下的變數，所以可取得全域的secureBooking=fn, booker=fn的變數環境，而secureBooking()的變數環境裡面有passengerCount=0    1 2 3 4 5 6 7 8 9 10  const secureBooking = function() { let passengerCount = 0; return function() { passengerCount++; console.log(`${passengerCount}passenger`); }; }; const booker = secureBooking(); booker(); // 1 passenger   step 1 \u0026amp; 2 創造＆執行全域執行文本，創造出個別執行文本\nstep 3 執行個別文本\n總結  閉包的存在建立在所有函式都可以獲取被創造當下的執行文本的變數環境的機制下 即便執行文本已經被銷毀，函式還是可以透過某種 ref 獲取到這個變數環境 所以可以取得 passengerCount = 0 的值，且可以持續更新這個變數  1 2 3  booker(); // 1 passenger booker(); // 2 passenger booker(); // 3 passenger   註：如果想知道這個神秘的Closure變數存在哪裡的話，可以在devtools裡console.dir偷偷看一下匿名函式的[[Scopes]]下Closure的passengerCount變數。但因為是private作用域所以無法存取或修改。\n1 2 3 4 5 6 7 8  console.dir(booker); // ...[ [Scopes] ]: Scopes[3] 0: Closure(secureBooking) { passengerCount: 0 }   ","date":"2022-01-12T00:00:00+08:00","image":"https://bacnotes.github.io/p/javascript-advanced-part1/javascript-removebg-preview_hu5afc4de35f8caf4a9ddf52b81b394066_38619_120x120_fill_box_smart1_3.png","permalink":"https://bacnotes.github.io/p/javascript-advanced-part1/","title":"JavaScript 進階函式知識 ｜bacnotes備份筆記"},{"content":"歡迎來到JavaScript基礎知識複習(3)，還記得 \u0026amp;\u0026amp; || ?? 這三個邏輯運算子嗎？其實他們可以跟指派運算子一起使用，如果沒有接觸過的可以先看看第一篇JavaScript 基礎知識複習(1)再來往下看唷\n邏輯運算子 + 指派運算子 \u0026amp;\u0026amp;= ||= ??=  下方是兩個餐廳資料物件，彼此的屬性略有不同  1 2 3 4 5 6 7 8 9  const restaurant1 = { name: \u0026#34;Carpi\u0026#34;, numGuests: 20, }; const restaurant2 = { name: \u0026#34;La Piazza\u0026#34;, owner: \u0026#34;Giovanni Rossi\u0026#34;, };    當想增加物件內的屬性，可以用邏輯運算子的方式添加  1 2 3 4  restaurant1.numGuests = restaurant1.numGuests || 10; // 屬性存在不會有變動 restaurant2.numGuests = restaurant2.numGuests || 10; // 沒有這個屬性，新增一個numGuests: 10 console.log(restaurant1); // { name: \u0026#39;Carpi\u0026#39;, numGuests: 20 } console.log(restaurant2); // { name: \u0026#39;La Piazza\u0026#39;, owner: \u0026#39;Giovanni Rossi\u0026#39;, numGuests: 10 }    但還可以寫得更精簡，使用邏輯運算子 + 指派運算子，跟上方的結果是一樣的  1 2 3 4  restaurant1.numGuests || = 10; // 屬性存在不會有變動 restaurant2.numGuests || = 10; // 沒有這個屬性，新增一個numGuests: 10 console.log(restaurant1); // { name: \u0026#39;Carpi\u0026#39;, numGuests: 20 } console.log(restaurant2); // { name: \u0026#39;La Piazza\u0026#39;, owner: \u0026#39;Giovanni Rossi\u0026#39;, numGuests: 10 }    遇到 numGuests 數量為0，會因 falsy 更新成後面的值，這個邏輯不是我們期待的結果可以使用??= 的方式避免這個問題 當屬性 null 不存在或 undefined，使用後方的值增加這個屬性  1 2 3 4  restaurant1.numGuests ?? = 10; restaurant2.numGuests ?? = 10; console.log(restaurant1); // { name: \u0026#39;Carpi\u0026#39;, numGuests: 20 } console.log(restaurant2); // { name: \u0026#39;La Piazza\u0026#39;, owner: \u0026#39;Giovanni Rossi\u0026#39;, numGuests: 10 }    當我們想更新屬性值的時候則可以使用\u0026amp;\u0026amp;=，如果這個屬性不存在會回傳 undefined  1 2 3 4 5 6 7  // 更新第一家餐廳的客戶數量 restaurant1.numGuests \u0026amp;\u0026amp; = 300; console.log(restaurant1); // {name: \u0026#39;Carpi\u0026#39;, numGuests: 300}  // 更新第二家餐廳的owner restaurant2.owner \u0026amp;\u0026amp; = \u0026#34;Mars\u0026#34;; console.log(restaurant2); // {name: \u0026#39;La Piazza\u0026#39;, owner: \u0026#39;Mars\u0026#39;, numGuests: 10}   for 迴圈語法糖：for of 迭代元素、for in 迭代屬性  每次寫 for 迴圈都覺得寫計數器跟迭代條件很麻煩嗎？其實還有更簡單的寫法 一樣可以搭配使用 continue 跟 break 語法  for of 迴圈迭代陣列裡的元素  for (const 陣列元素 of 陣列) 迭代元素  1 2 3 4 5 6 7 8  const menu = [\u0026#34;Focaccia\u0026#34;, \u0026#34;Bruschetta\u0026#34;, \u0026#34;Garlic Bread\u0026#34;]; for (const item of menu) { console.log(item); } // Focaccia // Bruschetta // Garlic Bread   for in 迴圈迭代物件屬性  for in 迭代屬性  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const openingHours = { mon: { open: 10, close: 16, }, tue: { open: 12, close: 18, }, }; for (const day in openingHours) { console.log(day); } // mon // tue    for in 搭配取值的bracket[]迭代值  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const openingHours = { mon: { open: 10, close: 16, }, tue: { open: 12, close: 18, }, }; for (const day in openingHours) { console.log(openingHours[day]); } // mon // tue    for..in 不應該用來迭代一個索引順序很重要的陣列。陣列索引只是以整數命名的可列舉屬性，其他方面等同於一般物件屬性。無法擔保 for\u0026hellip;in 以特定順序傳回索引，並且它將傳回全部可列舉屬性，包括非整數名的，以及繼承而來的可列舉屬性。  使用 Object.keys()、Object.values() 迭代物件屬性名或值 Object.keys 迭代物件屬性名成一個陣列  Object.keys(obj)  1 2 3 4 5 6 7 8 9 10 11 12  const openingHours = { mon: { open: 10, close: 16, }, tue: { open: 12, close: 18, }, }; console.log(Object.keys(openingHours)); // [\u0026#39;mon\u0026#39;, \u0026#39;tue\u0026#39;]   1 2 3 4 5 6 7  -Object.keys() 可搭配 for of 迭代出陣列元素(值) for (const day of Object.keys(openingHours)) { console.log(day) } // mon // tue    跟 for in 迴圈迭代順序相同但 for in 還會列舉出 prototype 的屬性  Object.values 迭代物件值成一個陣列  Object.values(obj)  1 2 3 4 5 6 7 8 9 10 11 12  const openingHours = { mon: { open: 10, close: 16, }, tue: { open: 12, close: 18, }, }; console.log(Object.values(openingHours)); // [{open: 10, close: 16}, {open: 12, close: 18}]   同時迭代陣列或物件的屬性跟值：陣列.entries() Object.entries(Obj) 陣列 array.prototype.entries() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  const menu = [\u0026#34;Focaccia\u0026#34;, \u0026#34;Bruschetta\u0026#34;, \u0026#34;Garlic Bread\u0026#34;]; for (const item of menu.entries()) { console.log(item); } // [ 0, \u0026#39;Focaccia\u0026#39; ] // [ 1, \u0026#39;Bruschetta\u0026#39; ] // [ 2, \u0026#39;Garlic Bread\u0026#39; ]  // ...展開陣列 for (const item of menu.entries()) { console.log(...item); } // 0 Focaccia // 1 Bruschetta // 2 Garlic Bread  // 使用解構賦值，並從1開始呈現 for (const [index, item] of menu.entries()) { console.log(`${index + 1}: ${item}`); } // 1: Focaccia // 2: Bruschetta // 3: Garlic Bread   物件 Object.entries(obj)  跟 for in 迴圈迭代順序相同但 for in 還會列舉出 prototype 的屬性  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  const openingHours = { mon: { open: 10, close: 16, }, tue: { open: 12, close: 18, }, }; // 屬性key 值value for (const [key, { open, close }] of Object.entries(openingHours)) { console.log(`On ${key}, we open at${open}and close at ${close}`); } // On mon, we open at10 and close at 16 // On tue, we open at12 and close at 18   Enhanced Object Literals 當變數跟屬性名稱相同可省略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // 變數name 跟 openingHours const name = \u0026#39;Great Restaurant\u0026#39;, const openingHours = { mon: { open: 10, close: 16, }, tue: { open: 12, close: 18 } } // 以往物件賦值，需要屬性key跟值value都寫上去 const restaurant = { name: name, openingHours: openingHours, location: \u0026#39;France\u0026#39; } // 現在只要屬性跟變數名一樣，單寫屬性就好，程式碼會幫你把值對起來 const restaurant = { name, openingHours, location: \u0026#39;France\u0026#39; }   物件方法可省略冒號跟 function 1 2 3 4 5 6 7 8 9  // 過去會寫成 order: function(a, b) { return a + b } // 可以簡寫成 長得就跟宣告函式一樣 order(a, b) { return a + b }   表達式作為物件的屬性名 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const weekdays = [\u0026#34;mon\u0026#34;, \u0026#34;tue\u0026#34;, \u0026#34;wed\u0026#34;, \u0026#34;thu\u0026#34;, \u0026#34;fri\u0026#34;]; const openingHours = { [weekdays[2]]: { open: 12, close: 18, }, [`day-${2 + 4}`]: { open: 13, close: 19, }, }; console.log(openingHours); // day-6: {open: 13, close: 19} // wed: {open: 12, close: 18}   Optional Chaining(ES2020) ?.  當資料本身很多屬性且每筆資料不一定存在這個屬性，讀取到不存在的屬性會跳出 Uncaught TypeError 使用?. 讀取屬性，若不存在 null 或 undefined，會立即回傳 undefined，可以避免上方的 Uncaught TypeError 若為 0 \u0026lsquo;\u0026lsquo;會回傳相對應的值，只有 null undefined 會回傳 undefined 常搭配?? 一起使用  屬性加上 Optional Chaining 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  const openingHours = { mon: { open: 10, close: 16, }, tue: { open: 12, close: 18 }, wed: { open: 12, close: 18 } } const restaurant = { name: \u0026#39;Great restaurant\u0026#39;, openingHours } // 使用邏輯運算子的寫法 當屬性存在才執行（但資料一多會吐血） if (restaurant.openingHours \u0026amp;\u0026amp; restaurant.openingHours.mon) console.log(restaurant.openingHours.mon.open) // 使用Optional Chaining的寫法 簡短 console.log(restaurant.openingHours?.mon?.open) // 加上迭代for of 想知道平日幾點開門 const weekdays = [\u0026#39;mon\u0026#39;, \u0026#39;tue\u0026#39;, \u0026#39;wed\u0026#39;, \u0026#39;thu\u0026#39;, \u0026#39;fri\u0026#39;] for (const weekday of weekdays) { // 避免undefined出現 使用??設定預設值 not open  const open = restaurant.openingHours[weekday]?.open ?? \u0026#39;not open\u0026#39; console.log(`On ${weekday}, ${open}`) } // On mon, 10 // On tue, 12 // On wed, 12 // On thu, not open // On fri, not open   物件方法加上 Optional Chaining  確認方法是否存在  1 2 3 4 5 6 7 8 9 10 11 12 13  const restaurant = { order(starterIndex, mainIndex) { return \u0026#34;Order!\u0026#34;; }, orderDelivery({ starterIndex = 1, mainIndex }) { return \u0026#34;OrderDelivery!\u0026#34;; }, }; console.log(restaurant.order?.(0, 1) ?? \u0026#34;Method not existed\u0026#34;); // Order! console.log(restaurant.orderRisotto?.(0, 1) ?? \u0026#34;Method not exist\u0026#34;); // \u0026#39;Method not exist\u0026#39;   陣列加上 Optional Chaining  檢查陣列是否有資料  1 2 3 4 5 6 7 8 9 10 11  const users = [{ name: \u0026#39;Jonas\u0026#39;, email: \u0026#39;hello@jonas.com\u0026#39; }] // 過去可能要寫 if (users.length \u0026gt; 0) console.log(users[0].name) else console.log(\u0026#39;User array empty\u0026#39;) // 使用Optional Chaining 寫起來更精簡 console.log(users[0]?.name ?? \u0026#39;User array empty\u0026#39;)   Set  長得像陣列，是元素的集合，元素可以是任何資料格式 Set 中所有的元素都是唯一的 (unique values)，不會有重複的值，當你存入重複的元素(值)會被忽略 Set 內部會用 === 來判斷是否有重複值，唯一的例外是 NaN 會被判斷作是重複的值(雖然 NaN !== NaN) 元素數量計算使用.size  1 2  const someSet = new Set([a, b, c]); console.log(someSet.size); // 3    .has(\u0026lsquo;元素\u0026rsquo;)檢查是否有包含元素  1 2  const someSet = new Set([a, b, c]); console.log(someSet.has(\u0026#34;a\u0026#34;)); // true    增加與刪除元素 .add() .delete() .clear()  1 2 3 4 5 6  someSet.add(\u0026#34;d\u0026#34;); console.log(someSet); // [a, b, c, d] someSet.delete(\u0026#34;a\u0026#34;); console.log(someSet); // [b, c, d] someSet.clear(); console.log(someSet); // []    無法用 index 從 Set 中把值取出，會回傳 undefined 可以迭代  1 2  const someSet = new Set([a, b, c]); for (const item of someSet) console.log(item); // a b c    查詢資料中不重複元素的數量  1 2 3  const classmate = [\u0026#34;a\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;b\u0026#34;]; const classmateSet = new Set(classmate); console.log(classmateSet.size);    把 Set 變不重複元素的陣列  1 2 3  const classmate = [\u0026#34;a\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;b\u0026#34;]; const classmateSet = [...new Set(classmate)]; console.log(classmateSet); // [ \u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;b\u0026#39; ]   Map  長得像物件，key value pair 的組合，可以記住 key 的原始加入 Map 的順序 可以迭代，迭代順序為加入 Map 的順序 在 Map 判斷 NaN 跟 NaN 相等（雖然 NaN !== NaN），剩下的值使用=== 判斷是否相等  新建構一個 Map 1  const restaurant = new Map(); //裡面是空的 跟物件有prototype不同    新增 key 使用.set(key, value) key 值的不限於字串，可以是任何資料型態（number、array、object、function、symbol)  1 2 3 4 5  console.log(restaurant.set(1, \u0026#34;Firenze, Italy\u0026#34;)); // Map(1) { 1 =\u0026gt; \u0026#39;Firenze, Italy\u0026#39; }  console.log(restaurant.set(2, \u0026#34;Tokyo, Japan\u0026#34;)); // Map(2) { 1 =\u0026gt; \u0026#39;Firenze, Italy\u0026#39;, 2 =\u0026gt; \u0026#39;Tokyo, Japan\u0026#39; }    set 的時候不只會更新 Map 內部資料，也會回傳一個新的 Map，所以我們可以連續.set 連續新增很多資料  1 2 3 4 5 6 7 8 9 10 11 12 13  restaurant .set(\u0026#34;categories\u0026#34;, [\u0026#34;Italian\u0026#34;, \u0026#34;Pizzeria\u0026#34;]) .set(\u0026#34;open\u0026#34;, 11) .set(\u0026#34;close\u0026#34;, 23) .set(true, \u0026#34;we are open\u0026#34;); console.log(restaurant); // Map(4) { // \u0026#39;categories\u0026#39; =\u0026gt; [ \u0026#39;Italian\u0026#39;, \u0026#39;Pizzeria\u0026#39; ], // \u0026#39;open\u0026#39; =\u0026gt; 11, // \u0026#39;close\u0026#39; =\u0026gt; 23, // true =\u0026gt; \u0026#39;we are open\u0026#39; // }   使用 get 獲取 key 的對應值 1 2 3  restaurant.set(1, \u0026#34;Test\u0026#34;); console.log(restaurant.get(1)); // \u0026#39;Test\u0026#39;   讀取 key 值加上邏輯判斷做條件渲染 1 2 3 4 5 6 7 8 9 10 11 12 13  // 新增以下key restaurant.set(\u0026#34;open\u0026#34;, 11); restaurant.set(\u0026#34;close\u0026#34;, 21); restaurant.set(true, \u0026#34;we are open\u0026#34;); restaurant.set(false, \u0026#34;we are closed\u0026#34;); // 判斷營業時間 const time = 21; console.log( restaurant.get( time \u0026gt; restaurant.get(\u0026#34;open\u0026#34;) \u0026amp;\u0026amp; time \u0026lt; restaurant.get(\u0026#34;close\u0026#34;) ) ); // we are closed   使用.size 查詢資料長度 1  console.log(restaurant.size); //6   使用 has 確認是否包含某個 key，回傳 true false 1 2  console.log(restaurant.has(true)); //true console.log(restaurant.has(false)); //true   使用 delete 刪除元素 clear 清空元素 1 2 3 4 5 6 7 8 9 10 11  restaurant.delete(1); console.log(restaurant); // Map(5) { // 2 =\u0026gt; \u0026#39;Tokyo, Japan\u0026#39;, // \u0026#39;open\u0026#39; =\u0026gt; 11, // \u0026#39;close\u0026#39; =\u0026gt; 21, // true =\u0026gt; \u0026#39;we are open\u0026#39;, // false =\u0026gt; \u0026#39;we are closed\u0026#39; // } restaurant.clear(); // Map(0) {}    注意：物件如果不是 ref 的方式給值，無法讀取到對應 value  1 2 3 4 5 6 7 8  restaurant.set([1, 2], \u0026#34;Test\u0026#34;); console.log(restaurant.get([1, 2])); // undefined  const arr = [1, 2]; restaurant.set(arr, \u0026#34;Test\u0026#34;); console.log(restaurant.get(arr)); // \u0026#39;Test\u0026#39;   可以綁定 DOM 元素 1 2 3  restaurant.set(document.querySelector(\u0026#34;h1\u0026#34;), \u0026#34;Heading\u0026#34;); console.log(restaurant.get(\u0026#34;h1\u0026#34;)); //Map(1) {h1.bold-title.is-1 =\u0026gt; \u0026#39;Heading\u0026#39;}   物件轉 Map  Object.entries(obj) 組成巢狀陣列，new Map 轉成 Map  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  const openingHours = { mon: { open: 10, close: 16, }, tue: { open: 12, close: 18, }, }; console.log(Object.entries(openingHours)); //[ // [ \u0026#39;mon\u0026#39;, { open: 10, close: 16 } ], // [ \u0026#39;tue\u0026#39;, { open: 12, close: 18 } ] //] // const hoursMap = new Map(Object.entries(openingHours)); console.log(hoursMap); //Map(2) { // \u0026#39;mon\u0026#39; =\u0026gt; { open: 10, close: 16 }, // \u0026#39;tue\u0026#39; =\u0026gt; { open: 12, close: 18 } //}   迭代 Map key value   建議迭代結構為巢狀陣列(同 Object.entries(obj)或[\u0026hellip;array.entries()]輸出的結構) // [[\u0026lsquo;key\u0026rsquo;, {value}], [\u0026lsquo;key\u0026rsquo;, {value}], [\u0026lsquo;key\u0026rsquo;, {value}]]\n  使用展開運算子搭配.keys()或.values()，並將迭代出的元素放入一個新陣列\n  直接使用.keys()或.values()會出現[Map Iterator] { \u0026lsquo;question\u0026rsquo;, 1, 2, 3, \u0026lsquo;correct\u0026rsquo;, true, false }\n  1 2 3 4 5 6 7 8 9  const question = new Map([ [\u0026#34;question\u0026#34;, \u0026#34;What is the best programming language in the world?\u0026#34;], [1, \u0026#34;C\u0026#34;], [2, \u0026#34;Java\u0026#34;], [3, \u0026#34;JavaScript\u0026#34;], [\u0026#34;correct\u0026#34;, 3], [true, \u0026#34;Correct 🎉\u0026#34;], [false, \u0026#34;Try again!\u0026#34;], ]);    先看看展開運算子外層加上陣列的結果 console.log([\u0026hellip;question]) 等於 console.log([\u0026hellip;question.entries())  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  //[ // [ \u0026#39;question\u0026#39;, \u0026#39;What is the best programming language in the world?\u0026#39; ], // [ 1, \u0026#39;C\u0026#39; ], // [ 2, \u0026#39;Java\u0026#39; ], // [ 3, \u0026#39;JavaScript\u0026#39; ], // [ \u0026#39;correct\u0026#39;, 3 ], // [ true, \u0026#39;Correct 🎉\u0026#39; ], // [ false, \u0026#39;Try again!\u0026#39; ] //]  // 迭代Map key console.log([...question.keys()]); // [\u0026#39;question\u0026#39;, 1, 2, 3, \u0026#39;correct\u0026#39;, true, false]  // 迭代Map value console.log([...question.values()]); // [\u0026#39;What is the best programming language in the world?\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;Java\u0026#39;, \u0026#39;JavaScript\u0026#39;, 3, \u0026#39;Correct 🎉\u0026#39;, \u0026#39;Try again!\u0026#39;]  // 問答 console.log(question.get(\u0026#34;question\u0026#34;)); // What is the best programming language in the world? for (const [key, value] of question) { if (typeof key === \u0026#34;number\u0026#34;) console.log(`Answer ${key}: ${value}`); } // Anwser 1: C // Anwser 2: Java // Anwser 3: JavaScript  const answer = Number(prompt(\u0026#34;Your Anwser\u0026#34;)); console.log(answer); // 問答用布林判斷 若答案3 下方判斷是為true 顯示\u0026#39;Correct 🎉\u0026#39; question.get(question.get(\u0026#34;correct\u0026#34;) === answer);   如何決定資料結構 考量資料來源  程式本身 2. UI 互動介面 3. API(JSON 格式{a, b:[{},{}\u0026hellip;], c})  資料結構  list (可用陣列或 set) key value pairs (可用 obj 或 map)  何時適合 Set 而不是陣列呢  需要 list 裡面都是唯一值(不能有重複值) 不需要索引取值 不需要對資料做操作 需要高效能查找  何時適合 Map 而不是物件呢  需要對資料頻繁操作，保持高效能 當資料插入順序是需要考慮的因素 需要使用不同資料型態的 key（不限於 string 和 symbol 作為 key) 方便迭代跟計算大小 size 比較少需要單獨對部分資料做操作(物件比較方便用. 跟[]取值)  課程小練習 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154  // challenge 1 const game = { team1: \u0026#34;Bayern Munich\u0026#34;, team2: \u0026#34;Borrussia Dortmund\u0026#34;, players: [ [ \u0026#34;Neuer\u0026#34;, \u0026#34;Pavard\u0026#34;, \u0026#34;Martinez\u0026#34;, \u0026#34;Alaba\u0026#34;, \u0026#34;Davies\u0026#34;, \u0026#34;Kimmich\u0026#34;, \u0026#34;Goretzka\u0026#34;, \u0026#34;Coman\u0026#34;, \u0026#34;Muller\u0026#34;, \u0026#34;Gnarby\u0026#34;, \u0026#34;Lewandowski\u0026#34;, ], [ \u0026#34;Burki\u0026#34;, \u0026#34;Schulz\u0026#34;, \u0026#34;Hummels\u0026#34;, \u0026#34;Akanji\u0026#34;, \u0026#34;Hakimi\u0026#34;, \u0026#34;Weigl\u0026#34;, \u0026#34;Witsel\u0026#34;, \u0026#34;Hazard\u0026#34;, \u0026#34;Brandt\u0026#34;, \u0026#34;Sancho\u0026#34;, \u0026#34;Gotze\u0026#34;, ], ], score: \u0026#34;4:0\u0026#34;, scored: [\u0026#34;Lewandowski\u0026#34;, \u0026#34;Gnarby\u0026#34;, \u0026#34;Lewandowski\u0026#34;, \u0026#34;Hummels\u0026#34;], date: \u0026#34;Nov 9th, 2037\u0026#34;, odds: { team1: 1.33, x: 3.25, team2: 6.5, }, }; // 分組 const [players1, players2] = game.players; console.log(players1); console.log(players2); // 組裡面有兩種角色 守門員gk跟 其他球員 const [gk, ...fieldPlayers] = players1; console.log(gk, fieldPlayers); // 把所有隊伍人的放進去一個陣列 const allPlayers = [...players1, ...players2]; console.log(allPlayers); // 新增三個候補 const players1Final = [...players1, \u0026#34;Thiago\u0026#34;, \u0026#34;Coutinho\u0026#34;, \u0026#34;Perisic\u0026#34;]; console.log(players1Final); // 解構賦值取出變數 x的變數名改為draw const { odds: { team1, x: draw, team2 }, } = game; console.log(team1, draw, team2); // 丟一堆名字進去，使用其餘運算子合併成陣列，length計算長度 function printGoals(...players) { console.log(`${players.length}goals were scored`); } printGoals(\u0026#34;Davies\u0026#34;, \u0026#34;Muller\u0026#34;, \u0026#34;Lewandowski\u0026#34;, \u0026#34;Kimmich\u0026#34;); // 勝率比大小 上面已經有寫出team1勝率跟team2勝率 team1 \u0026gt; team2 \u0026amp;\u0026amp; console.log(\u0026#34;Team 1 is more likely to win\u0026#34;); team1 \u0026lt; team2 \u0026amp;\u0026amp; console.log(\u0026#34;Team 2 is more likely to win\u0026#34;); // challenge 2 // 依序列印出game.scored array 裡面的球員 Goal 1: Lewandowski for (const [index, item] of game.scored.entries()) console.log(`Goal ${index + 1}: ${item}`); // 需要算出team1 x team2平均數 累加value / 長度 const odds = Object.values(game.odds); // [ 1.33, 3.25, 6.5 ] let sum = 0; for (const item of odds) { sum += item; } console.log(sum / odds.length); // 列印出 // Odd of victory Bayern Munich: 1.33 // Odd of draw: 3.25 // Odd of victory Borrussia Dortmund: 6.5  for (const [team, odd] of Object.entries(game.odds)) { // Object.entries(game.odds) // [ [ \u0026#39;team1\u0026#39;, 1.33 ], [ \u0026#39;x\u0026#39;, 3.25 ], [ \u0026#39;team2\u0026#39;, 6.5 ] ]  const teamStr = team === \u0026#34;x\u0026#34; ? \u0026#34;draw\u0026#34; : `victory ${game[team]}`; // 每次loop出來的team是字串，所以可以用這個[]方式取值  console.log(team, odd); } // 分數統計 // scorers = { // Gnarby: 1, // Hummels: 1, // Lewandowski: 2 // }  const scorers = {}; for (const item of game.scored) { // 屬性存在 賦值+1 不存在時賦值=1  scorers[item] ? scorers[item]++ : (scorers[item] = 1); } console.log(scorers); // challenge 3 const gameEvents = new Map([ [17, \u0026#34;⚽️ GOAL\u0026#34;], [36, \u0026#34;🔁 Substitution\u0026#34;], [47, \u0026#34;⚽️ GOAL\u0026#34;], [61, \u0026#34;🔁 Substitution\u0026#34;], [64, \u0026#34;🔶 Yellow card\u0026#34;], [69, \u0026#34;🔴 Red card\u0026#34;], [70, \u0026#34;🔁 Substitution\u0026#34;], [72, \u0026#34;🔁 Substitution\u0026#34;], [76, \u0026#34;⚽️ GOAL\u0026#34;], [80, \u0026#34;⚽️ GOAL\u0026#34;], [92, \u0026#34;🔶 Yellow card\u0026#34;], ]); // 創造不重複事件陣列：迭代巢狀陣列的value變成一個陣列 不重複使用new Set(array) const events = new Set(gameEvents.values()); console.log(events); // 移除map中64分鐘的資料 gameEvents.delete(64); console.log(gameEvents); // 列印出發生事件avg時間長度\u0026#34;An event happened, on average, every 9 minutes\u0026#34; 一局90分鐘 const time = [...gameEvents.keys()].pop(); console.log(time); // 92 有超過90分鐘因此另外計算 console.log( `An event happened, on average, every ${time / gameEvents.size}minutes` ); // 加上前後半場標示[FIRST HALF] 17: ⚽️ GOAL  for (const [key, value] of gameEvents) { const half = key \u0026lt;= 45 ? \u0026#34;First\u0026#34; : \u0026#34;Second\u0026#34;; console.log(`[${half}HALF]${key}: ${value}`); }   ","date":"2022-01-10T00:00:00+08:00","image":"https://bacnotes.github.io/p/javascript-fundamentals-part3/javascript_hu206ed96a14226138f3215dbd4aa48c79_350158_120x120_fill_box_smart1_3.png","permalink":"https://bacnotes.github.io/p/javascript-fundamentals-part3/","title":"JavaScript基礎知識複習(3)｜bacnotes備份筆記"},{"content":"本文是基於下方這堂 Udemy 課程的筆記，對 React 有興趣的話可以購買看看唷 React - The Complete Guide (incl Hooks, React Router, Redux)\n讓我們娓娓道來 React 的各種知識吧！\n1. 什麼是 React？ 1 2  A JavaScript library for building user interfaces. 一套用來打造使用者介面的JavaScript函式庫    React 是客戶端 based(非伺服器端運作)，在瀏覽器操作 DOM 讓互動性變高 使用 SPA 減少跟伺服器的溝通，使用上就跟手機的原生 APP 一樣順暢，所以名字才叫 React 技術上來說(e.g. 跟 Augular 相比)React 不算是一個完整的框架  ＊什麼是 SPA（Single-page application）\n 單頁應用，伺服器傳送一次 HTML，就接管整個頁面的生命週期 可以透過 API(e.g. XMLHttpRequest 或 Fetch)更新部分畫面(元件)或整個頁面 Angular、React、Vue 都是熱門的 SPA  2. 為什麼用 React 對開發者好處  使用 Declarative programming 宣告式程式設計 描述目標而非流程，比起過往 DOM 操作要一個個選元素，一個口令一個動作的指令式程式設計 imperative programming，可以讓撰寫的程式碼精簡不少 以元件為中心 把視覺呈現、資料等元素放在單一檔案中，複用性高，可以減少重複代碼 JSX 語法 JSX 幫助我們同時寫 HTML 跟 JS 邏輯，資料跟事件的綁定可以直接寫在 HTML 上，很方便，像是在 HTML 上實作 JS 邏輯，且容易閱讀 關注點分離 每一模組各自有獨立關注焦點，有助於後續協作跟維護 資料驅動畫面 用 useState+雙向綁定 HTML 元素，資料有變動畫面就會變動 不用再寫一個渲染指令請程式更新畫面  對使用者好處  不需要在換頁時跟伺服器要資料(減少等待重新渲染的時間)，使用者體驗佳  3. React.js v.s. Angular v.s. Vue  都是以元件為中心，資料驅動畫面 React：內建 framework 較少，建議使用 JSX 語法但也可以用 JavaScript 撰寫，不想跟用 Vue 一樣記太多額外的語法，適合直接來 React Angular：用 TypeScript 撰寫，有很多內建的 framework，不太需要社群資源，比較複雜 Vue：內建 framework 比 React 多，比 Angular 少，有很多語法糖，適合初學者建立框架與生命週期觀念  4. React 建立專案 CRA(create-react-app)  相對傳統撰寫網頁的方式，只要建立 HTML、CSS、JavaScript 三個檔案 React 專案建立相較複雜一點，使用 CRA 指令前要先安裝 node.js(JavaScript 執行環境)才能使用 npm/npx 等指令下載相關模組(記得下載時網路要順暢)  1 2 3 4 5  // cd到專案資料夾 專案名以new-app為範例 npx create-react-app new-app cd new-app npm start // 可以在localhost 3000看到    CRA 內建 Babel 和 Webpack 幫你把 JSX 轉成瀏覽器可以解析的 HTML、CSS、JavaScript  5. VSCode 安裝 Prettier format document 選擇 prettier  若同時會使用 Vue 或 Javascript 開發不同專案，建議 VSCode 設定檔 by 框架/語言設定格式化的預設套件及 formatOnSave 選項  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  { // JavaScript  \u0026#34;[javascript]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34;, \u0026#34;editor.formatOnSave\u0026#34;: true }, // vue  \u0026#34;[vue]\u0026#34;: { \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; }, // react JSX  \u0026#34;[javascriptreact]\u0026#34;: { \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; }, }   參考文章：VSCode does not format JSX Correctly\n啟用 emmet snippet 縮寫  設定檔寫入  1 2 3 4 5  { \u0026#34;emmet.includeLanguages\u0026#34;: { \u0026#34;javascript\u0026#34;: \u0026#34;javascriptreact\u0026#34; }, }    使用 rcc 或 rfc（趨勢) 來幫助你加速開發吧  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // rcc class component import React, { Component } from \u0026#39;react\u0026#39;; class 元件名 extends Component { render() { return ( \u0026lt;div\u0026gt; \u0026lt;/div\u0026gt; ); } } export default 元件名; // rfc function component import React from \u0026#39;react\u0026#39;; const 元件名 = () =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;/div\u0026gt; ); } export default 元件名;   參考文章：Enable Emmet support for JSX in Visual Studio Code | React\n6. 開發專案前環境整理  如果只是要簡單開發一個 React 程式，必要的檔案有 App.js、index.css、index.js 移除不需要的 import  1 2 3 4 5  // App.js function App() { return \u0026lt;div\u0026gt;Hello\u0026lt;/div\u0026gt;; } export default App;    npm run start 觀看即時 Hot Reload 畫面  7. 了解 React 運作方式跟元件   在 2020 React17 更新後不用在每個客製化元件最上方 import React from 'react'，Babel 遇到 JSX 就會幫我們處理，且跟過往的 JSX 程式碼相容\n  但記得 index.js entry point 這邊的 import React from 'react'不能拿掉\n  對於 JSX 轉換細節有興趣的人可以參考這篇文章Introducing the New JSX Transform\n  1 2 3 4 5 6  // Inserted by a compiler (don\u0026#39;t import it yourself!) import { jsx as _jsx } from \u0026#34;react/jsx-runtime\u0026#34;; function App() { return _jsx(\u0026#34;h1\u0026#34;, { children: \u0026#34;Hello world\u0026#34; }); }     SPA 是針對 server 回傳的單頁 HTML 做變動，也就是\u0026lt;body\u0026gt; 中 id=\u0026lsquo;root\u0026rsquo;區塊\n  而 \u0026lt;App /\u0026gt;是一個 JavaScript function 回傳 JSX code，我們不會在瀏覽器 element 區塊看到\u0026lt;App /\u0026gt;裡面的 JSX 內容(因瀏覽器不懂 JSX 的內容) 而是會 render 出 Babel 轉譯\u0026lt;App /\u0026gt;後的內容\n  1 2 3  import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; ReactDom.render(\u0026lt;App /\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;));   8. 元件添加 CSS 樣式使用 className 而非 class  因為 class 是 JavaScript 的保留字，而 JSX 是 JavaScript 的延伸語法，所以不使用 class  1 2 3 4 5 6 7 8  function APP() { return ( \u0026lt;div\u0026gt; \u0026lt;h1 className=\u0026#39;container\u0026#39;\u0026gt;Hello\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } export default App;   9. 使用元件增加複用性  下方是一個元件範例，一般會放在 src/components 下，檔案命名建議大寫開頭 元件保持精簡，一個元件專心做一件事，降低耦合  1 2 3 4 5 6 7 8 9 10 11 12 13  // 客製化元件大寫命名，跟內建HTML元素做區隔 function Todo() { return ( \u0026lt;div className=\u0026#39;container\u0026#39;\u0026gt; \u0026lt;h2\u0026gt;Title\u0026lt;/h2\u0026gt; \u0026lt;div className=\u0026#39;actions\u0026#39;\u0026gt; \u0026lt;span\u0026gt;A span\u0026lt;/span\u0026gt; \u0026lt;button className=\u0026#39;btn\u0026#39;\u0026gt;Delete\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default Todo;    引用元件到 App.js 要先 import  1 2 3 4 5 6 7 8 9 10 11 12  // App.js import Todo from \u0026#34;./components/Todo\u0026#34;; function APP() { return ( \u0026lt;div\u0026gt; \u0026lt;h1 className=\u0026#39;container\u0026#39;\u0026gt;Hello\u0026lt;/h1\u0026gt; \u0026lt;Todo /\u0026gt; \u0026lt;Todo /\u0026gt; \u0026lt;/div\u0026gt; ); } export default App;   10. 父層透過 props 傳資料到子層元件  {}放入表達式 ，用同樣邏輯渲染出不同的資料  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // App.js // 資料傳入子層 import Todo from \u0026#39;./components/Todo\u0026#39; function APP () { return ( \u0026lt;div\u0026gt; \u0026lt;h1 className=\u0026#39;container\u0026#39;\u0026gt;Hello\u0026lt;/h1\u0026gt; \u0026lt;Todo text=\u0026#39;Learn React\u0026#39;/\u0026gt; \u0026lt;Todo text=\u0026#39;Master React\u0026#39;/\u0026gt; \u0026lt;/div\u0026gt; ) } export default App // 元件 Todo.js // 利用props收到的動態資料，渲染出2項Todo function Todo(props) { return ( \u0026lt;div className=\u0026#39;container\u0026#39;\u0026gt; \u0026lt;h2\u0026gt;{props.text}\u0026lt;/h2\u0026gt; \u0026lt;div className=\u0026#39;actions\u0026#39;\u0026gt; \u0026lt;span\u0026gt;A span\u0026lt;/span\u0026gt; \u0026lt;button className=\u0026#39;btn\u0026#39;\u0026gt;Delete\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default Todo;   11. 設置與監聽事件  需理解 React 裡面的 JSX 不等於 HTML，所以不能用 HTML inline JavaScript 事件的值應該是一個表達式所以用 onClick={} 可以寫成匿名函式 onClick={function(){}}或箭頭函式 onClick={()⇒{}} 但建議指向另一個 function，保持 HTML 精簡(寫在 return 前的區塊)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 元件 Todo.js 下方是一個 delete 事件 function Todo(props) { // 命名通常是xxxHandler  function openModalHandler() { console.log(\u0026#34;click\u0026#34;, props.text); } return ( \u0026lt;div className=\u0026#39;container\u0026#39;\u0026gt; \u0026lt;h2\u0026gt;{props.text}\u0026lt;/h2\u0026gt; \u0026lt;div className=\u0026#39;actions\u0026#39;\u0026gt; \u0026lt;span\u0026gt;A span\u0026lt;/span\u0026gt; // openModalHandler這邊不會加上執行() 等觸發才執行  \u0026lt;button onClick={openModalHandler} className=\u0026#39;btn\u0026#39;\u0026gt; Delete \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default Todo;   12. 引入多個元件  以提示窗為例，需要一個 backdrop 覆蓋 modal 後面的背景，跟一個 modal  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function Backdrop(props) { return \u0026lt;div className=\u0026#39;backdrop\u0026#39; /\u0026gt;; } function Modal(props) { return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Are you sure?\u0026lt;/p\u0026gt; \u0026lt;button className=\u0026#39;btn btn--alt\u0026#39;\u0026gt;Cancel\u0026lt;/button\u0026gt; \u0026lt;button className=\u0026#39;btn\u0026#39;\u0026gt;Delete\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default Modal;    兩個都引入到 App  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // App.js import Todo from \u0026#34;./components/Todo\u0026#34;; import Modal from \u0026#34;./components/Modal\u0026#34;; import Backdrop from \u0026#34;./components/Backdrop\u0026#34;; function APP() { return ( \u0026lt;div\u0026gt; \u0026lt;h1 className=\u0026#39;container\u0026#39;\u0026gt;Hello\u0026lt;/h1\u0026gt; \u0026lt;Todo text=\u0026#39;Learn React\u0026#39; /\u0026gt; \u0026lt;Todo text=\u0026#39;Master React\u0026#39; /\u0026gt; \u0026lt;Modal /\u0026gt; \u0026lt;Backdrop /\u0026gt; \u0026lt;/div\u0026gt; ); } export default App;   13. useState 紀錄網頁 State，跟使用者互動  useState 是 React 一個 Hook，Hook 是一個內建 function，useState 是用來操作狀態的 hook 我們註冊不同的 State，React 會在 State 改變時 render 不同東西 const [state, setState] = useState(initialState setState(newState);  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // useState 是一個 function，因為是第三方函式庫不用寫路徑 import { useState } from ‘react’ function SomeFunction(){ // useState 會回傳陣列，內有 2 個元素，可以定義初始值參數 // useState 要放在元件 function 內第一層，不能巢狀到 const [variable, setVariable] = useState(initialValue) return ( \u0026lt;div\u0026gt; ... \u0026lt;/div\u0026gt; ); } export default SomeFunction   為什麼我重新賦值的變數畫面沒有更新？ 無法透過重新賦值 變數 的值來更新畫面\n 更改值會需要呼叫陣列的第二個參數(一個 callback function)更新初始值(以下方範例來說是 setModalIsOpen) 呼叫 useState 的時候 React 才會重新執行 State 所屬的元件，並重新更新資料跟畫面 ＊不這麼做的話畫面是不會重新渲染的（也就是跑一次下方的 return 的 JSX)。 我們會用 setModalIsOpen 來更新值，用 modalIsOpen 判斷條件渲染 JSX 的程式碼  ＊Hook 有很多種，官方文件有列出所有的 Hook API\n useEffect 可以 fetch 資料、訂閱、或操作 DOM useRef 可以抓取 Dom 元素，獲取表單的 value(但更新 current 值不會重新渲染畫面) useContext 可以管理全域狀態等，下方會繼續介紹  同層監聽：click 開啟刪除確認 modal 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // Todo.js 元件  import { useState } from \u0026#34;react\u0026#34;; import Modal from \u0026#34;./Modal\u0026#34;; import Backdrop from \u0026#34;./Backdrop\u0026#34;; function Todo(props) { const [modalIsOpen, setModalIsOpen] = useState(false); function deleteHandler() { setModalIsOpen(true); } return ( \u0026lt;div className=\u0026#39;card\u0026#39;\u0026gt; \u0026lt;h2\u0026gt;{props.text}\u0026lt;/h2\u0026gt; \u0026lt;div className=\u0026#39;actions\u0026#39;\u0026gt; // 點擊觸發上層function  \u0026lt;button className=\u0026#39;btn\u0026#39; onClick={deleteHandler}\u0026gt; Delete \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {modalIsOpen \u0026amp;\u0026amp; \u0026lt;Modal /\u0026gt;} {modalIsOpen \u0026amp;\u0026amp; \u0026lt;Backdrop /\u0026gt;} \u0026lt;/div\u0026gt; ); }   父層監聽子層：click 關閉刪除確認 modal  子元件觸發事件，方法寫在父層 onClick 監聽是觸發同層 function，裡面包裹 props 傳下來的父層方法(Passing Function As Props) 範例為點 Cancel 跟 Delete 按鈕會關閉 modal  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  // Todo.js 元件 import Modal from \u0026#34;./components/Modal\u0026#34;; import Backdrop from \u0026#34;./components/Backdrop\u0026#34;; function Todo(props) { const [modalIsOpen, setModalIsOpen] = userState(false); function openModalHandler() { setModalIsOpen(true); } function closeModalHandler() { setModalIsOpen(false); } return ( \u0026lt;div className=\u0026#39;container\u0026#39;\u0026gt; \u0026lt;h2\u0026gt;{props.text}\u0026lt;/h2\u0026gt; \u0026lt;div className=\u0026#39;actions\u0026#39;\u0026gt; \u0026lt;button onClick={openModalHandler} className=\u0026#39;btn\u0026#39;\u0026gt; Delete \u0026lt;/button\u0026gt; {modalIsOpen \u0026amp;\u0026amp; ( \u0026lt;Modal onCancel={closeModalHandler} onConfirm={openModalHandler} /\u0026gt; )} // 透過props傳下去key value 讓子層觸發執行  {modalIsOpen \u0026amp;\u0026amp; \u0026lt;Backdrop onCancel={closeModalHandler} /\u0026gt;} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } // Modal.js function Modal(props) { function cancelHandler() { // 執行onCancel 父層方法 關閉modal  props.onCancel(); } function confirmHandler() { // 執行onCancel 父層方法 關閉modal  props.onConfirm(); } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Are you sure?\u0026lt;/p\u0026gt; \u0026lt;button onClick={cancelHandler} className=\u0026#39;btn btn--alt\u0026#39;\u0026gt; Cancel \u0026lt;/button\u0026gt; \u0026lt;button onClick={confirmHandler} className=\u0026#39;btn\u0026#39;\u0026gt; Delete \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default Modal;   ＊onCancel 是離開一個 dialog 元素會觸發的事件(e.g. 點遮罩或右上角 x，或取消按鈕) ＊onConfirm 是點確認\n14. 加上路由  需要安裝套件（不包含在 CRA)  1  npm install --save react-router-dom@5    建議加上 src/pages 資料夾，比較好找到對應元件  1 2 3 4 5 6 7 8 9 10 11  // 建立這三個檔案在pages裡面 AllMeetups.js 命名Page幫助我們知道這個元件是一個頁面 function AllMetupsPage(){ return ( \u0026lt;div\u0026gt;AllMetupsPage\u0026lt;/div\u0026gt; ) } export default AllMeetupsPage Favorites.js NewMeetup.js 同上邏輯 改div內容跟function名字跟export名即可    我們使用 BrowserRouter 套件去定義哪些頁面何時要 load  1 2 3 4 5 6 7 8  // index.js import { BrowserRouter } from \u0026#34;react-router-dom\u0026#34;; // 初始化套件 確保他有在觀察url RouterDOM.render( \u0026lt;BrowserRouter\u0026gt; \u0026lt;APP /\u0026gt; \u0026lt;/BrowserRouter\u0026gt; );    搭配使用 Switch 渲染第一個符合路徑的元件  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // App.js import { Route } from \u0026#34;react-router-dom\u0026#34;; import AllMeetupsPage from \u0026#34;./pages/AllMeetups\u0026#34;; import NewMeetupsPage from \u0026#34;./pages/NewMeetups\u0026#34;; import FavoritesPage from \u0026#34;./pages/Favorites\u0026#34;; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Switch\u0026gt; // 避免/巢狀重複出現多個頁面內容 也可以直接exact  \u0026lt;Route path=\u0026#39;/\u0026#39; exact={true}\u0026gt; \u0026lt;AllMeetupsPage /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;Route path=\u0026#39;/newmeetup\u0026#39;\u0026gt; \u0026lt;NewMeetupsPage /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;Route path=\u0026#39;/favorites\u0026#39;\u0026gt; \u0026lt;FavoritesPage /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;/Switch\u0026gt; \u0026lt;/div\u0026gt; ); } export default App;   15. 用導覽列來練習 Link  導覽列一般會設置在 src 下方資料夾 layout，因為是整體佈局的元件 a href屬性可以用，但我們不想用伺服器傳 HTML，失去 SPA 優勢 import link 元件，會搭配to屬性加入路徑使用 \u0026lt;Link\u0026gt;tag 自動在 DOM 加入監聽，阻擋瀏覽器預設行為送出請求 且只會解析 url，修改網址列跟 load 相對應的元件(React/JavaScript)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  // MainNavigation.js  import { Link } from \u0026#39;react-router-dom\u0026#39; function MainNavigation() { return ( \u0026lt;header\u0026gt; \u0026lt;div\u0026gt; React Meetups\u0026lt;/div\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; \u0026lt;Link to=\u0026#39;/\u0026#39;\u0026gt;All Meetups\u0026lt;/Link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;Link to=\u0026#39;/newMeetup\u0026#39;\u0026gt;Add New Meetups\u0026lt;/Link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;Link to=\u0026#39;/favorites\u0026#39;\u0026gt;My favorites\u0026lt;/Link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;/header\u0026gt; ) } export default MainNavigation    導覽列 引入 App.js  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // App.js import { Route } from \u0026#34;react-router-dom\u0026#34;; import AllMeetupsPage from \u0026#34;./pages/AllMeetups\u0026#34;; import NewMeetupsPage from \u0026#34;./pages/NewMeetups\u0026#34;; import FavoritesPage from \u0026#34;./pages/Favorites\u0026#34;; import MainNavigation from \u0026#34;./components/layout/MainNavigation\u0026#34;; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;MainNavigation /\u0026gt; \u0026lt;Switch\u0026gt; \u0026lt;Route path=\u0026#39;/\u0026#39; exact={true}\u0026gt; \u0026lt;AllMeetupsPage /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;Route path=\u0026#39;/newmeetup\u0026#39;\u0026gt; \u0026lt;NewMeetupsPage /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;Route path=\u0026#39;/favorites\u0026#39;\u0026gt; \u0026lt;FavoritesPage /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;/Switch\u0026gt; \u0026lt;/div\u0026gt; ); } export default App;   16. CSS modules 來為元件加上樣式  CRA 本身有內建 CSS modules 需要在檔名使用 module.css 引入名稱自訂(e.g. classes)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // MainNavigation.js // classes會變成一個物件 import classes from \u0026#39;./MainNavigation.module.css\u0026#39; import { Link } from \u0026#39;react-router-dom\u0026#39; function MainNavigation() { return ( //module.css裡面的css樣式會變成key value pair  \u0026lt;header className={classes.header}\u0026gt; \u0026lt;div className={classes.logo}\u0026gt; React Meetups\u0026lt;/div\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; \u0026lt;Link to=\u0026#39;/\u0026#39;\u0026gt;All Meetups\u0026lt;/Link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;Link to=\u0026#39;/newMeetup\u0026#39;\u0026gt;Add New Meetups\u0026lt;/Link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;Link to=\u0026#39;/favorites\u0026#39;\u0026gt;My favorites\u0026lt;/Link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;/header\u0026gt; ) } export default App   17. 使用 map 迴圈渲染資料 React 能渲染出 JSX 元素裡的陣列  JSX expression{[\u0026lt;li\u0026gt;item1\u0026lt;/li\u0026gt;, \u0026lt;li\u0026gt;item2\u0026lt;/li\u0026gt;]} 或用 map 方法把元素 return 出來  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // pages/AllMeetup.js const DUMMY_DATA = [ { id: \u0026#34;m1\u0026#34;, title: \u0026#34;This is a first meetup\u0026#34;, image: \u0026#34;https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Stadtbild_M%C3%BCnchen.jpg/2560px-Stadtbild_M%C3%BCnchen.jpg\u0026#34;, address: \u0026#34;Meetupstreet 5, 12345 Meetup City\u0026#34;, description: \u0026#34;This is a first, amazing meetup which you definitely should not miss. It will be a lot of fun!\u0026#34;, }, { id: \u0026#34;m2\u0026#34;, title: \u0026#34;This is a second meetup\u0026#34;, image: \u0026#34;https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Stadtbild_M%C3%BCnchen.jpg/2560px-Stadtbild_M%C3%BCnchen.jpg\u0026#34;, address: \u0026#34;Meetupstreet 5, 12345 Meetup City\u0026#34;, description: \u0026#34;This is a first, amazing meetup which you definitely should not miss. It will be a lot of fun!\u0026#34;, }, ]; function AllMeetupsPage() { return ( \u0026lt;section\u0026gt; \u0026lt;h1\u0026gt;AllMeetupsPage\u0026lt;/h1\u0026gt; {DUMMY_DATA.map((el) =\u0026gt; { return \u0026lt;li key={el.id}\u0026gt;{el.title}\u0026lt;/li\u0026gt;; })} \u0026lt;/section\u0026gt; ); } export default AllMeetupsPage;   迴圈的元素設置 唯一值的 key  傳統演算法比對兩個節點差異，時間複雜度為 O 的 3 次方 為了渲染的效能，React 使用 heuristic 演算法比較內容變動的元素，但也可能因為沒有比對好(部分演算法假設跟現實不符)造成渲染出錯誤的元素 透過設置 key 告訴 React 你改動的元素，而非讓 React 自己比較元素內容差異 避免使用 index(元素完全位移), Math.random(key 值非固定)等方式來建立 key  18. 客製化元件的其他使用方式，目的在於讓元件專注在一件事 元件作為容器 Wrapper/Container 使用  設定 Container 包裹 children 內容  1 2 3 4 5 6 7  import classes from \u0026#34;./Container.module.css\u0026#34;; // 引入props.children children是每個元件都可以獲取的預設屬性，值是tag包覆的內容 function Container(props) { return \u0026lt;div className={classes.container}\u0026gt;{props.children}\u0026lt;/div\u0026gt;; } export default Container;    div 外用 Container 包裹  1 2 3 4 5 6 7 8  import Container from \u0026#34;../ui/Container\u0026#34;; function MeetUpItem(props) { return ( \u0026lt;Container\u0026gt; \u0026lt;div\u0026gt;some content\u0026lt;/div\u0026gt; \u0026lt;/Container\u0026gt; ); }   元件作為 Layout 使用(排版 body 內容)  Layout 放導覽列跟語意化標籤 main 包裹其他內容 在 components/layout 資料夾製作一個 Layout.js  1 2 3 4 5 6 7 8 9 10 11 12  import MainNavigation from \u0026#34;./MainNavigation\u0026#34;; import classes from \u0026#34;./Layout.module.css\u0026#34;; function Layout(props) { return ( \u0026lt;div\u0026gt; \u0026lt;MainNavigation /\u0026gt; \u0026lt;main className={classes.main}\u0026gt;{props.children}\u0026lt;/main\u0026gt; \u0026lt;/div\u0026gt; ); } export default Layout;    Layout 包裹路由內容  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // App.js import { Route } from \u0026#39;react-router-dom\u0026#39;; import AllMeetupsPage from \u0026#39;./pages/AllMeetups\u0026#39;; import NewMeetupsPage from \u0026#39;./pages/NewMeetups\u0026#39;; import FavoritesPage from \u0026#39;./pages/Favorites\u0026#39;; // 拿掉之前的MainNavigation 換成Layout import Layout from \u0026#39;./components/layout/Layout\u0026#39;; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;Layout\u0026gt; \u0026lt;Switch\u0026gt; \u0026lt;Route path=\u0026#39;/\u0026#39; exact={true}\u0026gt; \u0026lt;AllMeetupsPage /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;Route path=\u0026#39;/newmeetup\u0026#39;\u0026gt; \u0026lt;NewMeetupsPage /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;Route path=\u0026#39;/favorites\u0026#39;\u0026gt; \u0026lt;FavoritesPage /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;/Layout\u0026gt; \u0026lt;/div\u0026gt; ); } export default App;   19. 加上表單  Page 新增一頁 裡面放表單元件  1 2 3 4 5 6 7 8 9  function NewMeetupPage() { return ( \u0026lt;section\u0026gt; \u0026lt;h1\u0026gt;Add New Meetup\u0026lt;/h1\u0026gt; \u0026lt;NewMeetupFrom\u0026gt; \u0026lt;/section\u0026gt; ); } export default NewMeetupPage;    新增表單元件 for 屬性在 React 要寫成 htmlFor  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  // NewMeetupForm.js import Container from \u0026#34;../ui/Container\u0026#34;; import classes from \u0026#34;./NewMeetupForm.module.css\u0026#34;; function NewMeetupForm() { return ( \u0026lt;Container\u0026gt; \u0026lt;form className={classes.form}\u0026gt; \u0026lt;div className={classes.control}\u0026gt; \u0026lt;label htmlFor=\u0026#39;title\u0026#39;\u0026gt;Title\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#39;text\u0026#39; id=\u0026#39;title\u0026#39; required /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className={classes.control}\u0026gt; \u0026lt;label htmlFor=\u0026#39;image\u0026#39;\u0026gt;Image\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#39;url\u0026#39; id=\u0026#39;image\u0026#39; required /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className={classes.control}\u0026gt; \u0026lt;label htmlFor=\u0026#39;address\u0026#39;\u0026gt;Address\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#39;text\u0026#39; id=\u0026#39;address\u0026#39; required /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className={classes.control}\u0026gt; \u0026lt;label htmlFor=\u0026#39;description\u0026#39;\u0026gt;Address\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#39;textarea\u0026#39; rows=\u0026#39;5\u0026#39; id=\u0026#39;description\u0026#39; required /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className={classes.control}\u0026gt; \u0026lt;label htmlFor=\u0026#39;description\u0026#39;\u0026gt;Address\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#39;textarea\u0026#39; rows=\u0026#39;5\u0026#39; id=\u0026#39;description\u0026#39; required /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className={classes.action}\u0026gt; \u0026lt;button\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/Container\u0026gt; ); } export default NewMeetupFrom;   20. 使用 useRef 獲取表單元素值  偵測表單內容有兩種做法   使用 useState 監聽每個 input onChange 事件，更新資料 使用 useRef 直接操作 DOM 元素   ref 還適合用在管理 focus、文字選擇、播放影音、整合第三方 DOM 函式庫、觸發動畫 非必要時不濫用 ref 操作 DOM 元素，多數元素保持用 State 管理 ref 建議以 callback 方式使用  1 2 3  // 元素綁定this.content，使用this.xxx呼叫相關屬性 \u0026lt;input type=\u0026#39;text\u0026#39; ref={(el) =\u0026gt; (this.content = el)} /\u0026gt;; this.content.focus();    引入 ref object，使用 current 屬性獲取 value  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  // NewMeetupForm.js import Container from \u0026#34;../ui/Container\u0026#34;; import classes from \u0026#34;./NewMeetupForm.module.css\u0026#34;; import { useRef } from \u0026#34;react\u0026#34;; function NewMeetupForm() { // 創造一個ref物件，帶有ref屬性，裡面有current屬性  const titleInputRef = useRef(); const imageInputRef = useRef(); const addressInputRef = useRef(); const descriptionInputRef = useRef(); function submitHandler(event) { // 阻擋瀏覽器預設事件，避免點下表單就會對伺服器發出請求  event.preventDefault(); // 獲得title目前input值  const enteredTitle = titleInputRef.current.value; const enteredImage = imageInputRef.current.value; const enteredAddress = addressInputRef.current.value; const enteredDescription = descriptionInputRef.current.value; // 創造一個物件管理  const meetupData = { title: enteredTitle, image: enteredImage, address: enteredAddress, description: enteredDescription, }; // send to server console.log(meetupData)  props.onAddMeetupData(meetupData); } return ( \u0026lt;Container\u0026gt; // 新增 submit 監聽  \u0026lt;form className={classes.form} onSubmit={submitHandler}\u0026gt; \u0026lt;div className={classes.control}\u0026gt; \u0026lt;label htmlFor=\u0026#39;title\u0026#39;\u0026gt;Title\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#39;text\u0026#39; id=\u0026#39;title\u0026#39; ref={titleInputRef} required /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className={classes.control}\u0026gt; \u0026lt;label htmlFor=\u0026#39;image\u0026#39;\u0026gt;Image\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#39;url\u0026#39; id=\u0026#39;image\u0026#39; ref={imageInputRef} required /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className={classes.control}\u0026gt; \u0026lt;label htmlFor=\u0026#39;address\u0026#39;\u0026gt;Address\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#39;text\u0026#39; id=\u0026#39;address\u0026#39; ref={addressInputRef} required /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className={classes.control}\u0026gt; \u0026lt;label htmlFor=\u0026#39;description\u0026#39;\u0026gt;Description\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#39;textarea\u0026#39; rows=\u0026#39;5\u0026#39; id=\u0026#39;description\u0026#39; ref={descriptionInputRef} required /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className={classes.action}\u0026gt; \u0026lt;button\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/Container\u0026gt; ); } export default NewMeetupFrom;    表單資料丟到父層  1 2 3 4 5 6 7 8 9 10 11 12 13 14  // pages/NewMeetup.js function NewMeetupPage() { // 表單資料meetupData  function addMeetupHandler(meetupData) { // send http req  } return ( \u0026lt;section\u0026gt; \u0026lt;h1\u0026gt;Add New Meetup\u0026lt;/h1\u0026gt; \u0026lt;NewMeetupForm onAddMeetupData={addMeetupHandler}\u0026gt; \u0026lt;/section\u0026gt; ); } export default NewMeetupPage;   21. API 串接 為什麼需要 API  前端的程式碼在 devtool 可以看到，透過 API 資料跟 server 要資料以確保安全 不然懂一點程式的人透過前端程式碼呼叫 server，可以盜取使用者個資，也可以把你 server 清空 可以用 Firebase Realtime Database 測試前端丟出去的 JSON 資料  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  function NewMeetupPage() { function addMeetupHandler(meetupData) { // Firebase realtime 資料庫的API後方加上/xxx.json等於一個大表  fetch(\u0026#39;firebaseAPI網址/xxx.json\u0026#39;, { method: \u0026#39;POST\u0026#39;, // body是JSON格式  body:JSON.stringify(meetupData), // 部分API會要求提供\u0026#39;Content-Type\u0026#39;  headers: { \u0026#39;Content-Type\u0026#39;:\u0026#39;application/json\u0026#39; } }) } return ( \u0026lt;section\u0026gt; \u0026lt;h1\u0026gt;Add New Meetup\u0026lt;/h1\u0026gt; \u0026lt;NewMeetupForm onAddMeetupData={addMeetupHandler}\u0026gt; \u0026lt;/section\u0026gt; ); } export default NewMeetupPage;   22. 使用 useHistory 跳轉頁面  history.goBack() 回上一頁 history.push(\u0026rsquo;/\u0026rsquo;) 到首頁，新增一個網址資料到陣列尾端 history.replace(\u0026rsquo;/\u0026rsquo;) 回首頁，直接取代 current entry 資料，不新增資料，當不希望使用者回上一頁可使用  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import { useHistory } from \u0026#34;react-router-dom\u0026#34;; function NewMeetupPage() { function addMeetupHandler(meetupData) { // Firebase realtime 資料庫的API後方加上/xxx.json等於一個大表  fetch(\u0026#34;firebaseAPI網址/xxx.json\u0026#34;, { method: \u0026#34;POST\u0026#34;, // body是JSON格式  body: JSON.stringify(meetupData), // 部分API會要求提供\u0026#39;Content-Type\u0026#39;  headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, }, }).then(() =\u0026gt; { history.replace(\u0026#34;/\u0026#34;); }); } }   23. 使用 useEffect  useEffect 可以用來限制元件不要每次渲染都執行所有的程式碼 第一個參數為函式，第二個是陣列，只有[]內容有變化才會執行 若沒加第二個參數等於每次都會執行，有用跟沒用一樣 若為空陣列，由於沒有相依任何變數，所以偵測不到變化，只會執行第一次 若裡面有變數，則變數有變化就會再執行一次 適合用在 fetch data、訂閱監聽事件、改變 DOM、輸出 log get 方法讓個別頁面獲取不同資料(把 dummyData 換成實際 server 資料)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  // pages/AllMeetup.js import { useState, useEffect } from \u0026#34;react\u0026#34;; function AllMeetupsPage() { const [isLoading, setIsLoading] = useState(true); const [meetups, setMeetups] = useState([]); useEffect(() =\u0026gt; { // fetch回傳promise  fetch(\u0026#34;firebaseUrl/meetups.json\u0026#34;) .then((response) =\u0026gt; { // 獲取body 使用.json方法 把json檔案變成JS object  // 因為.json return promise所以用then接 課程這邊專心在獲取資料 沒有寫到error處理  return response.json(); }) .then((data) =\u0026gt; { // 我們期望是陣列資料套入到模板，而firebase上的meetups資料是巢狀物件結構  // 最外層是一個object，每筆資料是一個key value pair  // meetups = {  // key1: {title:\u0026#39;\u0026#39;, image:\u0026#39;\u0026#39;, address:\u0026#39;\u0026#39;, description:\u0026#39;\u0026#39;},  // key2: {title:\u0026#39;\u0026#39;, image:\u0026#39;\u0026#39;, address:\u0026#39;\u0026#39;, description:\u0026#39;\u0026#39;}  // }  const meetups = []; for (const key in data) { // 解構出data  const meetups = { id: key, ...data[key], }; // 資料一筆筆推入陣列  meetups.push(meetup); } setIsLoading(false); setMeetups(data); }); }, []); if (isLoading) { return ( \u0026lt;section\u0026gt; \u0026lt;p\u0026gt;Loading...\u0026lt;/p\u0026gt; \u0026lt;/section\u0026gt; ); } // 這段不會等上面回傳資料，但不能用async function AllMeetupPage await fetch來處理  // 元件函式應是同步函式，不應該return promise而是JSX  // 可使用State條件渲染 loading  return ( \u0026lt;section\u0026gt; \u0026lt;h1\u0026gt;AllMeetupsPage\u0026lt;/h1\u0026gt; {meetups.map((el) =\u0026gt; { return \u0026lt;li key={el.id}\u0026gt;{el.title}\u0026lt;/li\u0026gt;; })} \u0026lt;/section\u0026gt; ); } export default AllMeetupsPage;    若沒使用 useEffect，當 useState 更新狀態會再跑一次元件，再 fetch 一次就會無限迴圈  24-1 useContext 管理全域 State (這個應該是最複雜的)  上面介紹過 useState 在單個元件的更新資料方法 如果需要管理全域的 State，可以用 props 傳遞 State 更新其他元件資料，但大專案會不好維護跟管理 也可以使用 redux，但 React 函式庫本身就有內建 context 管理 State 的 function 管理 State 的 context 一般會建立在 src/store 下(e.g. favorites-context.js)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  import { createContext, useState } from \u0026#34;react\u0026#34;; // 建立一個context物件 裡面放初始值 const FavoritesContext = createContext({ favorites: [], totalFavorites: 0, addFavorite: (favoriteMeetup) =\u0026gt; {}, removeFavorite: (favoriteMeetup) =\u0026gt; {}, itemIsFavorite: (favoriteMeetup) =\u0026gt; {}, }); // 更新我的最愛State的函式 用來管理這個函式裡的State 這邊加上export之後會從外部呼叫 export function FavoritesContextProvider(props) { const [userFavorites, setUserFavorites] = useState([]); // 建立三個處理我的最愛State的函式  function addFavoriteHandler(favoriteMeetup) { setUserFavorites((prevUserFavorites) =\u0026gt; { return prevUserFavorites.concat(favoriteMeetup); }); } function removeFavoriteHandler(meetupId) { setUserFavorites((prevUserFavorites) =\u0026gt; { return prevUserFavorites.filter((prev) =\u0026gt; prev.id !== meetupId); }); } function itemIsFavoriteHandler(meetupId) { return userFavorites.some((meetup) =\u0026gt; meetup.id !== meetupId); } // 新增一個 context object 透過value把值傳過去  const context = { // 把userFavorite的snapshot放在這裡，當State改變context物件也會改變  // 也會透過value={context}傳新的值到相關元件  favorites: userFavorites, totalFavorites: userFavorites.length, // 當其他元件要使用上方三個函式時，用pointer指向下面的key然後就會執行後面的函式，即上面的function  addFavorite: addFavoriteHandler, removeFavorite: removeFavoriteHandler, itemIsFavorite: itemIsFavoriteHandler, }; // Provider是內建的元件 必須包在所有會跟他互動的元件(e.g. App) value會傳值  return ( \u0026lt;FavoritesContext.Provider value={context}\u0026gt; {props.children} \u0026lt;/FavoritesContext.Provider\u0026gt; ); } // 輸出Favoritescontext export default FavoritesContext;    index.js 引用，讓全域都可以使用 context  1 2 3 4 5 6 7 8 9 10 11  // index.js import { BrowserRouter } from \u0026#34;react-router-dom\u0026#34;; import { FavoriteContextProvider } from \u0026#34;./store/favorite-context\u0026#34;; RouterDOM.render( \u0026lt;FavoriteContextProvider\u0026gt; \u0026lt;BrowserRouter\u0026gt; \u0026lt;APP /\u0026gt; \u0026lt;/BrowserRouter\u0026gt; \u0026lt;/FavoriteContextProvider\u0026gt; );   24-2 在元件引用 useContext  引用到 MeetupItem.js  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  // 點加入我的最愛就會把item加入陣列，更新按鈕文字 ... import FavoritesContext from \u0026#39;./../../store/favorite-context\u0026#39; function MeetUpItem(props) { function toggleFavoritesStatusHandler() { const favoritesCtx = useContext(FavoritesContext) const itemIsFavorite = favoriteCtx.itemIsFavorite(prop.id) function toggleFavoriteStatusHandler() { if(itemIsFavorite) { favoritesCtx.removeFavorite(prop.id) } else { // 更新陣列資料，就會透過favorite-context讓全域物件下相關資料都更新  favoritesCtx.addFavorite({ id: props.id, title: props.title, address: props.address, image: props.image, description: prop.description }) } } return ( \u0026lt;li className={classes.item}\u0026gt; \u0026lt;Container\u0026gt; ... \u0026lt;div\u0026gt; \u0026lt;button onClick={toggleFavoriteStatusHandler}\u0026gt;{itemIsFavorite ? \u0026#39;Remove\u0026#39; : \u0026#39;Add\u0026#39;}\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/Container\u0026gt; \u0026lt;/li\u0026gt; ); } }    引用到 FavoritesPage  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  ... import { useContext } from \u0026#39;react\u0026#39; import FavoritesContext from \u0026#39;./../store/favorite-context\u0026#39; // 顯示我的最愛item function FavoritesPage(){ const favoritesCtx = useContext(FavoritesContext) let content if (favoritesCtx.totalFavorites.length === 0){ content = \u0026lt;p\u0026gt;No Favorites yet\u0026lt;/p\u0026gt; } else { content = \u0026lt;MeetupList meetups={favoritesCtx.favorites}\u0026gt; } return \u0026lt;section\u0026gt; \u0026lt;h1\u0026gt;My Favorites\u0026lt;/h1\u0026gt; // array  {content} \u0026lt;/section\u0026gt; } export default FavoritesPage    引用到導覽列(放上我的最愛總數)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // MainNavigation.js ... import { useContext } from \u0026#39;react\u0026#39; import FavoritesContext from \u0026#39;./../../store/favorite-context\u0026#39; import { Link } from \u0026#39;react-router-dom\u0026#39; function MainNavigation() { const favoriteCtx = useContext(FavoritesContext) return ( \u0026lt;header\u0026gt; ... \u0026lt;li\u0026gt; \u0026lt;Link to=\u0026#39;/favorites\u0026#39;\u0026gt;My favorites \u0026lt;span\u0026gt;{favoriteCtx.totalFavorites.length}\u0026lt;/span\u0026gt; \u0026lt;/Link\u0026gt; \u0026lt;/li\u0026gt; ... \u0026lt;/header\u0026gt; ) } export default MainNavigation   最後想補充一下\u0026hellip; 其實我覺得 Vue 也不錯啊（x)\n有好吃的語法糖：用@監聽事件，@submit.prevent.stop 就可阻止瀏覽器提交表單跟冒泡：動態 class，watch 深層監聽物件屬性，computed 動態更新，v-model 雙向綁定表單\u0026hellip; 等各種好吃的糖)\n原來暗藏一篇 Vue 推銷文，真是太邪惡了\n","date":"2022-01-06T00:00:00+08:00","image":"https://bacnotes.github.io/p/react-knowledge-101/photo-1633356122544-f134324a6cee_hu3d03a01dcc18bc5be0e67db3d8d209a6_61563_120x120_fill_q75_box_smart1.jpeg","permalink":"https://bacnotes.github.io/p/react-knowledge-101/","title":"自學React的你需要知道的一些知識｜bacnotes備份筆記"},{"content":"JavaScript 的特性 high level 高階(語言)  高階指的是接近人類讀得懂的語言，低階則是接近機器的 2 進位的機器碼(machine code) 例如 c 語言(低階語言)，需要處理宣告新變數時的記憶體 而高階語言的 python 跟 JavaScript 不需要，但效能不會有 c 語言好  prototype based object-oriented 物件導向  JavaScript 資料除了 primitives 都是物件 陣列也是物件，只是 key 為 index  1 2  let arr = [1, 2, 3] typeof arr //object   interpreted or just-in-time compiled  JavaScript 引擎會幫我們轉成 2 進位的機器碼  dynamic-typed 動態資料型態  宣告變數時不需要給予型別(C、Java、Ruby 要) 容易改變型別  single-threaded 單執行緒  一次只能執行一個任務  garbage collected 有記憶體回收機制  有機制會自動移除記憶體中老舊或沒有使用的變數  multi-paradigm 可以同時使用多種風格來寫程式  可以用 Procedural Programming 程序化程式設計 可以用 Function Programming 函式程式設計 可以用 Object-Oriented Programming 物件導向程式設計  with first-class functions 一級函式  一級函式是一種特性，部分程式語言沒有，而 JavaScript 有 一級函式表示在這個語言函式可以被當作一個變數(variable)，賦值給其他變數或做為參數傳遞(functions are values)  non-blocking event loop concurrent model  由於單執行緒但又得處理同時發生的多種任務，容易阻塞 JavaScript 引擎會使用 event loop，一個背景執行的 task，任務執行完的結果會放到 call stack  JavaScript 引擎 v.s. 執行環境 runtime v.s. 執行文本 context JavaScript 引擎  各家瀏覽器有自己的 JavaScript 引擎，用來執行 JavaScript Google 開發的 V8 引擎，不只用於 Chrome 還有 Node.js(可以在瀏覽器外執行 JavaScript) JavaScript 引擎包含一個 Call Stack(execution context)跟一個 Heap Heap 是非結構化的記憶體池，儲存所有物件 interpretation：程式碼轉成一行行執行的 code，再轉成機器碼 compilation：整包程式碼轉成 machine code(2 進位)，再執行程式 just-in-time compilation: 程式碼轉成 2 進位後立即執行(避免等待) 當一段程式碼進到引擎會執行下方程序  1 2 3 4  step1. parsing: JavaScript → AST(abstract syntax tree) 結構化JavaScript step2. compilation: AST → 2進位的機器碼 step3. execution: 在call stack執行 step2~3. optimization: 邊執行邊最佳化(在特別的thread執行，無法access)   JavaScript Runtime 執行環境  browser: JavaScript 引擎 + webAPIs + callback queue call stack : 由上到下執行 stack 裡面每一行程式，變數的記憶體也是在這個階段建立(hoisting)，遇到需要呼叫 API 的非同步函式會把裡面的 call back function 丟到 webAPI 排程執行 webAPIs 處理非同步函式，當有收到回傳結果，會依照回傳時間順序把 callback function 傳到 callback queue 當 stack 清空時，callback queue 就會把 callback function 依序（queue先進先出)丟到 stack 裡執行 這整個過程就是 event loop，為了提高瀏覽器的使用體驗，不會被非同步函式等待過程阻塞的機制   node.js: JavaScript 引擎 + C ++ bindings \u0026amp; thread pool + callback queue (這邊知道的大概即可)  ＊stack 是先進後出(後進先出)的資料結構，queue 是先進先出的資料結構\nExecution context 執行文本 ＊為了跟執行環境 runtime 做名詞區隔，使用不同中文名稱指稱\n  執行文本包含\n 變數環境 variable environment: 包含 let const var 宣告, 函式, 參數 arguments obj 作用域鏈 scope chain: 讓個別函式可以 ref 到函式外的變數，會存在個別執行文本 this: 每個執行文本都有自己的 this，在創造階段時誕生(執行階段前)    有創造階段跟執行階段\n  箭頭函式沒有自己的 this 或參數，但可以使用父層的 this 或參數\n  執行順序\n step1. 創造全域執行文本(top-level/not inside the function)\n只有非 function 的會被執行，因為 function 要被呼叫才會執行\n只會有一個 global execution context step2. 執行全域執行文本(inside global EC) step3. 執行函式等待 callback 回傳結果\n依序呼叫個別函式，個別函式的文本會被創造\ncall stack 的內容就是由這些個別函式跟文本所組成    scope 作用域 \u0026amp; scope chain 作用域鏈 global scope 全域  位於 function 跟 block 外 可以被所有地方存取  function scope 函式作用域  也被稱作 local scope 只能在函式內存取，嘗試存取會出現 error ES6 開始嚴格模式下也是 block scope  block scope(ES6 開始出現) 區塊作用域  let 跟 const 被限制只能在 block 範圍內存取 var 還是可以被 function scope 存取 ES6 開始嚴格模式下 function scope 也是 block scope(寫兩次因為很重要)  scope chain  當變數不存在現有 scope，無論是 block 或 function 都可以讀外面父層裡的變數 找不到時會一層層往外找(variable lookup)，完全找不到會出現 ReferenceError 只能往外找，不能往內 console.log(function 或 block 裡面的變數)會 ReferenceError sibling 之間不行互相讀取 每個 scope chain 都包含他的變數跟的父層的變數 scope chain 可以讀取的變數跟 function 在 call stack 執行順序無關  callstack v.s. scope chain  使用下方函式舉例 step1. 創造全域執行文本  全域變數環境：a=\u0026lsquo;Jonas\u0026rsquo;, first=fn, third=fn   step2. 執行全域執行文本，創造出個別執行文本 first()作用域：可以獲取本地作用域跟父層的變數環境  變數環境：b=\u0026lsquo;Hello\u0026rsquo;, second=fn, a=\u0026lsquo;Jonas\u0026rsquo;, first=fn, third=fn second()作用域：可以獲取本地作用域跟父層的變數環境 變數環境：c, b=\u0026lsquo;Hello\u0026rsquo;, second=fn, a=\u0026lsquo;Jonas\u0026rsquo;, first=fn, third=fn third()作用域：可以獲取本地作用域跟父層的變數環境 變數環境：d=\u0026lsquo;Hey\u0026rsquo;, a=\u0026lsquo;Jonas\u0026rsquo;, first=fn, third=fn   step3. 執行個別文本(執行函式)，等待 callback 回傳結果  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  const a = \u0026#39;Jonas\u0026#39;; first(); function first() { const b = \u0026#39;Hello\u0026#39;; second(); function second() { const c = \u0026#39;H1\u0026#39;; third(); } } function third() { const d = \u0026#39;Hey!\u0026#39;; console.log(d + c + b + a); // ReferenceError }   ＊下方是另一個範例，輸出結果用//表示，且視為單獨出現這行的狀況（彼此之間不影響）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  \u0026#39;use strict\u0026#39;; const firstName = \u0026#39;Jonas\u0026#39; function calcAge(birthYear) { const age = 2037 - birthYear function printAge() { // 執行時裡面沒有age，variable lookup往父層找  const output = `You are ${age}, born in ${birthYear}`; console.log(output); if (birthYear \u0026gt;= 1981 \u0026amp;\u0026amp; birthYear \u0026lt;= 1996) { var millenial = true; // 創造跟外面一樣變數名的新變數  const firstName = \u0026#39;Steven\u0026#39; const str = `you are a millenial, ${firstName}`; console.log(str); // 執行時裡面沒有firstName，往父層找 you are a millenial, Jonas  function add(a, b) { return a + b; } // 內部重新賦值output 下方會列印出新的值的output  output = \u0026#39;New output\u0026#39; } console.log(str); // 無法獲取內部變數 str is not defined  console.log(millenial); // var不是block scope是function scope因此可以獲取同function的變數 true  console.log(add(3, 5)) //add function 嚴格模式下也是block scope 會ReferenceError，非嚴格模式下會是8  console.log(output) //\u0026#39;New output\u0026#39;  } printAge() return age } calcAge(1991) // You are 46, born 1991 console.log(age) // ReferenceError 無法獲取內部變數age printAge(); // ReferenceError 無法獲取內部變數 printAge()   總結  要了解變數存活的區域，哪裡可以獲取這些值 如何設計變數的位置跟獲取程式的變數 lexical scoping 是使用 function 跟 block 等封閉環境，控制變數存取 scope 宣告變數的環境，有 global 全域, function 函式跟 block 區塊三種作用域 所有 scope 都可以獲取父層的 scope，因為這是一條 scope chain  Hoisting 提升  表面上是可以在宣告前被使用 其實是在執行階段前，已經在創造階段就建立在變數環境(variable environment) 不同變數行為不同  函式宣告  函式宣告會提升 未宣告使用為實際值 變數存取範圍嚴格模式下為 block scope，非嚴格模式下為 function scope  var  var 會提升 未宣告使用為 undefined 變數存取範圍為 function scope  const/let  const 跟 let，技術上來說有提升但是未初始化 uninitialized 沒有可取用的值 未宣告使用下會被鎖在 TDZ(temporary dead zone) 變數存取範圍為 block scope  函式表達式跟箭頭函式  函式表達式跟箭頭函式若用 var 存取會提升 未宣告使用是 undefined，反之則跟 const/let 特性一樣 這也是為何在函式表達式中，我們無法使用在宣告變數前調用函式，而函式宣告可以不顧函式宣告順序，任何地方都可以調用  TDZ 是什麼 (ES6 開始出現)  TDZ 為變數初始化前的區塊 下圖 job 在被 const 宣告前被呼叫，會出現 ReferenceError cannot access \u0026lsquo;job\u0026rsquo; before initialization，需要宣告後才能被使用 但如果呼叫完全沒被創造的變數，會顯示另一種訊息 ReferenceError x is not defined 有 TDZ 比較容易抓出未宣告使用的錯誤 另一個 TDZ 存在好處是，因 const 無法重新賦值，所以無法設定 undefined 再給新的值，TDZ 可以讓 const 順利運作 hoisting 的好處：mutual recursion，讓 code 可讀性高，而 var 的 hoisting 算是副產物，後見之明看來不是好東東  ＊下方輸出結果用//表示，且視為單獨出現這行的狀況（彼此之間不影響）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // Variables console.log(me); // not defined console.log(job); // ReferenceError cannot access \u0026#39;job\u0026#39; before initialization console.log(year); // ReferenceError cannot access \u0026#39;job\u0026#39; before initialization  var me = \u0026#39;Jonas\u0026#39;; let job = \u0026#39;teacher\u0026#39;; const year = 1991; -- // Functions console.log(addDecl(2, 3)); // 5 console.log(addExpr(2, 3)); // cannot access \u0026#39;addExpr\u0026#39; before initialization console.log(addArrow(2, 3)); // undefined(2,3) -\u0026gt; // addArrow is not a function  function addDecl(a, b) { return a + b; } const addExpr = function(a, b) { return a + b; }; var addArrow = (a, b) =\u0026gt; a + b;    因為 hoisting 造成的 bug 範例，使用 const/let 可避免，養成先宣告變數再使用的好習慣  1 2 3 4 5 6 7 8 9 10 11  // 原本期待不存在product執行deleteShoppingCart() // 因為沒宣告變數就使用，值變成undefined // !undefined而變成true console.log(!numProducts); //true // !undefined is true if (!numProducts) deleteShoppingCart(); var numProducts = 10; function deleteShoppingCart() { console.log(\u0026#39;All products deleted!\u0026#39;); }    當用 var 宣告，會在 browser 的 window(全域變數)下多一個屬性  1 2 3 4 5 6 7  var x = 1; let y = 2; const z = 3; console.log(x === window.x); // true console.log(y === window.y); // false console.log(z === window.z); // false   this 是什麼?  所有執行文本下都會有的特別變數，值取決於被呼叫的方式 作為 Method(物件下的 function)呼叫時，this 是呼叫他的變數 一般函式呼叫，嚴格模式下 this 值是 undefined，非嚴格模式下為全域物件(瀏覽器為window/node.js是global) 箭頭函式沒有自己的 this，this 值取決於父層(parent scope) eventListener 呼叫時，指向觸發的元素 this 不會是函式自己，也不會是變數環境(Variable Environment) new, call, apply, bind 會於其他篇介紹  ＊下方輸出結果用//表示，且視為單獨出現這行的狀況（彼此之間不影響）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  // this Keyword in Practice console.log(this); //window object  const calcAge = function(birthYear) { console.log(2037 - birthYear); console.log(this); }; calcAge(1991); // 46 嚴格模式 this是undefined 非嚴格模式this是window object  const calcAgeArrow = birthYear =\u0026gt; { console.log(2037 - birthYear); console.log(this); }; calcAgeArrow(1980); // 父層的this window object  const jonas = { year: 1991, calcAge: function() { console.log(this); console.log(2037 - this.year); }, }; jonas.calcAge(); // 46 jonas呼叫 this是jonas  const matilda = { year: 2017, }; matilda.calcAge = jonas.calcAge; // copy calcAge method from jonas matilda.calcAge(); // matilda, 20  // this是動態的 const f = jonas.calcAge; // copy function to a new variable f(); // 一般函式方法呼叫this undefined, cannot read property \u0026#39;year\u0026#39; of undefined at calcAge   讓 this 指向父層的 2 種做法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  // var firstName = \u0026#39;Matilda\u0026#39;;  const jonas = { firstName: \u0026#39;Jonas\u0026#39;, year: 1991, calcAge: function() { // console.log(this); // jonas  console.log(2037 - this.year); // Solution 1 (ES6前) 在函式外定義self為this 取得jonas  // const self = this; // self or that  // const isMillenial = function () {  // console.log(self);  // console.log(self.year \u0026gt;= 1981 \u0026amp;\u0026amp; self.year \u0026lt;= 1996);  // };  // Solution 2 （modern) 使用箭頭函式，沒有自己的this，會往父層找  const isMillenial = () =\u0026gt; { console.log(this); console.log(this.year \u0026gt;= 1981 \u0026amp;\u0026amp; this.year \u0026lt;= 1996); }; isMillenial(); // 一般函式呼叫 嚴格模式下undefined 除非用self綁定this或用箭頭函式呼叫  }, greet: () =\u0026gt; { console.log(this); console.log(`Hey ${this.firstName}`); }, }; jonas.greet(); jonas.calcAge(); // 沒有solution狀況下 cannot read property of \u0026#39;year\u0026#39; of undefined   一般函式 v.s. 箭頭函式 物件內的函式  當使用一般函式會有自己的 this，可以取得 jonas.firstName 當使用箭頭函式會沒有自己的 this，會往父層取變數，bug 通常在這裡發生（可能取得 undefined 或真的有一個變數值) 全域避免使用 var  1 2 3 4 5 6 7 8 9 10 11 12  // 用 let/const 的話會是 undefined，使用 var 就會是\u0026#39;hey mirenda\u0026#39; var firstName = \u0026#39;mirenda\u0026#39; const jonas = { firstName: \u0026#39;Jonas\u0026#39;, year: 1991, // 箭頭函式沒有自己的this  greet: () =\u0026gt; { console.log(this); console.log(`Hey ${this.firstName}`); }, }; jonas.greet(); // window obj, hey mirenda   arguments  只存在一般函式，箭頭函式沒有  1 2 3 4 5 6 7 8 9 10 11 12  const addExpr = function(a, b) { console.log(arguments); return a + b; }; addExpr(2, 5); addExpr(2, 5, 8, 12); // 雖然function上面參數設定2個，但可以加上更多arguments存到Arguments陣列，可以loop加總這些參數等  var addArrow = (a, b) =\u0026gt; { console.log(arguments); return a + b; }; addArrow(2, 5, 8);    arguments 跟其餘運算子的搭配  1 2 3 4 5 6 7 8 9 10  const restaurant = { orderPizza: function(mainIngredients, ...otherIngredients) { console.log(mainIngredients) console.log(otherIngredients) } } restaurant.orderPizza(\u0026#39;mushrooms\u0026#39;, \u0026#39;onions\u0026#39;, \u0026#39;olives\u0026#39;, \u0026#39;spinach\u0026#39;) // mushrooms [ \u0026#39;onions\u0026#39;, \u0026#39;olives\u0026#39;, \u0026#39;spinach\u0026#39; ] restaurant.orderPizza(\u0026#39;mushrooms\u0026#39;) // mushrooms []    當函式很多 argument 不好記順序，可以傳入一個物件作為參數，函式會解構物件並執行函式 常用於第三方函式庫  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  const restaurant = { starterMenu: [\u0026#39;Focaccia\u0026#39;, \u0026#39;Bruschetta\u0026#39;, \u0026#39;Garlic Bread\u0026#39;, \u0026#39;Caprese Salad\u0026#39;], mainMenu: [\u0026#39;Pizza\u0026#39;, \u0026#39;Pasta\u0026#39;, \u0026#39;Risotto\u0026#39;], orderDelivery: function({ starterIndex = 1, // 預設值  mainIndex = 0, // 預設值  time = \u0026#39;00:00\u0026#39;, // 預設值  address, }) { console.log( `Order received! ${this.starterMenu[starterIndex]}and ${this.mainMenu[mainIndex]}will be delivered to ${address}at ${time}` ); }, }; restaurant.orderDelivery({ time: \u0026#39;22:30\u0026#39;, address: \u0026#39;via del sole, 21\u0026#39;, mainIndex: 2, starterIndex: 2 }); // Order received! Garlic Bread and Risotto will be delivered to via del sole, 21 at 22:30  // 沒有全部參數 會用函式參數的預設值 restaurant.orderDelivery({ address: \u0026#39;via del sole, 21\u0026#39;, starterIndex: 2, }); // Order received! Garlic Bread and Pizza will be delivered to via del sole, 21 at 00:00   primitives v.s. objects  primitives 包含 數字、字串、布林、undefined、null、Symbol、BigInt，其他都是 objects primitives 記憶體存在 call stack objects 記憶體存在 Heap  primitives  let age = 30 給一個 call stack 的記憶體地址跟 30 的值(0001) let oldAge = age 傳 age 的 call stack 地址(0001)給 oldAge primitives 的值是 immutable（不可變更），當我們寫 age = 31 會再給一個新的記憶體的地址跟值給 age(0002)，而非修改原本的 30 的那塊記憶體(0001)的內容  objects  const me = {name: \u0026lsquo;Jonas\u0026rsquo;}，給一個 call stack 記憶體的地址跟 Heap 的地址 因為物件檔案可能太大，所以記憶體實際上是存在 Heap const friend = me，會傳 me 記憶體的地址給 friend friend.name = \u0026lsquo;mirenda\u0026rsquo; 物件跟上面的 primitives 不同，會改到 me 的值(D30F)，值參照同樣的 Heap 地址，並沒有另外再給一個新的記憶體，可以參考下方圖表的箭頭（只有一個)  常用淺拷貝方法  Object.assign 用於物件  1 2 3 4 5 6 7 8 9 10 11  const jessica = { firstName: \u0026#39;Jessica\u0026#39;, lastName: \u0026#39;Williams\u0026#39;, age: 27, family: [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;], }; const jessicaCopy = Object.assign({}, jessica); jessicaCopy.lastName = \u0026#39;Davis\u0026#39;; console.log(\u0026#39;Before marriage:\u0026#39;, jessica.lastName); // \u0026#39;Williams\u0026#39; console.log(\u0026#39;After marriage: \u0026#39;, jessicaCopy.lastName); // \u0026#39;Davis\u0026#39;    展開運算子 除了物件外也可用於 string、array、array-like、Set、Map 等可迭代物件  1 2  const arr = [1, 2, 3] const arrCopy = [...arr]   ","date":"2022-01-03T00:00:00+08:00","image":"https://bacnotes.github.io/p/javascript-behind-the-scenes/kanan-khasmammadov-7K8_U900tVc-unsplash_hu1499a893ce824cc10dc28f27c37e5d8f_1839383_120x120_fill_q75_box_smart1.jpg","permalink":"https://bacnotes.github.io/p/javascript-behind-the-scenes/","title":"JavaScript底層運作原理101｜bacnotes備份筆記"},{"content":"完全沒接觸過 JavaScript 的朋友可以先補足下方知識點再繼續閱讀唷\n JavaScript 基礎知識複習(1) JavaScript 基礎知識複習(2)  Document Object Model(DOM) 是什麼  將 HTML 元素變成文件物件模型，由節點 Node 組成的樹狀結構 讓 JavaScript 可以修改 HTML 內容跟改變 CSS 樣式(HTML 的 style 屬性) DOM 最上方結構是 document 物件，是我們對 DOM 的 entry point 節點之間有縱向的父子關係(parent/child)或橫向的兄弟關係(sibling) 第一個子元素通常是 HTML(也被稱作根元素)，下方通常有兩個子元素 head 跟 body，互為 sibling DOM 方法(e.g. querySelector)跟屬性(e.g. innerHTML)不屬於 JavaScript 這個語言，而是 WebAPIs(瀏覽器上使用 JavaScript 撰寫的 library)的一部分 我們可以用 JavaScript 去跟 WebAPIs 互動，像是 timer、fetch API  選取元素 選取單個元素 document.querySelector()  回傳相符的第一個元素  1 2  document.querySelector(\u0026#39;#id\u0026#39;) //id selector document.querySelector(\u0026#39;.classname\u0026#39;) //class selector   選取多個元素 document.querySelectorAll()  回傳所有相符的元素於一個 nodeList 類陣列 比單個元素多 index 與 length 屬性 只能使用部分陣列方法(e.g. forEach, index, length)  1 2  document.querySelectorAll(\u0026#39;.classname\u0026#39;) // class selector document.querySelectorAll(\u0026#39;li\u0026#39;) // type selector   選取多個元素中特定條件 1 2  // 選取tbody第一行內容 document.querySelectorAll(\u0026#39;.className tbody tr\u0026#39;)[0]   選取文字內容 innerHTML v.s. innerText v.s. textContent 下方是一段 HTML\n1 2 3 4  \u0026lt;section class=\u0026#34;left\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; class=\u0026#34;guess\u0026#34; /\u0026gt; \u0026lt;button class=\u0026#34;btn check\u0026#34;\u0026gt;Check!\u0026lt;/button\u0026gt; \u0026lt;/section\u0026gt;    innerHTML 選取元素下的整個 HTML 結構  1 2 3 4 5 6 7  console.log(document.querySelector(\u0026#39;.left\u0026#39;).innerHTML) //  \u0026lt; input type = \u0026#34;number\u0026#34; class = \u0026#34;guess\u0026#34; \u0026gt; \u0026lt; button class = \u0026#34;btn check\u0026#34; \u0026gt; Check! \u0026lt; /button\u0026gt;    innerText 選取整個 HTML 下可見(非 display:none)的文字 會讀取 CSS，效能較差  1 2 3 4  console.log(document.querySelector(\u0026#39;.left\u0026#39;).innerText) // Check!    textContent 選取整個 HTML 下的所有文字(包含空白) 不會讀取 CSS，效能較好  1 2 3 4  console.log(document.querySelector(\u0026#39;.left\u0026#39;).textContent) //  Check!   document.querySelector().value 選取表單元素值 1  document.querySelector(\u0026#39;.className\u0026#39;).value;   修改元素內容 在選取元素後加上 = 即可\n1  document.querySelector(\u0026#39;.className\u0026#39;).value = 1   修改 CSS 樣式 修改特定屬性 1 2 3 4  // 修改顏色 document.querySelector(\u0026#39;body\u0026#39;).style.background = \u0026#39;#ffffff\u0026#39; // 修改寬度 document.querySelector(\u0026#39;.number\u0026#39;).style.width = \u0026#39;10rem\u0026#39;   新增/切換/刪除/確認 class 1 2 3 4  document.classList.add(\u0026#39;hidden\u0026#39;); document.classList.toggle(\u0026#39;hidden\u0026#39;); document.classList.remove(\u0026#39;hidden\u0026#39;); document.classList.contains(\u0026#39;hidden\u0026#39;);   新增/切換/刪除/確認 屬性/回傳屬性值 1 2 3 4 5  document.setAttribute(\u0026#39;disable\u0026#39;); document.toggleAttribute(\u0026#39;disable\u0026#39;); document.removeAttribute(\u0026#39;disable\u0026#39;); document.hasAttribute(\u0026#39;disable\u0026#39;); // 是否包含指定屬性 return boolean document.getAttribute(\u0026#39;width\u0026#39;); // 回傳指定屬性值 e.g. 18rem 不存在會回傳null   設置監聽事件  第一個參數為事件，第二個為執行{}內容，第三個是否捕捉冒泡事件 第三個參數沒有設定時預設為 false 監聽冒泡事件，設定為 true 監聽捕捉事件  1  element.addEventListener(event, function, useCapture)   滑鼠點擊事件 click 1 2 3 4 5 6 7  // 選取按鈕跟呈現訊息元素 const guessButton = document.querySelector(\u0026#39;.check\u0026#39;) const message = document.querySelector(\u0026#39;.message\u0026#39;) // 用addEventListener監聽guessButton元素上的click事件 guessButton.addEventListener(\u0026#39;click\u0026#39;, function() { console.log(\u0026#39;click\u0026#39;) })   按鍵事件 keydown v.s. keyup v.s. keypress  keydown 按下去時觸發(不放開會連續觸發) keyup 抬起來時觸發 keypress 按著時觸發(不放開會連續觸發)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // 任何鍵盤皆可觸發keypress事件 document.addEventListener(\u0026#39;keypress\u0026#39;, function() { console.log(\u0026#39;key pressed\u0026#39;) }) // 任何鍵盤皆可觸發keydown事件 document.addEventListener(\u0026#39;keydown\u0026#39;, function(e) { //只在esc按鍵下觸發  if (e.key === \u0026#39;Escape\u0026#39;) { // 在modal\u0026#34;沒有\u0026#34;hidden class下，也就是顯示modal時觸發  if (!modal.classList.contains(\u0026#39;hidden\u0026#39;)) { console.log(\u0026#39;close modal\u0026#39;) } } })    keycode: 每一個鍵盤都有一個對應的數字，可以到這裡查詢keycodeInfo  捕捉特定條件事件  監聽觸發事件元素  1 2 3  if (event.target) { console.log(\u0026#39;event\u0026#39;) }    監聽設置在父元素，下面可能有多個子元素，設置 data-* attribute，符合條件的才觸發  1 2 3  if (event.target.dataset.id === 變數) { console.log(\u0026#39;event\u0026#39;) }    設置 class，偵測有無特定 class 時觸發  1 2 3  if (!modal.classList.contains(\u0026#39;hidden\u0026#39;)) { console.log(\u0026#39;event\u0026#39;) }   其他常用事件  dblclick(雙擊滑鼠) resize(變更視窗大小) select(選取) focus(當元素處於 focus 聚焦狀態，e.g. 聚焦在表單某一行 input) blur(當元素失去焦點狀態，e.g. 點聚焦元素旁邊內容) DOMContentLoaded(HTML 檔案解析完成，樣式表跟外部資源還在下載時) scroll(捲軸滾動) submit(提交表單) mouseover(滑鼠移到目標) mouseenter(滑鼠移到目標，不會連續觸發) mousemove(滑鼠移動) mouseout(滑鼠離開目標) mouseleave(滑鼠離開目標，不會冒泡) mousedown(按下滑鼠) mouseup(滑鼠放開) contextmenu(按下滑鼠右鍵)  補充 早期選取元素的方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14  // 選取ID document.getElementById(\u0026#39;idName\u0026#39;) 同 document.querySelector(\u0026#39;#idName\u0026#39;) // 選取class name document.getElementsByClassName(\u0026#39;className\u0026#39;) 同 document.querySelectorAll(\u0026#39;.className\u0026#39;) // 選取HTMLCollection document.getElementsByTagName(\u0026#39;li\u0026#39;) 同 document.querySelector(\u0026#39;li\u0026#39;) // 選取name 属性的值 在不同瀏覽器的邏輯不同，避免使用 document.getElementsByName()   NodeList v.s. HTMLCollection  NodeList 為節點的集合，包含 HTML 元素節點和其他節點(e.g. 屬性節點、文字節點等) HTMLCollection 為 HTML 元素集合，只有元素節點，不包含其他節點 HTMLCollection 多一個 nameItem()方法，可以回傳集合中 name 屬性和 id 屬性值的元素  ","date":"2022-01-02T00:00:00+08:00","image":"https://bacnotes.github.io/p/javascript-dom-manipulation/jade-seok-WOv2t_N6iwQ-unsplash_hueaef48dcbe256bb88acf1618f8b7005a_507165_120x120_fill_q75_box_smart1.jpg","permalink":"https://bacnotes.github.io/p/javascript-dom-manipulation/","title":"DOM操作基礎知識複習｜bacnotes備份筆記"},{"content":"使用嚴格模式提高程式碼品質 在檔案最上方加 'use strict mode' ，會幫你檢查哪些不適當的撰寫程式方式，下方狀況會拋出錯誤\n 有未宣告的全域變數 對於無法寫入的變數(e.g. NaN, undefined)或不存在的物件屬性賦值 刪除不能刪除的屬性(e.g. delete Object.prototype) 物件屬性不是唯一值 unique Function 名稱有重複 deleting plain names  1 2  var x; delete x; // !!! syntax error    使用到 reserved keywords  function  可用來實踐 dry code，重複使用一樣的邏輯，傳不同的參數 parameter 指 function 括弧中寫的變數名稱 argument 是用在實際呼叫的值 call = invoke = execute = run 都是代稱執行(函式)的動詞  1 2 3 4 5 6  function fruitProcessor(applesCount, orangesCount) { const juice = `juice with ${applesCount}apples \u0026amp; ${orangesCount}oranges`; return juice; } fruitProcessor(2, 5); // \u0026#39;juice with 2 apples \u0026amp; 5 oranges\u0026#39; fruitProcessor(3, 4); // \u0026#39;juice with 3 apples \u0026amp; 4 oranges\u0026#39;   函式宣告 function declaration  呼叫後存到變數  1 2 3 4 5  function calcAge(birthYear) { return 2037 - birthYear; } const age = calcAge(2036); // 放在function前後都可以 因為hoisting console.log(age); // 1   函式表達式 function expression  匿名函式是表達式，會產生 value，存到左邊變數  1 2 3 4  const calcAge = function(birthYear) { return 2037 - birthYear; }; console.log(calcAge(2036)); // 1   箭頭函式 arrow function  ES6 語法，沒有自己的 this，若箭頭函式裡面寫了this，會往父層找，this值取決於父層scope 若箭頭函式直接返回一個物件，必須在物件外面加上小括號(可參考下方範例)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  // 單行程式碼 不需要{}跟return const calcAge = (birthYear) =\u0026gt; 2037 - birthYear; console.log(calcAge(2036)); // 1  // 多行程式碼 需要{}跟return 程式會結束在return這行 const retireAge = (yourName, birthYear) =\u0026gt; { const age = 2037 - birthYear; const retirement = 65 - age; return `${yourName}retires in ${retirement}years`; }; console.log(retireAge(\u0026#34;bacnotes\u0026#34;, 2036)); // bacnotes retires in 64 years  // 單一參數時，小括號可以省略 const print = (a) =\u0026gt; { console.log(a); }; // 多個參數時，小括號不能省略 const print = (a, b) =\u0026gt; { console.log(a, b); }; // 單行程式碼要直接回傳物件時，則需要再套一層小括號，key value一樣{a:a, b:b} 寫 {a,b}即可 const print = (a, b) =\u0026gt; ({ a, b }); // 等於 const print = (a, b) =\u0026gt; { return { a, b, }; };   array 陣列 宣告陣列 1 2  const arrayA = [1, 2, 3]; const arrayB = new Array(123, 123, 123);   ＊JavaScript 的內建物件都不建議 new 作初始定義的。不過有一些特例是一定要的，例如 Date、Error 等等。\n陣列取值，序號從 0 開始 1 2 3  array[0] // 第1個元素值 array[n] // 第n+1個元素值 array[arr.length - 1] 陣列尾巴元素值   修改陣列元素值 1  arrayA[2] = 234;    const 不是不能修改值嗎？ 單獨修改元素值是可以的 如果是 arrayA = [\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;] 就不行，因為就表示重新賦值整個陣列 補充 immutable（不可變更）跟 mutable（可變更）：只有賦值時是傳值的 primitives 是 immutable，而賦值時是傳址的陣列、物件內部值是 mutable  想更了解傳值跟傳址在記憶體裡的運作方式，可以參考這一篇 JavaScript 底層運作原理 101\narray 方法  array.push() 新增元素到陣列最後面，回傳陣列新的長度  1 2 3 4  const friends = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;]; const newFriend = friends.push(\u0026#34;e\u0026#34;); console.log(friends); // [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39; ] console.log(newFriend); // 5    array.pop() 刪除陣列最後一個元素 並回傳 刪除的元素值  1 2 3 4  const friends = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;]; const popFriend = friends.pop(); console.log(friends)[(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;)]; console.log(popFriend); // e    array.unshift() 新增元素到陣列最前面，回傳陣列新的長度  1 2 3 4  const friends = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;]; const unshiftFriend = friends.unshift(\u0026#34;z\u0026#34;); console.log(friends); // [ \u0026#39;z\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39; ] console.log(unshiftFriend); // 5    array.shift() 刪除陣列第一個元素，回傳刪除的元素值  1 2 3 4  const friends = [\u0026#34;z\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;]; const shiftFriend = friends.shift(); console.log(friends); // [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39; ] console.log(shiftFriend); // z    array.indexOf(element, fromIndex) 搜尋元素索引位置  1 2 3 4 5  const friends = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;]; const positionD = friends.indexOf(\u0026#34;d\u0026#34;); console.log(positionD); // 3 const positionL = friends.indexOf(\u0026#34;l\u0026#34;); console.log(positionL); // if not existed return -1    array.includes(element, fromIndex) 回傳陣列中是否有這個元素  1 2 3  const hasLowerCaseA = friends.includes(\u0026#34;a\u0026#34;); const hasUpperCaseA = friends.includes(\u0026#34;A\u0026#34;); console.log(hasLowerCaseA, hasUpperCaseA); // true, false   其他的 array 方法可以參考這篇 陣列的處理方法。另外也推薦oxxostudio的這篇JavaScript Array 陣列操作方法大全 ( 含 ES6 )\nobject 物件  key value pair格式 value 可以儲存不同格式的資料  宣告物件 1 2 3 4 5 6 7  const jonas = { firstName: \u0026#34;Jonas\u0026#34;, lastName: \u0026#34;Schmedtmann\u0026#34;, age: 28, job: \u0026#34;teacher\u0026#34;, friends: [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;], };   dot notation 取值：物件. 屬性  直觀簡潔 特殊字元的賦值、取值無法透過dot notation取得 無法使用變數進行操作  1  console.log(jonas.lastName); // \u0026#39;Schmedtmann\u0026#39;   bracket notation 取值：物件[\u0026lsquo;屬性\u0026rsquo;]  []裡面是一個 expression，屬性記得用單引號包裹 可以使用變數在[]進行操作  1 2 3 4  console.log(jonas[\u0026#34;lastName\u0026#34;]); // \u0026#39;Schmedtmann\u0026#39;  const nameKey = \u0026#34;Name\u0026#34;; console.log(jonas[\u0026#34;last\u0026#34; + nameKey]); // \u0026#39;Schmedtmann\u0026#39;   brackets notation 可以使用 expression，dot notation 無法 1 2 3 4 5 6 7 8 9 10 11 12 13 14  const interestedIn = prompt( \u0026#34;what do you want ot know about Jonas? Choose between firstName, lastName,age or job\u0026#34; ); // dot notation 無法用expression取得屬性(物件沒有interestedIn的屬性) console.log(jonas.interestedIn); // undefined  // bracket 可使用expression取得屬性 console.log(jonas[interestedIn]); // teacher  // 當屬性存在列印出屬性值，屬性不存在時列印出\u0026#39;data not existed\u0026#39; jonas[interestedIn] ? console.log(jonas[interestedIn]) : console.log(\u0026#34;data not existed\u0026#34;);   新增/修改元素值：使用 = 賦值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // dot notation jonas.location = \u0026#39;Portugal\u0026#39; // bracket notation jonas[\u0026#39;twitter\u0026#39;] = \u0026#39;@jonas\u0026#39; jonas.age = 82 console.log(jonas) // { firstName: \u0026#39;Jonas\u0026#39;, lastName: \u0026#39;Schmedtmann\u0026#39;, age: 82, job: \u0026#39;teacher\u0026#39;, friends: [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;], location: \u0026#39;Portugal\u0026#39;, twitter: \u0026#39;@jonas\u0026#39; } // 使用模板字串 console.log(`${jonas.firstName}has ${jonas.friends.length}friends, and his best friends is called ${jonas.friends[0]}`) // Jonas has 3 friends, and his best friends is called a   object 方法  物件的 function，習慣叫 method  1 2 3 4 5 6 7 8 9 10 11 12 13 14  const jonas = { firstName: \u0026#34;Jonas\u0026#34;, lastName: \u0026#34;Schmedtmann\u0026#34;, birthYear: 2000, age: 28, job: \u0026#34;teacher\u0026#34;, friends: [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;], // 方法  calcAge: function(birthYear) { return 2027 - birthYear; }, }; console.log(jonas.calcAge(2000)); // 27 console.log(jonas[\u0026#34;calcAge\u0026#34;](2000)); // 27    關於 this 的使用，有助於精簡程式碼 如果需要用一樣的物件，寫 this 就不需要修改寫死的變數  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const jonas = { firstName: \u0026#34;Jona\u0026#34;, lastName: \u0026#34;Schmedtmann\u0026#34;, birthYear: 2000, age: 28, job: \u0026#34;teacher\u0026#34;, friends: [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;], hasDriverLicense: true, calcAge: function() { // return 2027 - jonas.birthYear 寫字的名字會不好維護  this.age = 2027 - this.birthYear; return this.age; // 更新值就不用每次調用都重複計算，減少浪費效能  }, };   for 迴圈  for ([初始表達式]; [條件為真時會執行{}內容]; [更新表達式]) 適合確定迴圈次數時使用(e.g. by array 的元素長度或一個數字) 可用來精簡重複執行重複的程式碼  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 假設要執行10次，從0開始到9結束 // 從 i = 0 開始，當(i \u0026lt; 9)條件為true會執行{}內的內容，完成後i++ for (let i = 0; i \u0026lt; 9; i++) { console.log(`lifting weights repetition ${i}🏋️‍♀️ `) } // lifting weights repetition 0🏋️‍♀️ lifting weights repetition 1🏋️‍♀️ lifting weights repetition 2🏋️‍♀️ lifting weights repetition 3🏋️‍♀️ lifting weights repetition 4🏋️‍♀️ lifting weights repetition 5🏋️‍♀️ lifting weights repetition 6🏋️‍♀️ lifting weights repetition 7🏋️‍♀️ lifting weights repetition 8🏋️‍♀️ lifting weights repetition 9🏋️‍♀️    反向迴圈 Backwards loop  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 假設要執行10次，從9開始到0結束 // 從 i = 9 開始，當(i \u0026gt; 0)條件為true會執行{}內的內容，完成後i-- for (let i = 9; i \u0026gt;= 0; i--) { console.log(`lifting weights repetition ${i}🏋️‍♀️ `) } // lifting weights repetition 9🏋️‍♀️ lifting weights repetition 8🏋️‍♀️ lifting weights repetition 7🏋️‍♀️ lifting weights repetition 6🏋️‍♀️ lifting weights repetition 5🏋️‍♀️ lifting weights repetition 4🏋️‍♀️ lifting weights repetition 3🏋️‍♀️ lifting weights repetition 2🏋️‍♀️ lifting weights repetition 1🏋️‍♀️ lifting weights repetition 0🏋️‍♀️    陣列使用迴圈迭代元素  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // 範例1 迭代元素資料類型並放到另一陣列type const arr = [1, 2, 3]; const type = []; for (let i = 0; i \u0026lt; arr.length; i++) { console.log(arr[i]); // filling types array  type[i] = typeof arr[i]; } console.log(type); // [ \u0026#39;number\u0026#39;, \u0026#39;number\u0026#39;, \u0026#39;number\u0026#39; ]  // 範例2 迭代元素元素值並放到另一陣列ages const years = [1991, 2003, 2022, 1972]; const ages = []; for (let i = 0; i \u0026lt; years.length; i++) { ages.push(2038 - years[i]); } //[ 47, 35, 16, 66 ]  // 範例3 使用比較簡潔的forEach語法 列印出元素 const arr = [1, 2, 3]; arr.forEach(function(element) { console.log(element); });    continue: 跳出本次迴圈，執行下個迴圈(e.g. i = 2 → i = 3)  1 2 3 4 5 6 7 8  const arrayB = [\u0026#34;stringA\u0026#34;, \u0026#34;stringB\u0026#34;, 1, 2022 - 11, true]; for (let i = 0; i \u0026lt; arrayB.length; i++) { if (typeof arrayB[i] !== \u0026#34;string\u0026#34;) continue; console.log(arrayB[i], typeof arrayB[i]); } // stringA string // stringB string    break: 終止整個迴圈  1 2 3 4 5 6  for (let i = 0; i \u0026lt; arrayB.length; i++) { if (typeof arrayB[i] === \u0026#34;number\u0026#34;) break; console.log(arrayB[i], typeof arrayB[i]); } // stringA string // stringB string    巢狀迴圈  1 2 3 4 5 6  for (let i = 0; i \u0026lt; 4; i++) { console.log(`-----starting excercise ${i}`); for (let j = 1; j \u0026lt; 3; j++) { console.log(`-----lifting ${j}time🏋️‍♀️`); } }   while Loop  while (condition) 當條件為真，則會一直執行{} 適合不確定迴圈次數時使用(e.g. Math.random 的亂數)  1 2 3 4  while (i \u0026lt; 10) { text += \u0026#34;The number is \u0026#34; + i; i++; }    隨機 1-6 的骰子，骰到 6 才會停止  1 2 3 4 5 6 7 8 9 10  let dice = Math.floor(Math.random() * 6 + 1); // 隨機產生1~6的數字  while (dice !== 6) { console.log(`Your rolled a ${dice}`); dice = Math.floor(Math.random() * 6) + 1; if (dice === 6) console.log(`Loop is about to end...`); } // Math.floor() 回傳小於等於所給數字的最大整數。(正數時等於無條件捨去，負數時等於無條件進位) // Math.random() 回傳一個偽隨機小數(pseudo-random) 介於0到1之間(包含0，不包含1)   ＊以上是 JavaScript 的基礎複習，如果喜歡的話還可以繼續往下看唷。 JavaScript 進階函式知識｜ The Complete JavaScript Course\n","date":"2021-12-31T00:00:00+08:00","image":"https://bacnotes.github.io/p/javascript-fundamentals-part2/javascript_hu206ed96a14226138f3215dbd4aa48c79_350158_120x120_fill_box_smart1_3.png","permalink":"https://bacnotes.github.io/p/javascript-fundamentals-part2/","title":"JavaScript基礎知識複習(2)｜bacnotes備份筆記"},{"content":"最近看到網路上文章有人推這堂 Udemy 的 JavaScript 課程，然後就買下來了 The Complete JavaScript Course - From Zero to Expert\n為什麼想上這堂課 由於整堂課有 69 小時，自己擷取的重點不一定符合所有階段的學習者，可能比較精簡 如果有看不懂的地方可以在下方留言，或建議還是來親自體驗一下這堂課 下方也會加入一些自己過往學習 JavaScript 的筆記\n什麼是 ES6（ECMAScript6）？  ECMAScript 是一個規範，JavaScript 實作了這個規範 JavaScript 在 2015 年迎來了一次大更新，更新後的版本叫 ES6（ES2015），俗稱 Modern JavaScript 當你使用 Google 跟 StackOverflow 社群都找不到解答，閱讀這份文件ECMAScript也許會有助於你 debug 你可能聽過 Vue、React、Angular 這些不同的 JavaScript 套件或是框架，不過最後都會被打包成 JavaScript 在瀏覽器上運行。 隨著時代演進使用的框架可能會變，但熟悉 JavaScript 有助於未來與時俱進  ES6 新增了哪些語法 解構賦值  可以用精簡的語法來命名變數，可彈性修改變數名稱  1 2 3 4 5 6 7 8 9 10 11  const variable = { a: 1, b: 2, c: 3 } const { a, b, c: cat } = variable //若想針對c做新變數命名為cat  console.log(a, b, cat) // 1 2 3    可以用來定義預設值，由於從遠端取用資料可能會有預料外狀況(例如取不到資料變成 undefined)，有預設值可以套用比較保險  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  const restaurant = { starterMenu: [\u0026#39;Focaccia\u0026#39;, \u0026#39;Bruschetta\u0026#39;, \u0026#39;Garlic Bread\u0026#39;, \u0026#39;Caprese Salad\u0026#39;], } // 解構賦值時加入預設值[] 避免undefined const { menu = [], starterMenu: starters = [] } = restaurant console.log(menu, starters) // [] [ \u0026#39;Focaccia\u0026#39;, \u0026#39;Bruschetta\u0026#39;, \u0026#39;Garlic Bread\u0026#39;, \u0026#39;Caprese Salad\u0026#39; ]  // 函數使用預設參數 function check(a, b = 1, c = 2, d) { console.log(a, b, c, d) } check(1, 3) // 1 3 2 undefined  // 物件方法使用預設參數 const restaurant = { orderDelivery: function({ starterIndex = 1, // 預設值  mainIndex = 0, // 預設值  time = \u0026#39;00:00\u0026#39;, // 預設值  address, // 沒訂預設值  }) { console.log( `${starterIndex}, ${mainIndex}, ${time}, ${address}`); }, }; restaurant.orderDelivery({}) // 1, 0, 00:00, undefined    可以不用另外宣告 temp 暫存變數，就可以互換變數值，很方便  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // 陣列範例 let [a, b] = [1, 2] [a, b] = [b, a] console.log(a, b) // 2 1 // 物件範例 let a = 1 let b = 2 const obj = { a: 11, b: 22 } ({ b, a } = obj) // 不能直接對block{}賦值，需要包在()中 console.log(a, b) // 22 11    讓取出巢狀內變數變得很簡單  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 陣列範例  const nested = [1, 2, [3, 4]] const [i, , [j, k]] = nested console.log(i, j, k) // 1 3 4  // 物件範例  const openingHours = { fri: { open: 0, // Open 24 hours  close: 24 }, }; const { fri: { open, close } } = openingHours console.log(open, close) // 0 24   Promise 語法  解決了 callback hell（難以維護跟閱讀的巢狀程式碼） ES7 有 async/await 更好讀  展開運算子  可以展開物件、淺拷貝、合併陣列、把可迭代的物件（string、array、array-like、Set、Map）跟非迭代物件 objects 變成陣列，且不用新增變數  1 2 3 4 5 6  const arr = [1, 2, 3] const arrCopy = [...arr] const str = \u0026#39;Jonas\u0026#39; const letters = [...str] // [\u0026#39;J\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;]  console.log(...str) // J o n a s   其餘運算子  可以將陣列後方剩下的值存成一個陣列，解構賦值時好用（不會存取 skip, , 的 key 跟有出現過的 key）  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // 陣列範例 const [x, , ...y] = [13, 25, 33, 2]; console.log(x); // 13 console.log(y); // [33, 2]  // 物件範例 const restaurant = { openingHours: { thu: 12, fri: 13, sat: 12 } } const { sat, ...weekdays } = restaurant.openingHours console.log(weekdays) = { thu: 12, fri: 13 }   箭頭函式  可以打較少的程式碼，提高程式碼可讀性 過往 this 值依照執行環境所有不同，不好判斷 而箭頭函式的 this 則是綁定定義他（而非呼叫他）的物件，看他身處在的 function scope 的 this 指向誰 白話文：箭頭函式沒有自己的 this，但可以使用父層的 this  模板字串  過往可以透過單引號或雙引號跟加號拼接字串，巢狀的時候需要雙引號包裹單引號(反過來則不行) 遇到拼接內容是 HTML 結構，換行需要加 \\n ，使用上麻煩閱讀上也不容易 想寫縮寫或所有格（e.g. I\u0026rsquo;m cool, bac\u0026rsquo;s）的英文內容可能遇到需要用跳脫字元\u0026quot;I'm\u0026quot;，而字串模板解決了上述不方便使用的問題  1 2 3 4 5 6  const yourName = \u0026#39;bacnotes\u0026#39;; const codeName = \u0026#39;JavaScript\u0026#39;; const string = `Hi I\u0026#39;m ${yourName}` And I love $ { codeName }!!`;   Enhanced Object Literals  屬性名跟本地變量名相同可以省略後面的冒號跟值  引入 class 類  作為 JavaScript 現有原型程式(prototype-based)繼承的語法糖  引入模組 Import and Export modules  方便管理程式碼之間的相依性，非同步載入（過往 require 是同步語法）  JavaScript 在網頁渲染時執行位置  瀏覽器渲染畫面流程：建立 DOM → 建立 CSSOM → 合併為 Render Tree → Layout（空間位置排版佈局） → Paint（繪製畫面，轉換成像素做呈現） 由於 JavaScript 在執行時，會停止渲染動作，阻塞 DOM 和 CSSOM 的建構過程 因此會建議把 script 放在 HTML 內容下方，也就是\u0026lt;/body\u0026gt;前  1 2 3 4 5  \u0026lt; body \u0026gt; ... \u0026lt; script src = \u0026#39;./script.js\u0026#39; \u0026gt; \u0026lt; /script\u0026gt; \u0026lt; / body \u0026gt;    如果為了效能想提早載入資源而希望把 script 放在\u0026lt;head\u0026gt;區塊，需要加一個defer屬性避免阻擋渲染過程（DOM 還在建立） 若使用async屬性，下載後會立刻執行但不保證順序，且請求回來後會停止解析，還是可能遇到 DOM 跟 CSSOM 還在生成，選不到元素，適合用在不會針對操作 DOM 的 script（e.g. Google Analytics）  JavaScript 變數命名限制  變數 variable 用來存取 value JavaScript 習慣小寫駝峰命名yourName，大寫開頭表示建構子 使用有意義的命名（e.g. firstJob、currentJob而非job1、job2） 不能用數字開頭當變數 不接受 - 符號（會當成減號) 變數內容只能包含數字、英文字、_、$ _跟$開頭的命名通常是有特別用途（e.g. 私有變數） 不能使用 Reserved keywords（e.g. new、function），但$new或_funtion是合法的 name 是 Reserved keywords，可以合法使用但可能有風險，寧願用firstName等等  error msg 與 console.log  SyntaxError: 語法結構錯誤（可能是括弧、拼字大小寫） ReferenceError: 引用錯誤（沒被定義、找不到檔案） RangeError: 超出參數範圍 TypeError: 型別錯誤 EvalError: eval()方法使用錯誤 URIError: url 錯誤 如果 console.log 結果無法在瀏覽器的 dev tools 顯示出來，點右邊齒輪確認勾選狀況(一般會是勾 default value)，可參考這篇 https://blog.csdn.net/xianyu_Padding/article/details/78013754  Data types 型別跟 Dynamic type  Number(整數/浮點數) String(文字) Boolean(true/false) Object(物件/陣列/函式) Undefined(已宣告無定義) null(空值/empty value) Symbol(ES2015) unique 且無法被改變的 value BigInt(ES2020) 大整數 非 number 可以保存的 value JavaScript 在命名變數時不用手動定義型別，同一個變數可以賦予不同型別的值 變數可能原本是數字，後面變成字串，這也是 bug 產生的風險(但現在也有 typescript XD) 確認變數型別typeof 變數 typeof 變數 得到的是固定的七種字串值:'undefined' 'object' 'boolean' 'number' 'string' 'function' 'symbol'  null v.s. undefined v.s. not defined  null 有宣告/有賦值 但是是一個空值 → 系統提示沒抓到元素 (e.g. array 當中 key 存在但值是空的) undefined 有宣告/沒賦值 → 系統提示沒有賦值 not defined 沒宣告/沒賦值 → 系統提示沒有宣告  宣告變數方式 let、const、var 從 ES6 開始有了 const 跟 let 兩種新的呼叫方式 並且最小的區塊切分從 function 變成 block{}，避免變數污染的發生\n  let 跟 const 的差異 \u0026ndash; let 的變數隨時可以用 = 重新賦值 \u0026ndash; const 的變數無法用 = 重新賦值，適合用在常數，若為陣列或物件屬性的值還是可被改變 \u0026ndash; const 若為 primitives，不能做 var += var 的操作 \u0026ndash; 由於值的變更有產生 bug 的風險，基本上宣告會使用 const ，若會重複賦值再用 let\n\u0026ndash; 不會使用早期的宣告變數方式 var ，早期宣告變數方法只有 var 搭配 function 把作用域鎖在函式裡面，但若放在 if else 等區塊語句，會讓 var 宣告的變數洩漏到全域，造成變數污染\n  let 跟 const 的共同處 \u0026ndash; 同區塊上不能重複宣告 \u0026ndash; 區塊內宣告不會洩漏到全域\n  作用域 \u0026ndash; var 在主程式區是全域變數，在 function 內是區域變數 \u0026ndash; 在 block 區塊語句（if、else、for、while 等）裡面用 var 宣告的變數，會洩漏到全域中，造成區域變數覆蓋全域變數\n  絕對不要直接命名而不使用let const var \u0026ndash; 像是 job = 'code'\n\u0026ndash; 沒有 scope，會變成全域變數，而且不在控管下，會造成記憶體管理問題\n  算數運算子 Arithmetic Operator  + = * / ** % ++ -- 加減乘除 指數 取餘數 遞增 遞減 x++ 跟 ++x 有執行順序的差別，前者先列印結果再相加，後者先相加再列印結果 運算子還可以用做合併字串 字串1+ ' '+ 字串2，但現在合併字串多用 template literal  指派運算子 Assignment operators  = += -= *= /= %= 將等號右邊的值拷貝給左邊的變數資料  比較運算子 Comparison operators  == === != !== \u0026gt; \u0026gt;= \u0026lt; \u0026lt;= 可以用來把判斷的結果存在變數  1 2  console.log(age \u0026gt;= 18); // true 判斷用的參數 const isFullAge = age \u0026gt;= 18;   Operator precedence 運算子優先順序  MDN可以查詢，不用背有個概念即可 如果搞不懂順序，用()把確定要先執行的段落包起來，權重最高  1 2 3 4 5 6 7 8  () 21 * / 14 + - 13 \u0026gt; \u0026lt; 比較 11 \u0026amp;\u0026amp; 6 || 5    解釋了為何程式可以正確執行類似有許多運算子卻不會誤判執行順序  1 2 3 4  const now = 2039; const ageJonas = now - 1991; const ageSarah = now - 2003; console.log(now - 1991 \u0026gt; now - 2003); // true    = 執行順序右到左  1 2 3 4  let x, y x = y = 25 - 10 - 5 console.log(x, y) // 10 10 假設是左到右 x＝ y時 y會是undefined 所以必須是右到左   顯性轉型 Type Conversion  String() 可以將 null 和 undefined 轉換為字串 toString() 可以將所有資料都轉換為字串 但是要排除 null 和 undefined（TypeError: Cannot read property \u0026rsquo;toString\u0026rsquo; ） toString(value, radix) 可以轉 2 或 8 或 10 或 16 進位字串 JSON.stringify()轉成 JSON 字串\u0026quot;\u0026quot; parseInt(string, radix) 字串轉成數字，若第一個字符無法轉換為數字回傳 NaN Number() 字串轉成數字，undefined 回傳 NaN，null 回傳 0，true 回傳 1，false 回傳 0 Boolean() 如果沒傳值，或者是 0、-0、null、false、NaN、undefined、空字串會轉成 Boolean  隱性轉型 Coercion 運算子  - * /會轉成數字'23' - '10' - 3 // 10 +會轉成字串'23' + '10' // 2310 綜合 10 - 3 - 3 + '1' // 41 == === != !==  也會，可以看下方的嚴格的等號 v.s. 寬鬆的等號說明  if () 跟!  if (變數) 在 if 括弧裡的變數都會強制轉為 Boolean 程式沒寫好可能回傳 null、undefined、NaN 等，若當作條件判斷變成 false 容易造成判斷式錯誤，需要注意。  1 2 3 4 5 6  // 運算前確認型別 if (typeof a === typeof b) { console.log(a + b) } else { console.log(\u0026#39;need to check problem\u0026#39;) }    !(變數)也會讓變數強制轉型  1 2 3 4 5 6 7  !\u0026#34;Hello\u0026#34;; // false !0; // true !{}; // false !null; // true !undefined; // true !NaN; // true !\u0026#34;\u0026#34;; // true   Truthy \u0026amp; Falsy values  Falsy 包含： null、undefined、0、空字串、NaN(不等於自己)、false Big Int 0n 也是 Falsy -1是 true，{}是 true 以下為 Falsy 值導致的錯誤設計範例（設計流程時需注意 falsy）  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 狀況1 let height; if (height) { console.log(\u0026#34;defined\u0026#34;); } else { console.log(\u0026#34;not defined\u0026#34;); } // not defined  // 狀況2 let height = 0; if (height) { console.log(\u0026#34;defined\u0026#34;); } else { console.log(\u0026#34;not defined\u0026#34;); } // not defined 雖然有define為0 但因為0是falsy 所以顯示還是not defined // 此為設計錯誤導致顯示出非預期的結果   嚴格的等號=== v.s. 寬鬆的等號 ==  使用寬鬆的==，會發生會強制轉型，字串跟數字會相等 嚴格的等號會檢查資料型別，不會強制轉型 寬鬆的等號容易產生 bug，所以只會使用===跟!== \u0026quot;0\u0026quot; == false // true (\u0026ldquo;0\u0026quot;轉成數字 0，false 轉成 0)  有興趣可看這份MDN 一般相等比較表 ＊ [] 會先由 toString() 強制轉型為字串，再強制轉型為數字\nAND OR ! 邏輯運算子 用於 if 條件增加判斷  \u0026amp;\u0026amp; (AND)所有條件為 true 才會是 true || (OR)有一個條件是 true 就是 true  1 2 3 4 5 6  當a is false b is true !a // true a \u0026amp;\u0026amp; b // false a || b // true  !a \u0026amp;\u0026amp; b // true a || !b // false   用於 short-circuiting  可以做為 if 條件判斷的 argument，要執行哪一段程式 也可以套用\u0026amp;\u0026amp;或||的邏輯，為變數賦值，讓程式碼更精簡 \u0026amp;\u0026amp; 可以檢查變數是否為 true，true 時才會執行後面的程式碼 || 可以當作處理例外情況，當左邊變數有問題，使用右邊預設值  1 2 3 4 5 6 7 8 9 10  // 不限資料型態 const a = var1 \u0026amp;\u0026amp; var2(當左邊變數為true， 才套用右邊的值， 若為false會套用左邊值) console.log(3 \u0026amp;\u0026amp; \u0026#39;cat\u0026#39;) // \u0026#39;cat\u0026#39; console.log(0 \u0026amp;\u0026amp; null) // 0 console.log(\u0026#39;\u0026#39; \u0026amp;\u0026amp; 0) // \u0026#39;\u0026#39;  const a = var1 || var2(當左邊變數為false， 才套用右邊的值， 若為true會套用左邊值) console.log(3 || \u0026#39;cat\u0026#39;) // 3 console.log(\u0026#39;\u0026#39; || null) // null console.log(undefined || 0 || \u0026#39;\u0026#39; || \u0026#39;hi\u0026#39; || 23) // \u0026#39;hi\u0026#39;   ?? Nullish Coalescing  當左邊變數為 null 或 undefined 才會回傳右邊的值 若非null或undefined，則回傳左邊的值  1 2 3 4 5  const guests = restaurant.numGuests || 10 console.log(guests) // 10 // null or undefined const guestsCorrect = restaurant.numGuests ?? 10 console.log(guestsCorrect) // 10   表達式 statements v.s. 陳述式 expressions  表達式：會回傳結果 e.g. 純值、變數、運算子、執行函式、正規表達式、函式表達式… 陳述式：會執行一些程式碼，可能是幾個單詞或是片段（不會是單一個字母），不會回傳結果 e.g. 宣告（var、function）、流程控制（block、if…else）、迴圈（for、while）、其它（import, export）  流程判斷  if else  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 比較運算子來設定條件，可以搭配\u0026amp;\u0026amp; || !邏輯運算子設定更細緻的判斷 const accountName = prompt(\u0026#34;your accountName: 8 ~ 20 characters\u0026#34;); if (accountName \u0026gt; 8 \u0026amp;\u0026amp; accountName \u0026lt; 20) { console.log(\u0026#34;correct account length\u0026#34;); } else { // 不符合條件，提示使用者檢查帳號長度  console.log(\u0026#34;please check your account length\u0026#34;); } // 有三組以上條件，中間的條件會用else if標示，最後才是else if (a \u0026gt; 10) { console.log(\u0026#34;bigger than 10\u0026#34;); } else if (a === 10) { console.log(\u0026#34;equal to 10\u0026#34;); } else { console.log(\u0026#34;smaller than 10\u0026#34;); }    Ternary Operator（條件運算子）  1 2 3 4 5 6 7  // condition ? exprIfTrue : exprIfFalse const age = 20; const drink = age \u0026gt;= 18 ? \u0026#34;wine\u0026#34; : \u0026#34;water\u0026#34;; console.log(drink); // wine  // expression也可以放到模板字串 console.log(`I can drink ${age \u0026gt;= 18 ? \u0026#34;wine\u0026#34; : \u0026#34;water\u0026#34;}`); // I can drink wine    switch（比較少用，看情況還是可以使用）  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const time = \u0026#34;morning\u0026#34;; switch (time) { case \u0026#34;morning\u0026#34;: console.log(\u0026#34;go to school\u0026#34;); break; case \u0026#34;noon\u0026#34;: console.log(\u0026#34;eat lunch\u0026#34;); break; case \u0026#34;night\u0026#34;: console.log(\u0026#34;sleep\u0026#34;); break; default: console.log(\u0026#34;nothing\u0026#34;); }   JavaScript 小歷史 1 2 3 4 5 6 7  1995 Brendan Eich10天內創造了第一版JavaScript叫 mocha 1996 LiveScript→ JavaScript 改名字希望吸引Java開發者， 但無關乎Java這個程式語言 MS發布IE， 從NetScape copyJavaScript叫JScript 擔心侵權改名， 但還是很像的東西 為了長遠發展， 需要標準化， 於是提交給ECMA獨立機構 1997 ECMAscript ES1發布， 大家使用一樣的標準跟規範開發 2009 ES5 / ES2016(ECMAScript5) 有一些新feature 2015 ES6 / ES2017(ECMAScript6) 新紀元   JavaScript 和瀏覽器的相容性  Backward compatibility: ES1 語法在現代瀏覽器還是相容的 Forwards compatibility: 舊版本 IE8 瀏覽器不理解新版本 JavaScript 的規範 我們可以透過更新瀏覽器避免不相容 ES5: fully supported in all browsers IE9(2011) ES6 → ES2021: well supported in all modern browsers, not in older ones. can use most features in production with transpiling and polyfilling 所以會使用 BABEL ES2022: ESNext future versions can use some features in production with transpiling and polyfilling 先學 Modern JavaScript 但還是需要知道過往 JavaScript 運作方式 e.g. const let v.s. var e.g. function construction v.s ES6 Class 關於Polyfills and transpilers  恭喜你看完這一篇 JavaScript 基礎知識複習(1)，休息一下再往下一篇前進吧！ JavaScript 基礎知識複習(2)\n","date":"2021-12-29T00:00:00+08:00","image":"https://bacnotes.github.io/p/javascript-fundamentals-part1/javascript_hu206ed96a14226138f3215dbd4aa48c79_350158_120x120_fill_box_smart1_3.png","permalink":"https://bacnotes.github.io/p/javascript-fundamentals-part1/","title":"JavaScript基礎知識複習(1)｜bacnotes備份筆記"},{"content":"什麼是 Google Analytics \u0026amp; Google Search Console Google Analytics：分析流量來源與站內行為表現  可以看進站管道分布，包含直接流量、自然搜尋、社群網站、其他網站連結導入或是來自廣告等等 可以了解到達網頁(landing page)集中在哪些頁面 觀看使用者類型與進站後的使用者行為，像是停留時間，觀看了幾頁，跟離開頁面 確認是否跟原本規劃的網站體驗流程相似，或是在哪些頁面容易流失客戶 電商網站可以設定電子商務觀看電子商務報表(轉換率/收益/客單價等)，由於我們只是單純的部落格，未來如果有機會的話再來介紹  Google Search Console：分析自然搜尋流量與站外排名  可以從成效報表觀察流量的變化，曝光 \u0026gt; 點擊 \u0026gt; 點閱率 \u0026gt; 排序 分析有哪些關鍵字跟頁面帶來流量 分析自然流量的來源是來自哪些地方 定期提交 sitemap 幫助網址被收錄，或是移除想拿掉的網址（sitemap 記得也要同步拿掉) 確認網站還有哪一些待改進的體驗  安裝 Google Analytics  登入你要使用 GA 的 Google 帳號 進到 https://analytics.google.com/ 填寫帳戶名稱，資料共用設定這部分可以自行判斷 填寫資源名稱 填寫商家資訊 接受 Google Analytics(分析)服務條款合約 選擇平台(我是部落格所以選網頁) 填寫網站串流網址跟名稱 會得到一個評估 ID G-xxxxxxxx (舊版為UA開頭) 把評估 ID 貼到 hugo 的 config 設定檔即可  GA4 將跨裝置的使用者行為串接起來，相較過去著重在停留時間、頁數，改以事件為核心的分析主體，對於數據的解讀方便許多\n使用 GA4 的即時報表確認資料是否已開始傳入\n或透過GTM/GA debugger套件確認是否有反應\nok 看起來成功囉！記得也檢查一下 404 頁面有無反應唷！\n安裝 Google search console  建議使用跟 GA 一樣的 Google 帳號 進到 https://search.google.com/search-console/welcome 選取資源類型，若跟我一樣是使用 GitHub pages 服務選右邊 填寫網址 驗證方法很多，因為剛剛已經安裝好 GA，帳號有編輯權，直接點第 3 種的 GA 驗證按鈕  ok 進到了資源頁面了！一般來說會需要等個 1 天時間跑資料\n在網站根目錄下建立 robots.txt 把 robots.txt 放在網站下的根目錄，使用hexo放在source資料夾下即可 下方是一個常見的範例，網址填入自己的版本\n1 2 3  User-agent: * Allow: / Sitemap: https://bacnotes.github.io/sitemap.xml   ＊Google 支援所有格式的標準 Sitemap 通訊協定，但目前不支援在 Sitemap 中使用 priority 屬性\n到 Google Search Console 提交 sitemap 生成靜態網頁的時候會自動產出 sitemap 檔案 網址是\u0026lt;你的網站名\u0026gt;/sitemap.xml e.g. https://bacnotes.github.io/sitemap.xml\n提交位置在 Google Search Console 索引區塊的 Sitemap 輸入你的 sitemap 網址即可，一般是 sitemap.xml\n使用 Google Search Console 的「要求建立索引」 發布文章後，會希望可以盡早被爬蟲爬取建立索引，hexo平台會自動生成sitemap 檔，很方便操作更新sitemap，但公司的行銷人員，可能不一定可以迅速取得工程師的即時協助 這時候可以點 Google Search Console 上方的輸入框，輸入文章網址，按下 enter就可以建立排程請爬蟲來看看這個網址 (也可以點側邊欄成效下方的網址審查，也會 focus 到這個框框)\n等待一段時間跑出結果\n點下方的「要求建立索引」，就會跟 Google 提交建立索引的要求且進入排程，爬蟲就會依照排程來看你剛剛提交的網址了\n跟 Google 提交 Sitemap 完之後，其他的搜尋引擎也需要嗎？ 我們用Statcounter看看目前搜尋引擎各家的市佔率 Statcounter 是一個網站流量分析工具，主要提供網頁瀏覽器跟搜尋引擎的使用分佈的訊息\n以下是上個月各家搜尋引擎全球市占率，Google 有 91.4%的市佔率，而其他家(bing, Baidu, Yahoo!)市占率大約都在個位數\n由於我們的使用者主要是在台灣，把條件設定成台灣\nGoogle 還是一樣市占率最高，且比剛剛全球數據的市佔率還高，為 9 成 4 看起來我們之後 SEO 還是專心於 Google，畢竟台灣大部分的使用者都使用 Google 搜尋\n最後，爬蟲大大快來我家吧\n","date":"2021-12-28T00:00:00+08:00","image":"https://bacnotes.github.io/p/google-seo-tools/myriam-jessier-VCtI-0qlVgA-unsplash_hu4b44d326edd3135b9f13e80e90e771b0_550794_120x120_fill_q75_box_smart1.jpg","permalink":"https://bacnotes.github.io/p/google-seo-tools/","title":"安裝SEO分析工具Google Analytics跟Google Search Console｜bacnotes備份筆記"},{"content":"關於部署的工具有很多，身為工程師的你一定聽過GitHub!\n為什麼用GitHub部署  因為免費(o) 因為用起來很親切，簡單又方便(o) 因為部署到生效的過程很快速(o) 因為部落格後面有GitHub域名很潮(x)  GitHub Pages是GitHub提供的免費靜態網頁託管服務 雖然是免費，不過用起來體驗也很好 那SEO表現呢? 這時候可以用ahrefs快速確認一下\nGitHub在網站權重跟外部連結數都有很好的表現 拿medium來當對手的話呢\nGitHub 加十分 🙌\n跟另一個也是很常拿來建立部落格的平台，且SEO客製化程度較高的wordpress相比呢\nGitHub 再加十分 🙌\n看起來是不錯的選擇唷！那麼來實作看看吧！\nGitHub Pages部署靜態網頁 GitHub Pages有兩種\n 專案型網址 https://username.github.io/reponame （一個帳號可以有很多個repo專案，每個專案都可以有一個靜態網頁） 帳號型網址 https://username.github.io （一個使用者帳號只會有一個，可以拿來經營個人網站）  專案型網址適合把Hugo這個部落格專案，備份到GitHub上(非部署)，執行步驟如下\n 新增一個GitHub Repo，Repo名自訂 cd到專案資料夾，輸入git init git branch -m main git add . git commit -m 'init project' # git msg 內容可自訂 git remote add origin \u0026lt;自訂repo網址\u0026gt; #如果電腦只有使用1組GitHub帳號，直接貼repo網址 #如果電腦本身有多組GitHub帳號，確認@host名:git網址結構是否有調整正確，可回到上一篇確認  這樣一來電腦裡的Hugo專案不見也不用擔心囉～之後還可以git clone下來\n作為部署部落格本身使用，執行步驟如下\n 新增一個GitHub Repo，Repo名為username.github.io(須完全符合) 在專案資料夾路徑下輸入 hugo，會生成靜態頁面檔案於public資料夾 cd public git init git branch -m main git add . git config --local user.name aaa #不需要多組帳號管理可跳過 git config --local user.email aaa@email.com #不需要多組帳號管理可跳過 git commit -m 'deploy' # git msg 內容可自訂 git remote add origin \u0026lt;repo網址\u0026gt; #注意事項同專案型網址 git push -f --set-upstream origin main # 強制覆蓋之前的紀錄  好的，若依照順序有執行成功，可以開始寫腳本檔案了!\n自動化部屬腳本deploy.sh  在專案資料夾的根目錄建立deploy.sh檔，貼上下方文字 repo網址記得替換成自己的，option依照自己狀況調整即可  1 2 3 4 5 6 7 8 9 10 11 12 13  hugo cd public git init git branch -m main git add . git config --local user.name aaa #不需要多組帳號管理可跳過 git config --local user.email aaa@email.com #不需要多組帳號管理可跳過 git commit -m \u0026#39;deploy\u0026#39; git remote add origin \u0026lt;repo網址\u0026gt; # if you have .ssh/config setting, remember to replace with right structure git push -f -u origin main cd -   參考文章: 部署Hugo個人網頁至GitHub\n","date":"2021-12-26T00:00:00Z","image":"https://bacnotes.github.io/p/github-deploy-hugo/mohammad-rahmani-q1p2DrLBtko-unsplash_hu34ce0191b88a37780da4e3c1a288bda4_3436174_120x120_fill_q75_box_smart1.jpg","permalink":"https://bacnotes.github.io/p/github-deploy-hugo/","title":"只要3秒，使用GitHub一鍵部署你的Hugo部落格｜bacnotes備份筆記"},{"content":"Um\u0026hellip;在部署前卡到了 Github 多組帳號權限的問題 如果你的電腦只有使用 1 組 GitHub 帳號，可以點下方連結直接到下一篇 只要 3 秒，使用 GitHub 一鍵部署你的 Hugo 部落格\n為什麼要用一台電腦使用多組 GitHub 帳號 當遠距工作變成時代趨勢，工作時勢必會有 1 組公司用的 GitHub 帳號(或 GitLab 或…其他的雲端協作平台)，但自己在寫 side project 也會用到 1 組 GitHub 帳號，那麼辦第 2 組 GitHub 帳號就好了吧（就跟 google 帳號一樣？\n但你在 GitHub 的新帳號開了一個 Repo，在編輯器的 terminal 依序輸入下方指令\n1 2 3 4 5 6  git init git add . git commit -m \u0026#39;some msg\u0026#39; git branch -M main git remote add origin \u0026#39;your repo\u0026#39; git push -u origin main   就會發現在最後一步跳出這個訊息\n ERROR: Permission to userB/repo.git denied to userA fatal: 無法讀取遠端版本庫。\n 要 commit 的時候，被最初註冊的 userA 帳號 deny\nUm\u0026hellip;啊！\n之前的帳號有設定一組對應的 SSH key 讓 GitHub 驗證身份，應該是 SSH key 的問題吧？ 有 2 組帳號，生 2 組 key 應該就沒問題了吧！欸不對，我的 terminal 在 git push 的時候，怎麼知道哪組帳號對應哪個 SSH key…\n上網查了一下相關文章，發現可以寫一個 config 來讓不同帳號對應各自的 key\n管理多組 SSH key 流程如下 aaa 為範例，可自由代入你的帳號\n 產生 SSH key ssh-keygen -t rsa -C \u0026quot;aaa@example.com\u0026quot; 決定要儲存的檔名(路徑) 在 Enter file in which to save the key (/Users/XXX/.ssh/id_rsa): 後方填入 /Users/aaa/.ssh/id_rsa_aaa *如果沒有新的命名，就會覆蓋原本的 id_rsa Enter passphrase(看個人，可以直接 enter 不設定密碼) Enter same passphrase again(如果有設定要再輸入一次，沒有就直接 enter) 把對應的公鑰(id_rsa_aaa.pub 裡面的文字)新增到 GitHub 的 SSH key，官方圖文教學 在.ssh 目錄下，touch 一個 config(不用副檔名)  1 2 3 4 5  Host gh.aaa HostName github.com User aaa PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_aaa   把 key 加入管理 ssh-add ~/.ssh/id_rsa_aaa 嘗試連線看看對應 host 是否有生效ssh -T git@gh.aaa  Hi aaa! You\u0026rsquo;ve successfully authenticated, but GitHub does not provide shell access.\n   看到上方訊息表示有成功連線囉！ 第 2 個帳號照著上方步驟寫在同個 config 檔案即可\n1 2 3 4 5 6 7 8 9 10 11  Host gh.aaa HostName github.com User aaa PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_aaa Host gh.bbb HostName github.com User bbb PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_bbb   注意：經過上面的設定檔後，repo 的位置會從預定的 git@github.com:ooo/ooo.git 變成 git@gh.aaa:ooo/ooo.git 後續在新增 repo 連結時需注意，不然可能吃不到 config 設定檔唷\n參考文章: [Git] 多個 SSH Key 與帳號的設定(Mac)\n","date":"2021-12-25T00:00:00Z","image":"https://bacnotes.github.io/p/github-ssh-key/maria-ziegler-jJnZg7vBfMs-unsplash_hu3d03a01dcc18bc5be0e67db3d8d209a6_39928_120x120_fill_q75_box_smart1.jpeg","permalink":"https://bacnotes.github.io/p/github-ssh-key/","title":"關於SSH key與多組GitHub帳號切換｜bacnotes備份筆記"},{"content":"為什麼工程師要寫部落格 身為一個專業的工程師，你也許會需要\n 一台筆電(o) 持續學習(o) 跟容量大的腦袋來備份知識(x)  Um\u0026hellip; 工程師的世界永遠有追不完的技術，自知腦容量沒有這麼大，記錄成部落格文字來比較可靠，而且\n 寫成部落格也有機會跟別人交流，也許還會有高手可以切磋(!\n 部落格架站選擇 - Jekyll, Hexo, Hugo, Gatsby 除了 hugo 外還有很多人氣的靜態網站生成器 Jekyll (Ruby) / Hexo (JavaScript) / Gatsby (React)等，也有很多比較文\n [Day06] Jekyll vs Hexo vs Hugo Hexo Hugo Vuepress Gatsby 静态网站生成器的选择  Hugo號稱部屬最快的框架，用 Go 語言寫的，也許未來有時間會想學學看這個 google 工程師團隊開發的語言，而且時間就是金錢啊！就先選用這個了！\n安裝 Hugo 如果是用 Mac，直接 homebrew 下載  如果沒用過 homebrew 套件管理軟體可以先下載homebrew brew install hugo 用 hugo version or hugo help 來檢查是否有新增成功  如果是用 Windows，可以使用 Chocolatey 下載   沒用過 ChocoLatey 套件管理工具的話，可以先參考這篇安裝說明 用指令安裝程式\u0026ndash;Chocolatey\n  下載完後來安裝 Hugo\n  基礎版是choco install hugo -confirm\n  Sass/SCSS version 是 choco install hugo-extended -confirm\n  看之後部落格選擇的主題，會使用到 Sass/SCSS 語法的就選後者\n 依照官方影片說明，在 C:\\下方新增 Hugo 資料夾   Hugo 資料夾下新增 Sites 跟 bin 資料夾(Sites 是專案資料夾，bin 是儲存執行檔案用) 到Hugo Releases 下載安裝檔，解壓縮完的檔案丟到 bin 資料夾 新增 window 開發環境變數，在變數 PATH 下新增一個值叫C:\\Hugo\\bin，讓全域都可以執行 hugo 命令 到其他資料夾用 hugo version or hugo help 來檢查是否有新增成功  新增網站的專案資料夾 ＊以下用 example.com 為部落格網址作為範例，這邊根據自己的網站名做修改即可(mac 跟 windows 流程大同小異)\n window 的使用者 cd 到C:\\Hugo\\Sites\u0026gt;，mac 的使用者 cd 到你設定的專案資料夾 執行hugo new site example.com  選擇與安裝喜歡的主題   到Hugo Themes找喜歡的主題\n  我選用的是 hugo-theme-stack \u0026ndash; git clone 你喜歡的主題到 theme 資料夾 \u0026ndash; 一開始我們的部落格裡面沒有內容，hugo-theme-stack 有提供範例， exampleSite 資料夾，我們用這個來覆蓋專案資料夾看看實際部落格效果 \u0026ndash; 在 example.com 網站資料夾下執行 hugo server\n\u0026ndash; 網址列查看 http://localhost:1313\n  哇真的出現了! 好感人啊！ 現在只有自己可以看到，下一篇會介紹如何使用 GitHub 來部署我們的部落格 只要 3 秒，使用 GitHub 一鍵部署你的 Hugo 部落格\n參考文章: [Day07] Let\u0026rsquo;s Hugo!\n","date":"2021-12-23T00:00:00Z","image":"https://bacnotes.github.io/p/hugo-blog/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://bacnotes.github.io/p/hugo-blog/","title":"工程師的技術部落格要怎麼架？使用Hugo!｜bacnotes備份筆記"}]